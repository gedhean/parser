// Code generated from MariaDBParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package mariadb // MariaDBParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MariaDBParser struct {
	*antlr.BaseParser
}

var MariaDBParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mariadbparserParserInit() {
	staticData := &MariaDBParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BODY'", "'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'",
		"'CAST'", "'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'",
		"'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'",
		"'CROSS'", "'CURRENT'", "'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'",
		"'DATABASE'", "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'",
		"'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'",
		"'DISTINCT'", "'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'",
		"'EMPTY'", "'ENCLOSED'", "'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'",
		"'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'",
		"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'",
		"'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'",
		"'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'",
		"'INTO'", "'IS'", "'ITERATE'", "'JOIN'", "'KEY'", "'KEYS'", "'KILL'",
		"'LATERAL'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'", "'LIMIT'",
		"'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOCKED'", "'LOOP'", "'LOW_PRIORITY'",
		"'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'",
		"'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'",
		"'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONAL'",
		"'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'", "'OUTER'", "'OUTFILE'",
		"'OVER'", "'PARTITION'", "'PRIMARY'", "'PACKAGE'", "'PROCEDURE'", "'PURGE'",
		"'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", "'RELEASE'",
		"'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", "'RESTRICT'",
		"'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'",
		"'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'",
		"'SKIP'", "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'",
		"'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'",
		"'STACKED'", "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'",
		"'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'",
		"'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'",
		"'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'",
		"'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'",
		"'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", "'INT2'", "'INT3'",
		"'INT4'", "'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'",
		"'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'",
		"'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'",
		"'VARCHAR'", "'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'",
		"'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", "'TINYTEXT'",
		"'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'",
		"'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'",
		"'HOUR_SECOND'", "'MINUTE_SECOND'", "'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'",
		"'HOUR_MICROSECOND'", "'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'",
		"'JSON_ARRAY_APPEND'", "'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'",
		"'JSON_DEPTH'", "'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'",
		"'JSON_MERGE'", "'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'",
		"'JSON_OBJECTAGG'", "'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'",
		"'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'",
		"'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'",
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'",
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'",
		"'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'",
		"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
		"'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", "'IDENTIFIED'",
		"'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'",
		"'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", "'INSTANT'",
		"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'",
		"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'",
		"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOCALES'", "'LOGFILE'",
		"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'",
		"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'",
		"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'",
		"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'",
		"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'",
		"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'",
		"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'",
		"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'",
		"'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'",
		"'MYSQL'", "'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'",
		"'NEXT'", "'NO'", "'NOCACHE'", "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'",
		"'NOMINVALUE'", "'NOWAIT'", "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'",
		"'OFFSET'", "'OF'", "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'",
		"'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", "'OWNER'", "'PACK_KEYS'",
		"'PAGE'", "'PAGE_COMPRESSED'", "'PAGE_COMPRESSION_LEVEL'", "'PARSER'",
		"'PARTIAL'", "'PARTITIONING'", "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'",
		"'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'",
		"'PRECEDING'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUERY_RESPONSE_TIME'",
		"'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'", "'REDO_BUFFER_SIZE'",
		"'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", "'RELAYLOG'",
		"'REMOVE'", "'REORGANIZE'", "'REPAIR'", "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'",
		"'REPLICATE_IGNORE_DB'", "'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'",
		"'REPLICATE_WILD_DO_TABLE'", "'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'",
		"'RESET'", "'RESTART'", "'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'",
		"'RETURNS'", "'REUSE'", "'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'",
		"'ROW'", "'ROWS'", "'ROW_FORMAT'", "'RTREE'", "'SAVEPOINT'", "'SCHEDULE'",
		"'SECURITY'", "'SEQUENCE'", "'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'",
		"'SIGNED'", "'SIMPLE'", "'SLAVE'", "'SLAVES'", "'SLOW'", "'SNAPSHOT'",
		"'SOCKET'", "'SOME'", "'SONAME'", "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'",
		"'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'",
		"'SQL_CACHE'", "'SQL_NO_CACHE'", "'SQL_THREAD'", "'START'", "'STARTS'",
		"'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", "'STATS_SAMPLE_PAGES'",
		"'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", "'STRING'", "'SUBCLASS_ORIGIN'",
		"'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'",
		"'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", "'TABLE_TYPE'", "'TEMPORARY'",
		"'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", "'TRANSACTION'", "'TRANSACTIONAL'",
		"'TRIGGERS'", "'TRUNCATE'", "'TYPES'", "'UNBOUNDED'", "'UNDEFINED'",
		"'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'",
		"'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'WSREP_MEMBERSHIP'",
		"'WSREP_STATUS'", "'X509'", "'XA'", "'XML'", "'YES'", "'EUR'", "'USA'",
		"'JIS'", "'ISO'", "'INTERNAL'", "'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'",
		"'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", "'USER_STATISTICS'",
		"'CLIENT_STATISTICS'", "'INDEX_STATISTICS'", "'TABLE_STATISTICS'", "'ADMIN'",
		"'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ADMIN'", "'BACKUP_ADMIN'", "'BINLOG_ADMIN'",
		"'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", "'CONNECTION_ADMIN'",
		"'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'", "'FIREWALL_ADMIN'",
		"'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", "'FLUSH_TABLES'",
		"'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'",
		"'INNODB_REDO_LOG_ENABLE'", "'INVOKE'", "'LAMBDA'", "'NDB_STORED_USER'",
		"'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'", "'PRIVILEGES'",
		"'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
		"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'",
		"'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'",
		"'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'",
		"'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'",
		"'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'",
		"'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'",
		"'Y'", "'X'", "'VIA'", "'LASTVAL'", "'NEXTVAL'", "'SETVAL'", "'PREVIOUS'",
		"'PERSISTENT'", "'BINLOG_MONITOR'", "'BINLOG_REPLAY'", "'FEDERATED_ADMIN'",
		"'READ_ONLY_ADMIN'", "'REPLICA'", "'REPLICAS'", "'REPLICATION_MASTER_ADMIN'",
		"'MONITOR'", "'READ_ONLY'", "'REPLAY'", "':='", "'+='", "'-='", "'*='",
		"'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", "'%'", "'+'",
		"'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'",
		"'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", "'1'", "'2'",
		"'''", "'\"'", "'`'", "':'",
	}
	staticData.SymbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"ATTRIBUTE", "BEFORE", "BETWEEN", "BODY", "BOTH", "BUCKETS", "BY", "CALL",
		"CASCADE", "CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE",
		"COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE",
		"CROSS", "CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", "DATABASE",
		"DATABASES", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE",
		"DETERMINISTIC", "DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH",
		"ELSE", "ELSEIF", "EMPTY", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS",
		"EXIT", "EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM",
		"FULLTEXT", "GENERATED", "GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY",
		"HISTOGRAM", "IF", "IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER",
		"INOUT", "INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY",
		"KEYS", "KILL", "LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT",
		"LINEAR", "LINES", "LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY",
		"MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE",
		"MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL_LITERAL",
		"NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY", "OR",
		"ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY",
		"PACKAGE", "PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES",
		"REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL",
		"RESTRICT", "RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA",
		"SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_",
		"SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT",
		"SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING",
		"STATEMENT", "STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING",
		"TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED",
		"UPDATE", "USAGE", "USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE",
		"WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT",
		"MIDDLEINT", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER",
		"BIGINT", "REAL", "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8",
		"DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME",
		"YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY",
		"TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT",
		"MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH",
		"DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND",
		"MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND",
		"DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND",
		"JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH",
		"JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE",
		"JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG",
		"JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE",
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH",
		"JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE",
		"JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "NESTED", "ORDINALITY",
		"PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST",
		"DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD",
		"MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER",
		"STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP",
		"VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME",
		"CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP",
		"NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE",
		"UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE",
		"ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE",
		"AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK",
		"BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED",
		"CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT",
		"CLOSE", "CLUSTERING", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT",
		"COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED",
		"COMPRESSION", "CONCURRENT", "CONNECT", "CONNECTION", "CONSISTENT",
		"CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", "CONTAINS",
		"CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CYCLE", "CURSOR_NAME", "DATA",
		"DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE",
		"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE",
		"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID",
		"END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN",
		"EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT",
		"EXTENDED", "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS",
		"FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING",
		"FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
		"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS",
		"IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES",
		"INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT",
		"INVISIBLE", "INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER",
		"JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL",
		"LIST", "LOCAL", "LOCALES", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION",
		"MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST",
		"MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT",
		"MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH",
		"MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH",
		"MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR",
		"MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR",
		"MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT",
		"MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO",
		"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY",
		"NOCYCLE", "NOMAXVALUE", "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE",
		"ODBC", "OFFLINE", "OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE",
		"ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS",
		"PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", "PARSER", "PARTIAL",
		"PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PHASE",
		"PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUERY_RESPONSE_TIME", "QUICK", "REBUILD", "RECOVER",
		"RECURSIVE", "REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE",
		"RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB",
		"REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE",
		"REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE",
		"REPLICATION", "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING",
		"RETURNS", "REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS",
		"ROW_FORMAT", "RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE",
		"SERVER", "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE",
		"SLAVES", "SLOW", "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS",
		"SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS",
		"SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE", "SQL_THREAD", "START",
		"STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", "STATS_SAMPLE_PAGES",
		"STATUS", "STOP", "STORAGE", "STORED", "STRING", "SUBCLASS_ORIGIN",
		"SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND", "SWAPS", "SWITCHES",
		"TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY", "TEMPTABLE",
		"THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL", "TRIGGERS", "TRUNCATE",
		"TYPES", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL",
		"UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "WSREP_MEMBERSHIP",
		"WSREP_STATUS", "X509", "XA", "XML", "YES", "EUR", "USA", "JIS", "ISO",
		"INTERNAL", "QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", "SECOND",
		"MICROSECOND", "USER_STATISTICS", "CLIENT_STATISTICS", "INDEX_STATISTICS",
		"TABLE_STATISTICS", "ADMIN", "APPLICATION_PASSWORD_ADMIN", "AUDIT_ADMIN",
		"BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN",
		"CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE", "FILE", "FIREWALL_ADMIN",
		"FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS", "FLUSH_TABLES",
		"FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE",
		"INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN",
		"PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER",
		"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER",
		"ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN",
		"SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN",
		"TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VIA",
		"LASTVAL", "NEXTVAL", "SETVAL", "PREVIOUS", "PERSISTENT", "BINLOG_MONITOR",
		"BINLOG_REPLAY", "FEDERATED_ADMIN", "READ_ONLY_ADMIN", "REPLICA", "REPLICAS",
		"REPLICATION_MASTER_ADMIN", "MONITOR", "READ_ONLY", "REPLAY", "VAR_ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL",
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"STRING_USER_NAME", "IP_ADDRESS", "STRING_USER_NAME_MARIADB", "LOCAL_ID",
		"GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.RuleNames = []string{
		"root", "sqlStatements", "sqlStatement", "setStatementFor", "emptyStatement_",
		"ddlStatement", "dmlStatement", "transactionStatement", "replicationStatement",
		"preparedStatement", "compoundStatement", "administrationStatement",
		"utilityStatement", "createDatabase", "createEvent", "createIndex",
		"createLogfileGroup", "createProcedure", "createFunction", "createRole",
		"createServer", "createTable", "createTablespaceInnodb", "createTablespaceNdb",
		"createTrigger", "withClause", "commonTableExpressions", "cteName",
		"cteColumnName", "createView", "createSequence", "sequenceSpec", "createDatabaseOption",
		"charSet", "currentUserExpression", "ownerStatement", "scheduleExpression",
		"timestampValue", "intervalExpr", "intervalType", "enableType", "indexType",
		"indexOption", "procedureParameter", "functionParameter", "routineOption",
		"serverOption", "createDefinitions", "createDefinition", "columnDefinition",
		"columnConstraint", "tableConstraint", "referenceDefinition", "referenceAction",
		"referenceControlType", "indexColumnDefinition", "tableOption", "tableType",
		"tablespaceStorage", "partitionDefinitions", "partitionFunctionDefinition",
		"subpartitionFunctionDefinition", "partitionDefinition", "partitionDefinerAtom",
		"partitionDefinerVector", "subpartitionDefinition", "partitionOption",
		"alterDatabase", "alterEvent", "alterFunction", "alterInstance", "alterLogfileGroup",
		"alterProcedure", "alterServer", "alterTable", "alterTablespace", "alterView",
		"alterSequence", "alterSpecification", "dropDatabase", "dropEvent",
		"dropIndex", "dropLogfileGroup", "dropProcedure", "dropFunction", "dropServer",
		"dropTable", "dropTablespace", "dropTrigger", "dropView", "dropRole",
		"setRole", "dropSequence", "renameTable", "renameTableClause", "truncateTable",
		"callStatement", "deleteStatement", "doStatement", "handlerStatement",
		"insertStatement", "loadDataStatement", "loadXmlStatement", "replaceStatement",
		"selectStatement", "updateStatement", "valuesStatement", "insertStatementValue",
		"updatedElement", "assignmentField", "lockClause", "singleDeleteStatement",
		"multipleDeleteStatement", "handlerOpenStatement", "handlerReadIndexStatement",
		"handlerReadStatement", "handlerCloseStatement", "singleUpdateStatement",
		"multipleUpdateStatement", "orderByClause", "orderByExpression", "tableSources",
		"tableSource", "tableSourceItem", "indexHint", "indexHintType", "joinPart",
		"queryExpression", "queryExpressionNointo", "querySpecification", "querySpecificationNointo",
		"unionParenthesis", "unionStatement", "lateralStatement", "jsonTable",
		"jsonColumnList", "jsonColumn", "jsonOnEmpty", "jsonOnError", "selectSpec",
		"selectElements", "selectElement", "selectIntoExpression", "selectFieldsInto",
		"selectLinesInto", "fromClause", "groupByClause", "havingClause", "windowClause",
		"groupByItem", "limitClause", "limitClauseAtom", "startTransaction",
		"beginWork", "commitWork", "rollbackWork", "savepointStatement", "rollbackStatement",
		"releaseStatement", "lockTables", "unlockTables", "setAutocommitStatement",
		"setTransactionStatement", "transactionMode", "lockTableElement", "lockAction",
		"transactionOption", "transactionLevel", "changeMaster", "changeReplicationFilter",
		"purgeBinaryLogs", "resetMaster", "resetSlave", "startSlave", "stopSlave",
		"startGroupReplication", "stopGroupReplication", "masterOption", "stringMasterOption",
		"decimalMasterOption", "boolMasterOption", "channelOption", "replicationFilter",
		"tablePair", "threadType", "untilOption", "connectionOption", "gtuidSet",
		"xaStartTransaction", "xaEndTransaction", "xaPrepareStatement", "xaCommitWork",
		"xaRollbackWork", "xaRecoverWork", "prepareStatement", "executeStatement",
		"deallocatePrepare", "routineBody", "blockStatement", "caseStatement",
		"ifStatement", "iterateStatement", "leaveStatement", "loopStatement",
		"repeatStatement", "returnStatement", "whileStatement", "cursorStatement",
		"declareVariable", "declareCondition", "declareCursor", "declareHandler",
		"handlerConditionValue", "procedureSqlStatement", "caseAlternative",
		"elifAlternative", "alterUser", "createUser", "dropUser", "grantStatement",
		"roleOption", "grantProxy", "renameUser", "revokeStatement", "revokeProxy",
		"setPasswordStatement", "userSpecification", "userAuthOption", "authenticationRule",
		"tlsOption", "userResourceOption", "userPasswordOption", "userLockOption",
		"privelegeClause", "privilege", "privilegeLevel", "renameUserClause",
		"analyzeTable", "checkTable", "checksumTable", "optimizeTable", "repairTable",
		"checkTableOption", "createUdfunction", "installPlugin", "uninstallPlugin",
		"setStatement", "showStatement", "explainStatement", "variableClause",
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity",
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement",
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement",
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes",
		"simpleDescribeStatement", "fullDescribeStatement", "formatJsonStatement",
		"helpStatement", "useStatement", "signalStatement", "resignalStatement",
		"signalConditionInformation", "diagnosticsStatement", "diagnosticsConditionInformationName",
		"describeObjectClause", "fullId", "tableName", "roleName", "fullColumnName",
		"indexColumnName", "userName", "mysqlVariable", "charsetName", "collationName",
		"engineName", "encryptedLiteral", "uuidSet", "xid", "xuidStringId",
		"authPlugin", "uid", "simpleId", "dottedId", "decimalLiteral", "fileSizeLiteral",
		"stringLiteral", "booleanLiteral", "hexadecimalLiteral", "nullNotnull",
		"constant", "dataType", "collectionOptions", "convertedDataType", "lengthOneDimension",
		"lengthTwoDimension", "lengthTwoOptionalDimension", "uidList", "tables",
		"indexColumnNames", "expressions", "expressionsWithDefaults", "constants",
		"simpleStrings", "userVariables", "defaultValue", "currentTimestamp",
		"expressionOrDefault", "ifExists", "ifNotExists", "orReplace", "waitNowaitClause",
		"lockOption", "functionCall", "specificFunction", "caseFuncAlternative",
		"levelsInWeightString", "levelInWeightListElement", "aggregateWindowedFunction",
		"nonAggregateWindowedFunction", "overClause", "windowSpec", "windowName",
		"frameClause", "frameUnits", "frameExtent", "frameBetween", "frameRange",
		"partitionClause", "scalarFunctionName", "passwordFunctionClause", "functionArgs",
		"functionArg", "expression", "predicate", "expressionAtom", "unaryOperator",
		"comparisonOperator", "logicalOperator", "bitOperator", "mathOperator",
		"jsonOperator", "charsetNameBase", "transactionLevelBase", "privilegesBase",
		"intervalTypeBase", "dataTypeBase", "keywordsCanBeId", "functionNameBase",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1184, 7583, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 1, 0, 3, 0,
		722, 8, 0, 1, 0, 1, 0, 3, 0, 726, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3,
		1, 733, 8, 1, 1, 1, 3, 1, 736, 8, 1, 1, 1, 5, 1, 739, 8, 1, 10, 1, 12,
		1, 742, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 747, 8, 1, 1, 1, 3, 1, 750, 8, 1,
		1, 1, 3, 1, 753, 8, 1, 1, 2, 3, 2, 756, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 3, 2, 765, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 5, 3, 776, 8, 3, 10, 3, 12, 3, 779, 9, 3, 1, 3, 1, 3, 1,
		4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 826, 8, 5, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 839, 8, 6, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 850, 8, 7, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 3, 8, 867, 8, 8, 1, 9, 1, 9, 1, 9, 3, 9, 872, 8, 9, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 884,
		8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 912, 8, 11, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 921, 8, 12, 1, 13, 1, 13,
		1, 13, 3, 13, 926, 8, 13, 1, 13, 1, 13, 5, 13, 930, 8, 13, 10, 13, 12,
		13, 933, 9, 13, 1, 14, 1, 14, 3, 14, 937, 8, 14, 1, 14, 1, 14, 3, 14, 941,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 950, 8,
		14, 1, 14, 3, 14, 953, 8, 14, 1, 14, 3, 14, 956, 8, 14, 1, 14, 1, 14, 3,
		14, 960, 8, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 3, 15, 967, 8, 15, 1,
		15, 3, 15, 970, 8, 15, 1, 15, 3, 15, 973, 8, 15, 1, 15, 1, 15, 3, 15, 977,
		8, 15, 1, 15, 1, 15, 3, 15, 981, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 987, 8, 15, 1, 15, 5, 15, 990, 8, 15, 10, 15, 12, 15, 993, 9, 15, 1,
		15, 1, 15, 3, 15, 997, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1002, 8, 15,
		1, 15, 5, 15, 1005, 8, 15, 10, 15, 12, 15, 1008, 9, 15, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1019, 8, 16, 1, 16,
		3, 16, 1022, 8, 16, 1, 16, 1, 16, 3, 16, 1026, 8, 16, 1, 16, 3, 16, 1029,
		8, 16, 1, 16, 1, 16, 3, 16, 1033, 8, 16, 1, 16, 3, 16, 1036, 8, 16, 1,
		16, 1, 16, 3, 16, 1040, 8, 16, 1, 16, 3, 16, 1043, 8, 16, 1, 16, 3, 16,
		1046, 8, 16, 1, 16, 1, 16, 3, 16, 1050, 8, 16, 1, 16, 3, 16, 1053, 8, 16,
		1, 16, 1, 16, 3, 16, 1057, 8, 16, 1, 16, 1, 16, 1, 17, 1, 17, 3, 17, 1063,
		8, 17, 1, 17, 3, 17, 1066, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1072,
		8, 17, 1, 17, 1, 17, 5, 17, 1076, 8, 17, 10, 17, 12, 17, 1079, 9, 17, 1,
		17, 1, 17, 5, 17, 1083, 8, 17, 10, 17, 12, 17, 1086, 9, 17, 1, 17, 1, 17,
		1, 18, 1, 18, 3, 18, 1092, 8, 18, 1, 18, 3, 18, 1095, 8, 18, 1, 18, 3,
		18, 1098, 8, 18, 1, 18, 1, 18, 3, 18, 1102, 8, 18, 1, 18, 1, 18, 1, 18,
		3, 18, 1107, 8, 18, 1, 18, 1, 18, 5, 18, 1111, 8, 18, 10, 18, 12, 18, 1114,
		9, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 1120, 8, 18, 10, 18, 12, 18,
		1123, 9, 18, 1, 18, 1, 18, 3, 18, 1127, 8, 18, 1, 19, 1, 19, 1, 19, 3,
		19, 1132, 8, 19, 1, 19, 1, 19, 1, 19, 5, 19, 1137, 8, 19, 10, 19, 12, 19,
		1140, 9, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 5, 20, 1154, 8, 20, 10, 20, 12, 20, 1157, 9, 20,
		1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 1163, 8, 21, 1, 21, 3, 21, 1166, 8,
		21, 1, 21, 1, 21, 3, 21, 1170, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 1, 21, 3, 21, 1180, 8, 21, 1, 21, 1, 21, 3, 21, 1184, 8,
		21, 1, 21, 3, 21, 1187, 8, 21, 1, 21, 1, 21, 3, 21, 1191, 8, 21, 1, 21,
		1, 21, 3, 21, 1195, 8, 21, 1, 21, 1, 21, 3, 21, 1199, 8, 21, 1, 21, 5,
		21, 1202, 8, 21, 10, 21, 12, 21, 1205, 9, 21, 3, 21, 1207, 8, 21, 1, 21,
		3, 21, 1210, 8, 21, 1, 21, 3, 21, 1213, 8, 21, 1, 21, 3, 21, 1216, 8, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1222, 8, 21, 1, 21, 3, 21, 1225, 8,
		21, 1, 21, 1, 21, 3, 21, 1229, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21,
		1235, 8, 21, 1, 21, 5, 21, 1238, 8, 21, 10, 21, 12, 21, 1241, 9, 21, 3,
		21, 1243, 8, 21, 1, 21, 3, 21, 1246, 8, 21, 3, 21, 1248, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1259, 8,
		22, 1, 22, 1, 22, 3, 22, 1263, 8, 22, 1, 22, 3, 22, 1266, 8, 22, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 3, 23, 1280, 8, 23, 1, 23, 3, 23, 1283, 8, 23, 1, 23, 1, 23, 3, 23,
		1287, 8, 23, 1, 23, 3, 23, 1290, 8, 23, 1, 23, 1, 23, 3, 23, 1294, 8, 23,
		1, 23, 3, 23, 1297, 8, 23, 1, 23, 1, 23, 3, 23, 1301, 8, 23, 1, 23, 3,
		23, 1304, 8, 23, 1, 23, 1, 23, 3, 23, 1308, 8, 23, 1, 23, 3, 23, 1311,
		8, 23, 1, 23, 3, 23, 1314, 8, 23, 1, 23, 1, 23, 3, 23, 1318, 8, 23, 1,
		23, 3, 23, 1321, 8, 23, 1, 23, 1, 23, 3, 23, 1325, 8, 23, 1, 23, 1, 23,
		1, 24, 1, 24, 3, 24, 1331, 8, 24, 1, 24, 3, 24, 1334, 8, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24,
		1347, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 1353, 8, 25, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 1362, 8, 26, 10, 26, 12,
		26, 1365, 9, 26, 1, 26, 1, 26, 3, 26, 1369, 8, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 3, 26, 1377, 8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1,
		29, 1, 29, 3, 29, 1385, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1390, 8, 29,
		1, 29, 3, 29, 1393, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1398, 8, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1406, 8, 29, 1, 29, 1, 29,
		1, 29, 3, 29, 1411, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1417, 8,
		29, 1, 29, 1, 29, 1, 29, 3, 29, 1422, 8, 29, 1, 29, 1, 29, 3, 29, 1426,
		8, 29, 3, 29, 1428, 8, 29, 1, 30, 1, 30, 3, 30, 1432, 8, 30, 1, 30, 3,
		30, 1435, 8, 30, 1, 30, 1, 30, 3, 30, 1439, 8, 30, 1, 30, 1, 30, 1, 30,
		5, 30, 1444, 8, 30, 10, 30, 12, 30, 1447, 9, 30, 1, 31, 1, 31, 3, 31, 1451,
		8, 31, 1, 31, 1, 31, 1, 31, 3, 31, 1456, 8, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 3, 31, 1464, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 1472, 8, 31, 1, 31, 1, 31, 1, 31, 3, 31, 1477, 8, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 1485, 8, 31, 1, 31, 3, 31,
		1488, 8, 31, 1, 32, 3, 32, 1491, 8, 32, 1, 32, 1, 32, 3, 32, 1495, 8, 32,
		1, 32, 1, 32, 3, 32, 1499, 8, 32, 1, 32, 3, 32, 1502, 8, 32, 1, 32, 1,
		32, 3, 32, 1506, 8, 32, 1, 32, 1, 32, 3, 32, 1510, 8, 32, 1, 32, 1, 32,
		3, 32, 1514, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 1520, 8, 32, 1,
		32, 3, 32, 1523, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1530,
		8, 33, 1, 34, 1, 34, 1, 34, 3, 34, 1535, 8, 34, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 3, 35, 1542, 8, 35, 1, 36, 1, 36, 1, 36, 5, 36, 1547, 8, 36,
		10, 36, 12, 36, 1550, 9, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1555, 8, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 5, 36, 1561, 8, 36, 10, 36, 12, 36, 1564, 9, 36,
		3, 36, 1566, 8, 36, 1, 36, 1, 36, 1, 36, 5, 36, 1571, 8, 36, 10, 36, 12,
		36, 1574, 9, 36, 3, 36, 1576, 8, 36, 3, 36, 1578, 8, 36, 1, 37, 1, 37,
		1, 37, 1, 37, 3, 37, 1584, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1590,
		8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 1607, 8, 39, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 1614, 8, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1,
		42, 3, 42, 1621, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 3, 42, 1633, 8, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1638,
		8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1647, 8,
		42, 3, 42, 1649, 8, 42, 1, 43, 3, 43, 1652, 8, 43, 1, 43, 1, 43, 1, 43,
		1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1665, 8,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 3, 45, 1678, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1683, 8, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 3, 46, 1699, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 5,
		47, 1705, 8, 47, 10, 47, 12, 47, 1708, 9, 47, 1, 47, 1, 47, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 3, 48, 1717, 8, 48, 1, 49, 1, 49, 5, 49, 1721, 8,
		49, 10, 49, 12, 49, 1724, 9, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 3, 50, 1735, 8, 50, 1, 50, 3, 50, 1738, 8, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 1743, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1756, 8, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1763, 8, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 3, 50, 1770, 8, 50, 3, 50, 1772, 8, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 3, 50, 1779, 8, 50, 1, 51, 1, 51, 3, 51, 1783, 8, 51, 3,
		51, 1785, 8, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1790, 8, 51, 1, 51, 3, 51,
		1793, 8, 51, 1, 51, 1, 51, 5, 51, 1797, 8, 51, 10, 51, 12, 51, 1800, 9,
		51, 1, 51, 1, 51, 3, 51, 1804, 8, 51, 3, 51, 1806, 8, 51, 1, 51, 1, 51,
		3, 51, 1810, 8, 51, 1, 51, 3, 51, 1813, 8, 51, 1, 51, 3, 51, 1816, 8, 51,
		1, 51, 1, 51, 5, 51, 1820, 8, 51, 10, 51, 12, 51, 1823, 9, 51, 1, 51, 1,
		51, 3, 51, 1827, 8, 51, 3, 51, 1829, 8, 51, 1, 51, 1, 51, 1, 51, 3, 51,
		1834, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1841, 8, 51, 3,
		51, 1843, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1850, 8, 51,
		1, 52, 1, 52, 1, 52, 3, 52, 1855, 8, 52, 1, 52, 1, 52, 3, 52, 1859, 8,
		52, 1, 52, 3, 52, 1862, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		3, 53, 1870, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1878,
		8, 53, 3, 53, 1880, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3,
		54, 1888, 8, 54, 1, 55, 1, 55, 3, 55, 1892, 8, 55, 1, 55, 3, 55, 1895,
		8, 55, 1, 55, 1, 55, 5, 55, 1899, 8, 55, 10, 55, 12, 55, 1902, 9, 55, 1,
		55, 1, 55, 3, 55, 1906, 8, 55, 1, 55, 3, 55, 1909, 8, 55, 1, 55, 1, 55,
		5, 55, 1913, 8, 55, 10, 55, 12, 55, 1916, 9, 55, 3, 55, 1918, 8, 55, 1,
		56, 1, 56, 3, 56, 1922, 8, 56, 1, 56, 3, 56, 1925, 8, 56, 1, 56, 1, 56,
		3, 56, 1929, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1934, 8, 56, 1, 56, 1,
		56, 1, 56, 3, 56, 1939, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1944, 8, 56,
		1, 56, 1, 56, 3, 56, 1948, 8, 56, 1, 56, 1, 56, 3, 56, 1952, 8, 56, 1,
		56, 1, 56, 3, 56, 1956, 8, 56, 1, 56, 1, 56, 3, 56, 1960, 8, 56, 1, 56,
		1, 56, 3, 56, 1964, 8, 56, 1, 56, 1, 56, 3, 56, 1968, 8, 56, 1, 56, 1,
		56, 1, 56, 3, 56, 1973, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1978, 8, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 1983, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 1989, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1994, 8, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 1999, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2004, 8, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 3, 56, 2010, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56,
		2015, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2020, 8, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 3, 56, 2026, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2031, 8, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 2036, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2041,
		8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2046, 8, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 2051, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2056, 8, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 2061, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2068,
		8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2073, 8, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 2078, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2083, 8, 56, 1, 56, 1, 56,
		3, 56, 2087, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2092, 8, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2100, 8, 56, 1, 56, 1, 56, 1, 56,
		3, 56, 2105, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2111, 8, 56, 1,
		57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59,
		2123, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 2130, 8, 59, 3,
		59, 2132, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2138, 8, 59, 10, 59,
		12, 59, 2141, 9, 59, 1, 59, 1, 59, 3, 59, 2145, 8, 59, 1, 60, 3, 60, 2148,
		8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 2156, 8, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 3, 60, 2162, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3,
		60, 2178, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 3, 60, 2190, 8, 60, 3, 60, 2192, 8, 60, 1, 61, 3, 61, 2195,
		8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 2203, 8, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 3, 61, 2209, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		3, 61, 2215, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 5, 62, 2226, 8, 62, 10, 62, 12, 62, 2229, 9, 62, 1, 62, 1, 62,
		5, 62, 2233, 8, 62, 10, 62, 12, 62, 2236, 9, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 5, 62, 2242, 8, 62, 10, 62, 12, 62, 2245, 9, 62, 1, 62, 1, 62, 3, 62,
		2249, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2258,
		8, 62, 10, 62, 12, 62, 2261, 9, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62,
		2267, 8, 62, 10, 62, 12, 62, 2270, 9, 62, 1, 62, 1, 62, 3, 62, 2274, 8,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2284,
		8, 62, 10, 62, 12, 62, 2287, 9, 62, 1, 62, 1, 62, 5, 62, 2291, 8, 62, 10,
		62, 12, 62, 2294, 9, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2300, 8, 62,
		10, 62, 12, 62, 2303, 9, 62, 1, 62, 1, 62, 3, 62, 2307, 8, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2317, 8, 62, 10, 62,
		12, 62, 2320, 9, 62, 1, 62, 1, 62, 5, 62, 2324, 8, 62, 10, 62, 12, 62,
		2327, 9, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 2333, 8, 62, 10, 62, 12,
		62, 2336, 9, 62, 1, 62, 1, 62, 3, 62, 2340, 8, 62, 1, 62, 1, 62, 1, 62,
		5, 62, 2345, 8, 62, 10, 62, 12, 62, 2348, 9, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 5, 62, 2354, 8, 62, 10, 62, 12, 62, 2357, 9, 62, 1, 62, 1, 62, 3, 62,
		2361, 8, 62, 3, 62, 2363, 8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 2368, 8, 63,
		1, 64, 1, 64, 1, 64, 1, 64, 4, 64, 2374, 8, 64, 11, 64, 12, 64, 2375, 1,
		64, 1, 64, 1, 65, 1, 65, 1, 65, 5, 65, 2383, 8, 65, 10, 65, 12, 65, 2386,
		9, 65, 1, 66, 3, 66, 2389, 8, 66, 1, 66, 3, 66, 2392, 8, 66, 1, 66, 1,
		66, 3, 66, 2396, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 2401, 8, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 3, 66, 2407, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3,
		66, 2413, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 2418, 8, 66, 1, 66, 1, 66,
		1, 66, 3, 66, 2423, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 2428, 8, 66, 1,
		66, 1, 66, 1, 66, 3, 66, 2433, 8, 66, 1, 66, 3, 66, 2436, 8, 66, 1, 67,
		1, 67, 1, 67, 3, 67, 2441, 8, 67, 1, 67, 4, 67, 2444, 8, 67, 11, 67, 12,
		67, 2445, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67,
		2456, 8, 67, 1, 68, 1, 68, 3, 68, 2460, 8, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 3, 68, 2467, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 2472, 8, 68,
		1, 68, 3, 68, 2475, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 2480, 8, 68, 1,
		68, 3, 68, 2483, 8, 68, 1, 68, 1, 68, 3, 68, 2487, 8, 68, 1, 68, 1, 68,
		3, 68, 2491, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 2497, 8, 69, 10,
		69, 12, 69, 2500, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 2518,
		8, 71, 1, 71, 3, 71, 2521, 8, 71, 1, 71, 3, 71, 2524, 8, 71, 1, 71, 1,
		71, 3, 71, 2528, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72,
		2536, 8, 72, 10, 72, 12, 72, 2539, 9, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 5, 73, 2549, 8, 73, 10, 73, 12, 73, 2552, 9, 73,
		1, 73, 1, 73, 1, 74, 1, 74, 3, 74, 2558, 8, 74, 1, 74, 3, 74, 2561, 8,
		74, 1, 74, 1, 74, 1, 74, 3, 74, 2566, 8, 74, 1, 74, 1, 74, 1, 74, 5, 74,
		2571, 8, 74, 10, 74, 12, 74, 2574, 9, 74, 3, 74, 2576, 8, 74, 1, 74, 3,
		74, 2579, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 3, 75, 2590, 8, 75, 1, 75, 3, 75, 2593, 8, 75, 1, 75, 1, 75, 3,
		75, 2597, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 2605,
		8, 76, 1, 76, 3, 76, 2608, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 2613, 8,
		76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 2621, 8, 76, 1, 76,
		1, 76, 1, 76, 1, 76, 3, 76, 2627, 8, 76, 1, 76, 1, 76, 3, 76, 2631, 8,
		76, 1, 77, 1, 77, 1, 77, 3, 77, 2636, 8, 77, 1, 77, 1, 77, 4, 77, 2640,
		8, 77, 11, 77, 12, 77, 2641, 1, 78, 1, 78, 3, 78, 2646, 8, 78, 1, 78, 5,
		78, 2649, 8, 78, 10, 78, 12, 78, 2652, 9, 78, 1, 78, 1, 78, 3, 78, 2656,
		8, 78, 1, 78, 3, 78, 2659, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3,
		78, 2666, 8, 78, 1, 78, 1, 78, 3, 78, 2670, 8, 78, 1, 78, 3, 78, 2673,
		8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 2682, 8,
		78, 10, 78, 12, 78, 2685, 9, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3,
		78, 2692, 8, 78, 1, 78, 3, 78, 2695, 8, 78, 1, 78, 3, 78, 2698, 8, 78,
		1, 78, 1, 78, 5, 78, 2702, 8, 78, 10, 78, 12, 78, 2705, 9, 78, 1, 78, 1,
		78, 1, 78, 3, 78, 2710, 8, 78, 3, 78, 2712, 8, 78, 1, 78, 1, 78, 1, 78,
		3, 78, 2717, 8, 78, 1, 78, 3, 78, 2720, 8, 78, 1, 78, 1, 78, 5, 78, 2724,
		8, 78, 10, 78, 12, 78, 2727, 9, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2732, 8,
		78, 3, 78, 2734, 8, 78, 1, 78, 1, 78, 3, 78, 2738, 8, 78, 1, 78, 3, 78,
		2741, 8, 78, 1, 78, 3, 78, 2744, 8, 78, 1, 78, 3, 78, 2747, 8, 78, 1, 78,
		1, 78, 5, 78, 2751, 8, 78, 10, 78, 12, 78, 2754, 9, 78, 1, 78, 1, 78, 1,
		78, 3, 78, 2759, 8, 78, 1, 78, 3, 78, 2762, 8, 78, 1, 78, 1, 78, 5, 78,
		2766, 8, 78, 10, 78, 12, 78, 2769, 9, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2774,
		8, 78, 3, 78, 2776, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2781, 8, 78, 1,
		78, 3, 78, 2784, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78,
		2792, 8, 78, 3, 78, 2794, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 3, 78, 2803, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2808, 8, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2816, 8, 78, 1, 78, 1,
		78, 3, 78, 2820, 8, 78, 1, 78, 3, 78, 2823, 8, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 2831, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 3, 78, 2841, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78,
		2846, 8, 78, 1, 78, 3, 78, 2849, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 3, 78, 2856, 8, 78, 1, 78, 1, 78, 3, 78, 2860, 8, 78, 1, 78, 3, 78,
		2863, 8, 78, 1, 78, 1, 78, 3, 78, 2867, 8, 78, 1, 78, 1, 78, 1, 78, 3,
		78, 2872, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78,
		2881, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2899, 8, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2908, 8, 78, 1,
		78, 1, 78, 3, 78, 2912, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2924, 8, 78, 1, 78, 3, 78, 2927, 8,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2936, 8, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3,
		78, 2948, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 2954, 8, 78, 10, 78,
		12, 78, 2957, 9, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2964, 8,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2971, 8, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 2978, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 3, 78, 2985, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 2998, 8, 78, 10, 78, 12, 78, 3001, 9,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		3, 78, 3013, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3019, 8, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 3, 78, 3025, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		3, 78, 3031, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3037, 8, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 3, 78, 3043, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 3, 78, 3051, 8, 78, 1, 78, 3, 78, 3054, 8, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 5, 78, 3060, 8, 78, 10, 78, 12, 78, 3063, 9, 78, 1, 78,
		1, 78, 3, 78, 3067, 8, 78, 1, 79, 1, 79, 1, 79, 3, 79, 3072, 8, 79, 1,
		79, 1, 79, 1, 80, 1, 80, 1, 80, 3, 80, 3079, 8, 80, 1, 80, 1, 80, 1, 81,
		1, 81, 1, 81, 3, 81, 3086, 8, 81, 1, 81, 3, 81, 3089, 8, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 1, 81, 3, 81, 3096, 8, 81, 1, 81, 1, 81, 1, 81, 3, 81,
		3101, 8, 81, 1, 81, 5, 81, 3104, 8, 81, 10, 81, 12, 81, 3107, 9, 81, 1,
		81, 3, 81, 3110, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82,
		1, 82, 1, 83, 1, 83, 1, 83, 3, 83, 3123, 8, 83, 1, 83, 1, 83, 1, 84, 1,
		84, 1, 84, 3, 84, 3130, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 3, 85,
		3137, 8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 3143, 8, 86, 1, 86, 1,
		86, 3, 86, 3147, 8, 86, 1, 86, 1, 86, 3, 86, 3151, 8, 86, 1, 86, 3, 86,
		3154, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 3161, 8, 87, 1,
		87, 3, 87, 3164, 8, 87, 1, 88, 1, 88, 1, 88, 3, 88, 3169, 8, 88, 1, 88,
		1, 88, 1, 89, 1, 89, 1, 89, 3, 89, 3176, 8, 89, 1, 89, 1, 89, 1, 89, 5,
		89, 3181, 8, 89, 10, 89, 12, 89, 3184, 9, 89, 1, 89, 3, 89, 3187, 8, 89,
		1, 90, 1, 90, 1, 90, 3, 90, 3192, 8, 90, 1, 90, 1, 90, 1, 90, 5, 90, 3197,
		8, 90, 10, 90, 12, 90, 3200, 9, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 5, 91, 3210, 8, 91, 10, 91, 12, 91, 3213, 9, 91, 3,
		91, 3215, 8, 91, 1, 91, 1, 91, 1, 91, 3, 91, 3220, 8, 91, 1, 91, 1, 91,
		1, 91, 3, 91, 3225, 8, 91, 5, 91, 3227, 8, 91, 10, 91, 12, 91, 3230, 9,
		91, 1, 91, 1, 91, 1, 91, 3, 91, 3235, 8, 91, 1, 92, 1, 92, 3, 92, 3239,
		8, 92, 1, 92, 1, 92, 3, 92, 3243, 8, 92, 1, 92, 3, 92, 3246, 8, 92, 1,
		92, 1, 92, 1, 92, 5, 92, 3251, 8, 92, 10, 92, 12, 92, 3254, 9, 92, 1, 93,
		1, 93, 1, 93, 1, 93, 1, 93, 5, 93, 3261, 8, 93, 10, 93, 12, 93, 3264, 9,
		93, 1, 94, 1, 94, 3, 94, 3268, 8, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95,
		3, 95, 3275, 8, 95, 1, 95, 1, 95, 3, 95, 3279, 8, 95, 1, 96, 1, 96, 1,
		96, 1, 96, 1, 96, 3, 96, 3286, 8, 96, 1, 96, 3, 96, 3289, 8, 96, 1, 97,
		1, 97, 3, 97, 3293, 8, 97, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1,
		99, 3, 99, 3302, 8, 99, 1, 100, 1, 100, 3, 100, 3306, 8, 100, 1, 100, 3,
		100, 3309, 8, 100, 1, 100, 3, 100, 3312, 8, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 3, 100, 3318, 8, 100, 1, 100, 3, 100, 3321, 8, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 3, 100, 3327, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 5, 100, 3334, 8, 100, 10, 100, 12, 100, 3337, 9, 100, 3, 100, 3339,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 5, 100,
		3348, 8, 100, 10, 100, 12, 100, 3351, 9, 100, 3, 100, 3353, 8, 100, 1,
		101, 1, 101, 1, 101, 3, 101, 3358, 8, 101, 1, 101, 3, 101, 3361, 8, 101,
		1, 101, 1, 101, 1, 101, 3, 101, 3366, 8, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 3376, 8, 101, 1, 101, 1, 101,
		1, 101, 3, 101, 3381, 8, 101, 1, 101, 1, 101, 4, 101, 3385, 8, 101, 11,
		101, 12, 101, 3386, 3, 101, 3389, 8, 101, 1, 101, 1, 101, 4, 101, 3393,
		8, 101, 11, 101, 12, 101, 3394, 3, 101, 3397, 8, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 3, 101, 3403, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101,
		3409, 8, 101, 10, 101, 12, 101, 3412, 9, 101, 1, 101, 1, 101, 3, 101, 3416,
		8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 3422, 8, 101, 10, 101,
		12, 101, 3425, 9, 101, 3, 101, 3427, 8, 101, 1, 102, 1, 102, 1, 102, 3,
		102, 3432, 8, 102, 1, 102, 3, 102, 3435, 8, 102, 1, 102, 1, 102, 1, 102,
		3, 102, 3440, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3,
		102, 3448, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102,
		3456, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 3462, 8, 102, 1,
		102, 1, 102, 1, 102, 1, 102, 5, 102, 3468, 8, 102, 10, 102, 12, 102, 3471,
		9, 102, 1, 102, 1, 102, 3, 102, 3475, 8, 102, 1, 102, 1, 102, 1, 102, 1,
		102, 5, 102, 3481, 8, 102, 10, 102, 12, 102, 3484, 9, 102, 3, 102, 3486,
		8, 102, 1, 103, 1, 103, 3, 103, 3490, 8, 103, 1, 103, 3, 103, 3493, 8,
		103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 3501, 8, 103,
		1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 3507, 8, 103, 1, 103, 1, 103, 1,
		103, 1, 103, 1, 103, 5, 103, 3514, 8, 103, 10, 103, 12, 103, 3517, 9, 103,
		3, 103, 3519, 8, 103, 1, 104, 1, 104, 3, 104, 3523, 8, 104, 1, 104, 1,
		104, 3, 104, 3527, 8, 104, 1, 104, 1, 104, 4, 104, 3531, 8, 104, 11, 104,
		12, 104, 3532, 1, 104, 1, 104, 3, 104, 3537, 8, 104, 1, 104, 1, 104, 3,
		104, 3541, 8, 104, 3, 104, 3543, 8, 104, 1, 104, 3, 104, 3546, 8, 104,
		1, 104, 3, 104, 3549, 8, 104, 1, 104, 3, 104, 3552, 8, 104, 1, 104, 1,
		104, 4, 104, 3556, 8, 104, 11, 104, 12, 104, 3557, 1, 104, 1, 104, 3, 104,
		3562, 8, 104, 1, 104, 3, 104, 3565, 8, 104, 1, 104, 3, 104, 3568, 8, 104,
		1, 104, 3, 104, 3571, 8, 104, 1, 104, 3, 104, 3574, 8, 104, 1, 104, 1,
		104, 1, 104, 4, 104, 3579, 8, 104, 11, 104, 12, 104, 3580, 3, 104, 3583,
		8, 104, 1, 105, 1, 105, 3, 105, 3587, 8, 105, 1, 106, 1, 106, 1, 106, 3,
		106, 3592, 8, 106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 3598, 8, 106,
		1, 106, 5, 106, 3601, 8, 106, 10, 106, 12, 106, 3604, 9, 106, 1, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 3610, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		3, 107, 3616, 8, 107, 1, 107, 5, 107, 3619, 8, 107, 10, 107, 12, 107, 3622,
		9, 107, 3, 107, 3624, 8, 107, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3630,
		8, 108, 1, 109, 1, 109, 3, 109, 3634, 8, 109, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 3, 110, 3642, 8, 110, 1, 110, 3, 110, 3645, 8, 110,
		1, 111, 1, 111, 3, 111, 3649, 8, 111, 1, 111, 3, 111, 3652, 8, 111, 1,
		111, 3, 111, 3655, 8, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
		1, 111, 3, 111, 3664, 8, 111, 1, 111, 1, 111, 3, 111, 3668, 8, 111, 1,
		111, 3, 111, 3671, 8, 111, 1, 111, 1, 111, 3, 111, 3675, 8, 111, 1, 112,
		1, 112, 3, 112, 3679, 8, 112, 1, 112, 3, 112, 3682, 8, 112, 1, 112, 3,
		112, 3685, 8, 112, 1, 112, 1, 112, 1, 112, 3, 112, 3690, 8, 112, 1, 112,
		1, 112, 1, 112, 1, 112, 3, 112, 3696, 8, 112, 5, 112, 3698, 8, 112, 10,
		112, 12, 112, 3701, 9, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 3, 112, 3710, 8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112,
		3716, 8, 112, 5, 112, 3718, 8, 112, 10, 112, 12, 112, 3721, 9, 112, 1,
		112, 1, 112, 1, 112, 3, 112, 3726, 8, 112, 1, 112, 1, 112, 3, 112, 3730,
		8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 3736, 8, 113, 1, 113, 3,
		113, 3739, 8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 1, 114, 3, 114, 3751, 8, 114, 1, 114, 1, 114, 3, 114, 3755,
		8, 114, 1, 114, 1, 114, 3, 114, 3759, 8, 114, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 115, 1, 115, 3, 115, 3767, 8, 115, 1, 115, 1, 115, 3, 115, 3771,
		8, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 3, 117, 3779, 8,
		117, 1, 117, 3, 117, 3782, 8, 117, 1, 117, 1, 117, 3, 117, 3786, 8, 117,
		1, 117, 3, 117, 3789, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 5, 117, 3795,
		8, 117, 10, 117, 12, 117, 3798, 9, 117, 1, 117, 1, 117, 3, 117, 3802, 8,
		117, 1, 117, 3, 117, 3805, 8, 117, 1, 117, 3, 117, 3808, 8, 117, 1, 118,
		1, 118, 3, 118, 3812, 8, 118, 1, 118, 3, 118, 3815, 8, 118, 1, 118, 1,
		118, 1, 118, 1, 118, 1, 118, 5, 118, 3822, 8, 118, 10, 118, 12, 118, 3825,
		9, 118, 1, 118, 1, 118, 3, 118, 3829, 8, 118, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 5, 119, 3836, 8, 119, 10, 119, 12, 119, 3839, 9, 119, 1, 120,
		1, 120, 3, 120, 3843, 8, 120, 1, 121, 1, 121, 1, 121, 5, 121, 3848, 8,
		121, 10, 121, 12, 121, 3851, 9, 121, 1, 122, 1, 122, 5, 122, 3855, 8, 122,
		10, 122, 12, 122, 3858, 9, 122, 1, 122, 1, 122, 1, 122, 5, 122, 3863, 8,
		122, 10, 122, 12, 122, 3866, 9, 122, 1, 122, 1, 122, 1, 122, 3, 122, 3871,
		8, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3879, 8,
		123, 1, 123, 3, 123, 3882, 8, 123, 1, 123, 3, 123, 3885, 8, 123, 1, 123,
		1, 123, 1, 123, 5, 123, 3890, 8, 123, 10, 123, 12, 123, 3893, 9, 123, 3,
		123, 3895, 8, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3902,
		8, 123, 1, 123, 3, 123, 3905, 8, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1,
		123, 1, 123, 3, 123, 3913, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124,
		3919, 8, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 3, 125, 3930, 8, 125, 1, 126, 3, 126, 3933, 8, 126, 1, 126,
		1, 126, 3, 126, 3937, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1,
		126, 1, 126, 1, 126, 3, 126, 3947, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126,
		3, 126, 3953, 8, 126, 1, 126, 1, 126, 3, 126, 3957, 8, 126, 1, 126, 1,
		126, 3, 126, 3961, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 3, 126, 3971, 8, 126, 1, 126, 1, 126, 1, 126, 3, 126, 3976,
		8, 126, 3, 126, 3978, 8, 126, 1, 126, 1, 126, 3, 126, 3982, 8, 126, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 3992,
		8, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128,
		3, 128, 4002, 8, 128, 1, 129, 1, 129, 5, 129, 4006, 8, 129, 10, 129, 12,
		129, 4009, 9, 129, 1, 129, 1, 129, 3, 129, 4013, 8, 129, 1, 129, 3, 129,
		4016, 8, 129, 1, 129, 3, 129, 4019, 8, 129, 1, 129, 3, 129, 4022, 8, 129,
		1, 129, 3, 129, 4025, 8, 129, 1, 129, 3, 129, 4028, 8, 129, 1, 129, 3,
		129, 4031, 8, 129, 1, 129, 1, 129, 5, 129, 4035, 8, 129, 10, 129, 12, 129,
		4038, 9, 129, 1, 129, 1, 129, 3, 129, 4042, 8, 129, 1, 129, 3, 129, 4045,
		8, 129, 1, 129, 3, 129, 4048, 8, 129, 1, 129, 3, 129, 4051, 8, 129, 1,
		129, 3, 129, 4054, 8, 129, 1, 129, 3, 129, 4057, 8, 129, 1, 129, 3, 129,
		4060, 8, 129, 3, 129, 4062, 8, 129, 1, 130, 1, 130, 5, 130, 4066, 8, 130,
		10, 130, 12, 130, 4069, 9, 130, 1, 130, 1, 130, 3, 130, 4073, 8, 130, 1,
		130, 3, 130, 4076, 8, 130, 1, 130, 3, 130, 4079, 8, 130, 1, 130, 3, 130,
		4082, 8, 130, 1, 130, 3, 130, 4085, 8, 130, 1, 130, 3, 130, 4088, 8, 130,
		1, 131, 1, 131, 3, 131, 4092, 8, 131, 1, 131, 1, 131, 1, 132, 1, 132, 3,
		132, 4098, 8, 132, 1, 132, 1, 132, 3, 132, 4102, 8, 132, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 4110, 8, 133, 1, 133, 1, 133, 3,
		133, 4114, 8, 133, 1, 133, 3, 133, 4117, 8, 133, 3, 133, 4119, 8, 133,
		1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134,
		1, 134, 1, 134, 3, 134, 4132, 8, 134, 1, 134, 3, 134, 4135, 8, 134, 1,
		135, 1, 135, 1, 135, 5, 135, 4140, 8, 135, 10, 135, 12, 135, 4143, 9, 135,
		1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 4152, 8,
		136, 1, 136, 3, 136, 4155, 8, 136, 1, 136, 1, 136, 1, 136, 3, 136, 4160,
		8, 136, 3, 136, 4162, 8, 136, 1, 136, 1, 136, 3, 136, 4166, 8, 136, 1,
		136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 4174, 8, 136, 1, 137,
		1, 137, 1, 137, 1, 137, 3, 137, 4180, 8, 137, 1, 137, 1, 137, 1, 137, 1,
		138, 1, 138, 1, 138, 1, 138, 3, 138, 4189, 8, 138, 1, 138, 1, 138, 1, 138,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139,
		4202, 8, 139, 1, 140, 1, 140, 3, 140, 4206, 8, 140, 1, 140, 1, 140, 5,
		140, 4210, 8, 140, 10, 140, 12, 140, 4213, 9, 140, 1, 141, 1, 141, 1, 141,
		1, 141, 1, 141, 1, 141, 3, 141, 4221, 8, 141, 1, 141, 3, 141, 4224, 8,
		141, 1, 141, 1, 141, 3, 141, 4228, 8, 141, 1, 141, 3, 141, 4231, 8, 141,
		1, 141, 1, 141, 3, 141, 4235, 8, 141, 1, 141, 1, 141, 3, 141, 4239, 8,
		141, 1, 141, 3, 141, 4242, 8, 141, 3, 141, 4244, 8, 141, 1, 142, 1, 142,
		1, 142, 1, 142, 5, 142, 4250, 8, 142, 10, 142, 12, 142, 4253, 9, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 3,
		142, 4264, 8, 142, 1, 142, 1, 142, 4, 142, 4268, 8, 142, 11, 142, 12, 142,
		4269, 3, 142, 4272, 8, 142, 1, 142, 1, 142, 4, 142, 4276, 8, 142, 11, 142,
		12, 142, 4277, 3, 142, 4280, 8, 142, 3, 142, 4282, 8, 142, 1, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 4288, 8, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 3, 143, 4296, 8, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144,
		1, 144, 3, 144, 4304, 8, 144, 1, 145, 1, 145, 3, 145, 4308, 8, 145, 1,
		145, 1, 145, 3, 145, 4312, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146,
		5, 146, 4319, 8, 146, 10, 146, 12, 146, 4322, 9, 146, 1, 146, 1, 146, 3,
		146, 4326, 8, 146, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148,
		1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148,
		5, 148, 4344, 8, 148, 10, 148, 12, 148, 4347, 9, 148, 1, 149, 1, 149, 3,
		149, 4351, 8, 149, 1, 150, 1, 150, 1, 150, 1, 150, 3, 150, 4357, 8, 150,
		1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 3, 150, 4364, 8, 150, 1, 151, 1,
		151, 1, 151, 3, 151, 4369, 8, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152,
		5, 152, 4376, 8, 152, 10, 152, 12, 152, 4379, 9, 152, 3, 152, 4381, 8,
		152, 1, 153, 1, 153, 3, 153, 4385, 8, 153, 1, 154, 1, 154, 3, 154, 4389,
		8, 154, 1, 154, 1, 154, 3, 154, 4393, 8, 154, 1, 154, 3, 154, 4396, 8,
		154, 1, 154, 3, 154, 4399, 8, 154, 1, 154, 3, 154, 4402, 8, 154, 1, 155,
		1, 155, 3, 155, 4406, 8, 155, 1, 155, 1, 155, 3, 155, 4410, 8, 155, 1,
		155, 3, 155, 4413, 8, 155, 1, 155, 3, 155, 4416, 8, 155, 1, 155, 3, 155,
		4419, 8, 155, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 3, 157, 4426, 8,
		157, 1, 157, 1, 157, 3, 157, 4430, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158,
		1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 5, 159, 4443, 8,
		159, 10, 159, 12, 159, 4446, 9, 159, 1, 159, 3, 159, 4449, 8, 159, 1, 160,
		1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162,
		3, 162, 4461, 8, 162, 1, 162, 1, 162, 1, 162, 1, 162, 5, 162, 4467, 8,
		162, 10, 162, 12, 162, 4470, 9, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1,
		163, 1, 163, 1, 163, 3, 163, 4479, 8, 163, 1, 164, 1, 164, 3, 164, 4483,
		8, 164, 1, 164, 3, 164, 4486, 8, 164, 1, 164, 1, 164, 1, 165, 1, 165, 3,
		165, 4492, 8, 165, 1, 165, 3, 165, 4495, 8, 165, 1, 165, 3, 165, 4498,
		8, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 3, 166,
		4507, 8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 3,
		167, 4516, 8, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 5, 168,
		4524, 8, 168, 10, 168, 12, 168, 4527, 9, 168, 1, 168, 3, 168, 4530, 8,
		168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 4538, 8, 169,
		10, 169, 12, 169, 4541, 9, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170,
		1, 170, 1, 170, 3, 170, 4550, 8, 170, 1, 171, 1, 171, 1, 171, 1, 172, 1,
		172, 1, 172, 3, 172, 4558, 8, 172, 1, 172, 3, 172, 4561, 8, 172, 1, 173,
		1, 173, 1, 173, 1, 173, 1, 173, 5, 173, 4568, 8, 173, 10, 173, 12, 173,
		4571, 9, 173, 3, 173, 4573, 8, 173, 1, 173, 1, 173, 3, 173, 4577, 8, 173,
		1, 173, 5, 173, 4580, 8, 173, 10, 173, 12, 173, 4583, 9, 173, 1, 173, 3,
		173, 4586, 8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 4593,
		8, 174, 10, 174, 12, 174, 4596, 9, 174, 3, 174, 4598, 8, 174, 1, 175, 1,
		175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 177, 1,
		177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1,
		177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 5, 177, 4627,
		8, 177, 10, 177, 12, 177, 4630, 9, 177, 3, 177, 4632, 8, 177, 1, 177, 3,
		177, 4635, 8, 177, 1, 178, 1, 178, 1, 179, 1, 179, 1, 180, 1, 180, 1, 181,
		1, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		5, 182, 4689, 8, 182, 10, 182, 12, 182, 4692, 9, 182, 1, 182, 1, 182, 3,
		182, 4696, 8, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 184,
		1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 3, 185, 4724, 8, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1,
		186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 4738, 8, 186,
		1, 187, 1, 187, 1, 187, 5, 187, 4743, 8, 187, 10, 187, 12, 187, 4746, 9,
		187, 1, 187, 3, 187, 4749, 8, 187, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188,
		4755, 8, 188, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 4763,
		8, 189, 3, 189, 4765, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 3, 191, 4776, 8, 191, 1, 192, 1, 192, 1, 192,
		1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 4786, 8, 193, 1, 194, 1,
		194, 1, 194, 1, 194, 1, 194, 3, 194, 4793, 8, 194, 1, 195, 1, 195, 1, 195,
		1, 195, 3, 195, 4799, 8, 195, 1, 196, 1, 196, 1, 196, 1, 196, 1, 197, 1,
		197, 3, 197, 4807, 8, 197, 1, 198, 1, 198, 1, 198, 3, 198, 4812, 8, 198,
		1, 198, 1, 198, 1, 198, 1, 198, 5, 198, 4818, 8, 198, 10, 198, 12, 198,
		4821, 9, 198, 1, 198, 1, 198, 1, 198, 5, 198, 4826, 8, 198, 10, 198, 12,
		198, 4829, 9, 198, 1, 198, 1, 198, 1, 198, 5, 198, 4834, 8, 198, 10, 198,
		12, 198, 4837, 9, 198, 1, 198, 1, 198, 1, 198, 5, 198, 4842, 8, 198, 10,
		198, 12, 198, 4845, 9, 198, 1, 198, 5, 198, 4848, 8, 198, 10, 198, 12,
		198, 4851, 9, 198, 3, 198, 4853, 8, 198, 1, 198, 1, 198, 3, 198, 4857,
		8, 198, 1, 199, 1, 199, 1, 199, 3, 199, 4862, 8, 199, 1, 199, 4, 199, 4865,
		8, 199, 11, 199, 12, 199, 4866, 1, 199, 1, 199, 4, 199, 4871, 8, 199, 11,
		199, 12, 199, 4872, 3, 199, 4875, 8, 199, 1, 199, 1, 199, 1, 199, 1, 200,
		1, 200, 1, 200, 1, 200, 4, 200, 4884, 8, 200, 11, 200, 12, 200, 4885, 1,
		200, 5, 200, 4889, 8, 200, 10, 200, 12, 200, 4892, 9, 200, 1, 200, 1, 200,
		4, 200, 4896, 8, 200, 11, 200, 12, 200, 4897, 3, 200, 4900, 8, 200, 1,
		200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1,
		203, 1, 203, 1, 203, 3, 203, 4914, 8, 203, 1, 203, 1, 203, 4, 203, 4918,
		8, 203, 11, 203, 12, 203, 4919, 1, 203, 1, 203, 1, 203, 3, 203, 4925, 8,
		203, 1, 204, 1, 204, 1, 204, 3, 204, 4930, 8, 204, 1, 204, 1, 204, 4, 204,
		4934, 8, 204, 11, 204, 12, 204, 4935, 1, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 4943, 8, 204, 1, 205, 1, 205, 1, 205, 1, 206, 1, 206, 1, 206,
		3, 206, 4951, 8, 206, 1, 206, 1, 206, 1, 206, 1, 206, 4, 206, 4957, 8,
		206, 11, 206, 12, 206, 4958, 1, 206, 1, 206, 1, 206, 3, 206, 4964, 8, 206,
		1, 207, 1, 207, 1, 207, 1, 207, 3, 207, 4970, 8, 207, 1, 207, 3, 207, 4973,
		8, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 3, 207, 4981, 8,
		207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 4988, 8, 208, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 4997, 8, 209, 1,
		209, 3, 209, 5000, 8, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 5, 211, 5015, 8,
		211, 10, 211, 12, 211, 5018, 9, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1,
		212, 3, 212, 5025, 8, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		3, 212, 5033, 8, 212, 1, 213, 1, 213, 3, 213, 5037, 8, 213, 1, 213, 1,
		213, 1, 214, 1, 214, 1, 214, 3, 214, 5044, 8, 214, 1, 214, 1, 214, 4, 214,
		5048, 8, 214, 11, 214, 12, 214, 5049, 1, 215, 1, 215, 1, 215, 1, 215, 4,
		215, 5056, 8, 215, 11, 215, 12, 215, 5057, 1, 216, 1, 216, 1, 216, 1, 216,
		1, 216, 5, 216, 5065, 8, 216, 10, 216, 12, 216, 5068, 9, 216, 1, 216, 1,
		216, 1, 216, 3, 216, 5073, 8, 216, 1, 216, 1, 216, 1, 216, 5, 216, 5078,
		8, 216, 10, 216, 12, 216, 5081, 9, 216, 1, 216, 1, 216, 1, 216, 1, 216,
		3, 216, 5087, 8, 216, 1, 216, 5, 216, 5090, 8, 216, 10, 216, 12, 216, 5093,
		9, 216, 3, 216, 5095, 8, 216, 3, 216, 5097, 8, 216, 1, 216, 1, 216, 4,
		216, 5101, 8, 216, 11, 216, 12, 216, 5102, 3, 216, 5105, 8, 216, 1, 216,
		1, 216, 5, 216, 5109, 8, 216, 10, 216, 12, 216, 5112, 9, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 3, 216, 5118, 8, 216, 3, 216, 5120, 8, 216, 1, 217,
		1, 217, 1, 217, 1, 217, 1, 217, 5, 217, 5127, 8, 217, 10, 217, 12, 217,
		5130, 9, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5135, 8, 217, 1, 217, 1,
		217, 1, 217, 5, 217, 5140, 8, 217, 10, 217, 12, 217, 5143, 9, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 3, 217, 5149, 8, 217, 1, 217, 5, 217, 5152, 8,
		217, 10, 217, 12, 217, 5155, 9, 217, 3, 217, 5157, 8, 217, 3, 217, 5159,
		8, 217, 1, 217, 1, 217, 4, 217, 5163, 8, 217, 11, 217, 12, 217, 5164, 3,
		217, 5167, 8, 217, 1, 217, 1, 217, 5, 217, 5171, 8, 217, 10, 217, 12, 217,
		5174, 9, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5180, 8, 217, 3,
		217, 5182, 8, 217, 1, 218, 1, 218, 1, 218, 3, 218, 5187, 8, 218, 1, 218,
		1, 218, 1, 218, 5, 218, 5192, 8, 218, 10, 218, 12, 218, 5195, 9, 218, 1,
		219, 1, 219, 1, 219, 1, 219, 5, 219, 5201, 8, 219, 10, 219, 12, 219, 5204,
		9, 219, 1, 219, 1, 219, 3, 219, 5208, 8, 219, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 5, 219, 5215, 8, 219, 10, 219, 12, 219, 5218, 9, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 3, 219, 5224, 8, 219, 1, 219, 5, 219, 5227, 8,
		219, 10, 219, 12, 219, 5230, 9, 219, 3, 219, 5232, 8, 219, 3, 219, 5234,
		8, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 5240, 8, 219, 10, 219,
		12, 219, 5243, 9, 219, 3, 219, 5245, 8, 219, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 1, 219, 3, 219, 5253, 8, 219, 1, 219, 1, 219, 1, 219, 3, 219,
		5258, 8, 219, 1, 219, 1, 219, 1, 219, 3, 219, 5263, 8, 219, 5, 219, 5265,
		8, 219, 10, 219, 12, 219, 5268, 9, 219, 1, 219, 1, 219, 1, 219, 3, 219,
		5273, 8, 219, 1, 219, 1, 219, 1, 219, 3, 219, 5278, 8, 219, 5, 219, 5280,
		8, 219, 10, 219, 12, 219, 5283, 9, 219, 1, 219, 1, 219, 1, 219, 3, 219,
		5288, 8, 219, 3, 219, 5290, 8, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1,
		220, 1, 220, 1, 220, 5, 220, 5299, 8, 220, 10, 220, 12, 220, 5302, 9, 220,
		3, 220, 5304, 8, 220, 1, 220, 1, 220, 1, 220, 5, 220, 5309, 8, 220, 10,
		220, 12, 220, 5312, 9, 220, 3, 220, 5314, 8, 220, 1, 221, 1, 221, 1, 221,
		1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 5, 221, 5324, 8, 221, 10, 221,
		12, 221, 5327, 9, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5332, 8, 221, 1,
		222, 1, 222, 1, 222, 1, 222, 1, 222, 5, 222, 5339, 8, 222, 10, 222, 12,
		222, 5342, 9, 222, 1, 223, 1, 223, 1, 223, 1, 223, 5, 223, 5348, 8, 223,
		10, 223, 12, 223, 5351, 9, 223, 1, 223, 1, 223, 3, 223, 5355, 8, 223, 1,
		223, 1, 223, 1, 223, 1, 223, 1, 223, 5, 223, 5362, 8, 223, 10, 223, 12,
		223, 5365, 9, 223, 1, 223, 1, 223, 1, 223, 3, 223, 5370, 8, 223, 1, 223,
		1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 5, 223, 5379, 8, 223, 10,
		223, 12, 223, 5382, 9, 223, 1, 223, 1, 223, 1, 223, 1, 223, 5, 223, 5388,
		8, 223, 10, 223, 12, 223, 5391, 9, 223, 1, 223, 1, 223, 1, 223, 3, 223,
		5396, 8, 223, 1, 223, 1, 223, 1, 223, 3, 223, 5401, 8, 223, 5, 223, 5403,
		8, 223, 10, 223, 12, 223, 5406, 9, 223, 3, 223, 5408, 8, 223, 1, 224, 1,
		224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 5, 224, 5418, 8, 224,
		10, 224, 12, 224, 5421, 9, 224, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225,
		5427, 8, 225, 1, 225, 1, 225, 1, 225, 3, 225, 5432, 8, 225, 1, 226, 1,
		226, 1, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1,
		227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 3, 227, 5450, 8, 227, 1, 227,
		1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 5, 227, 5458, 8, 227, 10, 227,
		12, 227, 5461, 9, 227, 1, 227, 3, 227, 5464, 8, 227, 1, 228, 1, 228, 1,
		228, 3, 228, 5469, 8, 228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 5475,
		8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		3, 229, 5485, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 3, 230, 5495, 8, 230, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231,
		1, 231, 1, 231, 1, 231, 3, 231, 5505, 8, 231, 1, 231, 1, 231, 1, 231, 1,
		231, 3, 231, 5511, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231,
		1, 231, 3, 231, 5520, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 5526,
		8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 5533, 8, 231, 3,
		231, 5535, 8, 231, 1, 232, 1, 232, 1, 232, 1, 233, 1, 233, 1, 233, 1, 233,
		1, 233, 3, 233, 5545, 8, 233, 1, 234, 1, 234, 3, 234, 5549, 8, 234, 1,
		234, 1, 234, 3, 234, 5553, 8, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 1, 234, 3, 234, 5563, 8, 234, 1, 234, 1, 234, 1, 234, 3,
		234, 5568, 8, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		3, 234, 5586, 8, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 3, 234, 5642, 8, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 3, 234, 5667, 8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1,
		235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1,
		235, 1, 235, 3, 235, 5685, 8, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1, 237,
		1, 237, 3, 237, 5693, 8, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1,
		237, 1, 237, 1, 237, 5, 237, 5703, 8, 237, 10, 237, 12, 237, 5706, 9, 237,
		1, 237, 1, 237, 1, 237, 1, 237, 3, 237, 5712, 8, 237, 3, 237, 5714, 8,
		237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 5, 237, 5722, 8, 237,
		10, 237, 12, 237, 5725, 9, 237, 3, 237, 5727, 8, 237, 1, 238, 1, 238, 1,
		238, 1, 238, 5, 238, 5733, 8, 238, 10, 238, 12, 238, 5736, 9, 238, 1, 239,
		1, 239, 1, 239, 1, 239, 3, 239, 5742, 8, 239, 1, 240, 1, 240, 3, 240, 5746,
		8, 240, 1, 240, 1, 240, 1, 240, 3, 240, 5751, 8, 240, 1, 241, 1, 241, 3,
		241, 5755, 8, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5760, 8, 241, 1, 241,
		3, 241, 5763, 8, 241, 1, 241, 3, 241, 5766, 8, 241, 1, 242, 1, 242, 1,
		242, 1, 242, 1, 242, 1, 242, 1, 242, 3, 242, 5775, 8, 242, 1, 243, 1, 243,
		3, 243, 5779, 8, 243, 1, 243, 3, 243, 5782, 8, 243, 1, 243, 1, 243, 3,
		243, 5786, 8, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 244,
		1, 244, 1, 244, 1, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1, 245,
		1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5809, 8, 246, 1, 246, 1,
		246, 1, 246, 1, 246, 1, 246, 3, 246, 5816, 8, 246, 5, 246, 5818, 8, 246,
		10, 246, 12, 246, 5821, 9, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246,
		5827, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5834, 8,
		246, 1, 246, 3, 246, 5837, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246,
		1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 5, 246, 5851, 8,
		246, 10, 246, 12, 246, 5854, 9, 246, 3, 246, 5856, 8, 246, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5866, 8, 247, 1,
		247, 1, 247, 3, 247, 5870, 8, 247, 1, 247, 3, 247, 5873, 8, 247, 1, 247,
		1, 247, 1, 247, 3, 247, 5878, 8, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5883,
		8, 247, 1, 247, 1, 247, 3, 247, 5887, 8, 247, 1, 247, 3, 247, 5890, 8,
		247, 1, 247, 1, 247, 1, 247, 3, 247, 5895, 8, 247, 1, 247, 1, 247, 1, 247,
		3, 247, 5900, 8, 247, 1, 247, 1, 247, 3, 247, 5904, 8, 247, 1, 247, 1,
		247, 1, 247, 1, 247, 1, 247, 3, 247, 5911, 8, 247, 1, 247, 3, 247, 5914,
		8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5920, 8, 247, 1, 247, 1,
		247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5931,
		8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247,
		1, 247, 3, 247, 5951, 8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1,
		247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5963, 8, 247, 1, 247, 3, 247,
		5966, 8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1,
		247, 3, 247, 5976, 8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247,
		3, 247, 5984, 8, 247, 1, 247, 1, 247, 3, 247, 5988, 8, 247, 1, 247, 1,
		247, 1, 247, 1, 247, 1, 247, 3, 247, 5995, 8, 247, 1, 247, 3, 247, 5998,
		8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 5, 247, 6005, 8, 247, 10,
		247, 12, 247, 6008, 9, 247, 3, 247, 6010, 8, 247, 1, 247, 1, 247, 1, 247,
		3, 247, 6015, 8, 247, 1, 247, 3, 247, 6018, 8, 247, 1, 247, 1, 247, 1,
		247, 3, 247, 6023, 8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 6029,
		8, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 6036, 8, 247, 1,
		247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 6043, 8, 247, 1, 247, 1, 247,
		3, 247, 6047, 8, 247, 3, 247, 6049, 8, 247, 1, 248, 1, 248, 3, 248, 6053,
		8, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249, 1, 249,
		3, 249, 6063, 8, 249, 1, 249, 3, 249, 6066, 8, 249, 1, 249, 3, 249, 6069,
		8, 249, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250, 1, 250,
		1, 250, 1, 250, 3, 250, 6081, 8, 250, 1, 250, 3, 250, 6084, 8, 250, 1,
		251, 1, 251, 1, 251, 1, 251, 3, 251, 6090, 8, 251, 1, 252, 3, 252, 6093,
		8, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 3, 252,
		6102, 8, 252, 3, 252, 6104, 8, 252, 1, 252, 1, 252, 3, 252, 6108, 8, 252,
		1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252,
		1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 3, 252, 6125, 8, 252, 1,
		253, 1, 253, 1, 253, 1, 253, 3, 253, 6131, 8, 253, 1, 253, 1, 253, 3, 253,
		6135, 8, 253, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1,
		254, 1, 254, 1, 254, 1, 254, 1, 254, 3, 254, 6149, 8, 254, 1, 255, 1, 255,
		1, 255, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 5, 256, 6159, 8, 256, 10,
		256, 12, 256, 6162, 9, 256, 1, 256, 1, 256, 1, 256, 1, 256, 3, 256, 6168,
		8, 256, 1, 256, 3, 256, 6171, 8, 256, 1, 256, 1, 256, 1, 256, 1, 257, 1,
		257, 3, 257, 6178, 8, 257, 1, 257, 1, 257, 1, 257, 5, 257, 6183, 8, 257,
		10, 257, 12, 257, 6186, 9, 257, 1, 257, 1, 257, 3, 257, 6190, 8, 257, 1,
		258, 1, 258, 3, 258, 6194, 8, 258, 1, 258, 1, 258, 1, 259, 1, 259, 1, 259,
		1, 259, 1, 259, 1, 259, 1, 259, 5, 259, 6205, 8, 259, 10, 259, 12, 259,
		6208, 9, 259, 1, 260, 1, 260, 1, 260, 1, 260, 1, 261, 1, 261, 1, 262, 1,
		262, 3, 262, 6218, 8, 262, 1, 262, 1, 262, 1, 262, 1, 262, 3, 262, 6224,
		8, 262, 1, 263, 1, 263, 1, 263, 3, 263, 6229, 8, 263, 1, 263, 1, 263, 1,
		263, 1, 263, 1, 263, 1, 263, 1, 263, 1, 263, 1, 263, 1, 263, 1, 263, 3,
		263, 6242, 8, 263, 3, 263, 6244, 8, 263, 1, 263, 1, 263, 1, 263, 3, 263,
		6249, 8, 263, 1, 263, 1, 263, 3, 263, 6253, 8, 263, 1, 263, 3, 263, 6256,
		8, 263, 3, 263, 6258, 8, 263, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 3,
		264, 6265, 8, 264, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265, 6272,
		8, 265, 1, 265, 3, 265, 6275, 8, 265, 1, 265, 3, 265, 6278, 8, 265, 1,
		265, 1, 265, 1, 265, 1, 265, 3, 265, 6284, 8, 265, 1, 265, 1, 265, 3, 265,
		6288, 8, 265, 1, 266, 1, 266, 1, 266, 1, 266, 3, 266, 6294, 8, 266, 1,
		267, 1, 267, 1, 267, 1, 267, 3, 267, 6300, 8, 267, 1, 267, 1, 267, 1, 268,
		1, 268, 1, 268, 1, 268, 1, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270,
		1, 271, 1, 271, 1, 271, 3, 271, 6317, 8, 271, 1, 271, 1, 271, 1, 271, 3,
		271, 6322, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271, 5, 271, 6328, 8, 271,
		10, 271, 12, 271, 6331, 9, 271, 3, 271, 6333, 8, 271, 1, 272, 1, 272, 1,
		272, 3, 272, 6338, 8, 272, 1, 272, 1, 272, 1, 272, 3, 272, 6343, 8, 272,
		1, 272, 1, 272, 1, 272, 1, 272, 5, 272, 6349, 8, 272, 10, 272, 12, 272,
		6352, 9, 272, 3, 272, 6354, 8, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1,
		273, 1, 273, 3, 273, 6362, 8, 273, 1, 274, 1, 274, 3, 274, 6366, 8, 274,
		1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274,
		5, 274, 6377, 8, 274, 10, 274, 12, 274, 6380, 9, 274, 1, 274, 1, 274, 1,
		274, 3, 274, 6385, 8, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274,
		1, 274, 1, 274, 5, 274, 6395, 8, 274, 10, 274, 12, 274, 6398, 9, 274, 3,
		274, 6400, 8, 274, 1, 275, 1, 275, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276,
		3, 276, 6409, 8, 276, 1, 276, 1, 276, 1, 276, 3, 276, 6414, 8, 276, 1,
		277, 1, 277, 1, 277, 1, 277, 3, 277, 6420, 8, 277, 1, 278, 1, 278, 1, 279,
		1, 279, 3, 279, 6426, 8, 279, 1, 280, 1, 280, 1, 280, 3, 280, 6431, 8,
		280, 3, 280, 6433, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 6438, 8, 280,
		3, 280, 6440, 8, 280, 1, 281, 1, 281, 3, 281, 6444, 8, 281, 1, 281, 1,
		281, 1, 281, 1, 281, 3, 281, 6450, 8, 281, 1, 281, 3, 281, 6453, 8, 281,
		1, 281, 3, 281, 6456, 8, 281, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 3, 282, 6465, 8, 282, 1, 283, 1, 283, 1, 284, 1, 284, 1, 284,
		1, 284, 3, 284, 6473, 8, 284, 1, 285, 1, 285, 3, 285, 6477, 8, 285, 1,
		286, 1, 286, 1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1,
		288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 4,
		288, 6497, 8, 288, 11, 288, 12, 288, 6498, 1, 289, 1, 289, 1, 289, 1, 289,
		1, 289, 3, 289, 6506, 8, 289, 3, 289, 6508, 8, 289, 1, 290, 1, 290, 1,
		290, 4, 290, 6513, 8, 290, 11, 290, 12, 290, 6514, 3, 290, 6517, 8, 290,
		1, 291, 1, 291, 3, 291, 6521, 8, 291, 1, 292, 1, 292, 1, 292, 3, 292, 6526,
		8, 292, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 3, 293, 6537, 8, 293, 1, 294, 1, 294, 1, 294, 3, 294, 6542, 8,
		294, 1, 295, 1, 295, 1, 296, 1, 296, 3, 296, 6548, 8, 296, 1, 297, 3, 297,
		6551, 8, 297, 1, 297, 1, 297, 3, 297, 6555, 8, 297, 1, 297, 4, 297, 6558,
		8, 297, 11, 297, 12, 297, 6559, 1, 297, 3, 297, 6563, 8, 297, 1, 297, 1,
		297, 3, 297, 6567, 8, 297, 1, 297, 1, 297, 3, 297, 6571, 8, 297, 3, 297,
		6573, 8, 297, 1, 298, 1, 298, 1, 299, 3, 299, 6578, 8, 299, 1, 299, 1,
		299, 1, 300, 3, 300, 6583, 8, 300, 1, 300, 1, 300, 1, 301, 1, 301, 1, 301,
		1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 3, 301, 6596, 8, 301, 1,
		301, 3, 301, 6599, 8, 301, 1, 302, 1, 302, 3, 302, 6603, 8, 302, 1, 302,
		3, 302, 6606, 8, 302, 1, 302, 3, 302, 6609, 8, 302, 1, 302, 1, 302, 1,
		302, 3, 302, 6614, 8, 302, 1, 302, 1, 302, 1, 302, 3, 302, 6619, 8, 302,
		1, 302, 1, 302, 1, 302, 3, 302, 6624, 8, 302, 1, 302, 3, 302, 6627, 8,
		302, 1, 302, 1, 302, 1, 302, 3, 302, 6632, 8, 302, 1, 302, 3, 302, 6635,
		8, 302, 1, 302, 1, 302, 1, 302, 1, 302, 3, 302, 6641, 8, 302, 1, 302, 3,
		302, 6644, 8, 302, 1, 302, 1, 302, 3, 302, 6648, 8, 302, 1, 302, 5, 302,
		6651, 8, 302, 10, 302, 12, 302, 6654, 9, 302, 1, 302, 1, 302, 3, 302, 6658,
		8, 302, 1, 302, 5, 302, 6661, 8, 302, 10, 302, 12, 302, 6664, 9, 302, 1,
		302, 1, 302, 3, 302, 6668, 8, 302, 1, 302, 3, 302, 6671, 8, 302, 1, 302,
		5, 302, 6674, 8, 302, 10, 302, 12, 302, 6677, 9, 302, 1, 302, 1, 302, 3,
		302, 6681, 8, 302, 1, 302, 5, 302, 6684, 8, 302, 10, 302, 12, 302, 6687,
		9, 302, 1, 302, 1, 302, 1, 302, 3, 302, 6692, 8, 302, 1, 302, 1, 302, 1,
		302, 3, 302, 6697, 8, 302, 1, 302, 1, 302, 1, 302, 3, 302, 6702, 8, 302,
		1, 302, 1, 302, 1, 302, 3, 302, 6707, 8, 302, 1, 302, 3, 302, 6710, 8,
		302, 1, 302, 1, 302, 1, 302, 3, 302, 6715, 8, 302, 1, 302, 1, 302, 3, 302,
		6719, 8, 302, 1, 302, 1, 302, 3, 302, 6723, 8, 302, 1, 303, 1, 303, 1,
		303, 1, 303, 5, 303, 6729, 8, 303, 10, 303, 12, 303, 6732, 9, 303, 1, 303,
		1, 303, 1, 304, 1, 304, 3, 304, 6738, 8, 304, 1, 304, 1, 304, 3, 304, 6742,
		8, 304, 1, 304, 1, 304, 1, 304, 3, 304, 6747, 8, 304, 1, 304, 1, 304, 1,
		304, 3, 304, 6752, 8, 304, 1, 304, 1, 304, 3, 304, 6756, 8, 304, 3, 304,
		6758, 8, 304, 1, 304, 3, 304, 6761, 8, 304, 1, 305, 1, 305, 1, 305, 1,
		305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 307, 1, 307, 1,
		307, 1, 307, 3, 307, 6777, 8, 307, 1, 307, 1, 307, 1, 308, 1, 308, 1, 308,
		5, 308, 6784, 8, 308, 10, 308, 12, 308, 6787, 9, 308, 1, 309, 1, 309, 1,
		309, 5, 309, 6792, 8, 309, 10, 309, 12, 309, 6795, 9, 309, 1, 310, 1, 310,
		1, 310, 1, 310, 5, 310, 6801, 8, 310, 10, 310, 12, 310, 6804, 9, 310, 1,
		310, 1, 310, 1, 311, 1, 311, 1, 311, 5, 311, 6811, 8, 311, 10, 311, 12,
		311, 6814, 9, 311, 1, 312, 1, 312, 1, 312, 5, 312, 6819, 8, 312, 10, 312,
		12, 312, 6822, 9, 312, 1, 313, 1, 313, 1, 313, 5, 313, 6827, 8, 313, 10,
		313, 12, 313, 6830, 9, 313, 1, 314, 1, 314, 1, 314, 5, 314, 6835, 8, 314,
		10, 314, 12, 314, 6838, 9, 314, 1, 315, 1, 315, 1, 315, 5, 315, 6843, 8,
		315, 10, 315, 12, 315, 6846, 9, 315, 1, 316, 1, 316, 1, 316, 1, 316, 1,
		316, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 6857, 8, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 3, 316, 6864, 8, 316, 1, 316, 1, 316, 1, 316, 1,
		316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1,
		316, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 6883, 8, 316, 1, 317, 1, 317,
		1, 317, 3, 317, 6888, 8, 317, 1, 317, 3, 317, 6891, 8, 317, 1, 317, 1,
		317, 1, 317, 3, 317, 6896, 8, 317, 1, 317, 3, 317, 6899, 8, 317, 1, 318,
		1, 318, 3, 318, 6903, 8, 318, 1, 319, 1, 319, 1, 319, 1, 320, 1, 320, 1,
		320, 1, 320, 1, 321, 1, 321, 1, 321, 1, 322, 1, 322, 1, 322, 3, 322, 6918,
		8, 322, 1, 323, 1, 323, 1, 323, 3, 323, 6923, 8, 323, 1, 324, 1, 324, 1,
		324, 1, 324, 1, 324, 1, 324, 3, 324, 6931, 8, 324, 1, 324, 1, 324, 1, 324,
		1, 324, 1, 324, 3, 324, 6938, 8, 324, 1, 324, 1, 324, 1, 324, 3, 324, 6943,
		8, 324, 1, 325, 1, 325, 1, 325, 3, 325, 6948, 8, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 4,
		325, 6979, 8, 325, 11, 325, 12, 325, 6980, 1, 325, 1, 325, 3, 325, 6985,
		8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 4, 325, 6991, 8, 325, 11, 325,
		12, 325, 6992, 1, 325, 1, 325, 3, 325, 6997, 8, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7006, 8, 325, 1, 325, 1, 325,
		1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7014, 8, 325, 1, 325, 1, 325, 1,
		325, 3, 325, 7019, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325,
		3, 325, 7027, 8, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7032, 8, 325, 1,
		325, 1, 325, 1, 325, 3, 325, 7037, 8, 325, 3, 325, 7039, 8, 325, 1, 325,
		1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7048, 8, 325, 1,
		325, 1, 325, 1, 325, 3, 325, 7053, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325,
		1, 325, 1, 325, 3, 325, 7061, 8, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7066,
		8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7074, 8,
		325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 7082, 8, 325,
		1, 325, 3, 325, 7085, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 3, 325, 7095, 8, 325, 1, 325, 1, 325, 1, 325, 1, 325,
		1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325,
		1, 325, 1, 325, 1, 325, 3, 325, 7113, 8, 325, 1, 325, 3, 325, 7116, 8,
		325, 1, 325, 3, 325, 7119, 8, 325, 1, 325, 1, 325, 3, 325, 7123, 8, 325,
		1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 327, 1, 327, 1, 327, 1, 327,
		5, 327, 7134, 8, 327, 10, 327, 12, 327, 7137, 9, 327, 1, 327, 1, 327, 1,
		327, 1, 327, 1, 327, 3, 327, 7144, 8, 327, 1, 328, 1, 328, 3, 328, 7148,
		8, 328, 1, 329, 1, 329, 1, 329, 3, 329, 7153, 8, 329, 1, 329, 1, 329, 1,
		329, 3, 329, 7158, 8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 7164,
		8, 329, 1, 329, 1, 329, 1, 329, 3, 329, 7169, 8, 329, 1, 329, 1, 329, 3,
		329, 7173, 8, 329, 1, 329, 1, 329, 1, 329, 3, 329, 7178, 8, 329, 1, 329,
		1, 329, 1, 329, 3, 329, 7183, 8, 329, 1, 329, 1, 329, 1, 329, 3, 329, 7188,
		8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 5, 329, 7196, 8,
		329, 10, 329, 12, 329, 7199, 9, 329, 3, 329, 7201, 8, 329, 1, 329, 1, 329,
		3, 329, 7205, 8, 329, 1, 329, 1, 329, 3, 329, 7209, 8, 329, 1, 330, 1,
		330, 1, 330, 1, 330, 1, 330, 3, 330, 7216, 8, 330, 1, 330, 1, 330, 3, 330,
		7220, 8, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1,
		330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1,
		330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1,
		330, 1, 330, 3, 330, 7249, 8, 330, 1, 331, 1, 331, 1, 331, 3, 331, 7254,
		8, 331, 1, 331, 1, 331, 3, 331, 7258, 8, 331, 1, 332, 3, 332, 7261, 8,
		332, 1, 332, 3, 332, 7264, 8, 332, 1, 332, 3, 332, 7267, 8, 332, 1, 332,
		3, 332, 7270, 8, 332, 1, 333, 1, 333, 1, 334, 1, 334, 1, 334, 1, 335, 1,
		335, 1, 336, 1, 336, 3, 336, 7281, 8, 336, 1, 337, 1, 337, 1, 337, 1, 337,
		1, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 3, 338,
		7295, 8, 338, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 5, 339, 7302, 8,
		339, 10, 339, 12, 339, 7305, 9, 339, 1, 340, 1, 340, 1, 340, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1,
		340, 3, 340, 7330, 8, 340, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 342,
		1, 342, 1, 342, 1, 342, 3, 342, 7341, 8, 342, 1, 342, 1, 342, 1, 342, 1,
		342, 1, 342, 3, 342, 7348, 8, 342, 5, 342, 7350, 8, 342, 10, 342, 12, 342,
		7353, 9, 342, 1, 343, 1, 343, 1, 343, 1, 343, 3, 343, 7359, 8, 343, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 7367, 8, 344, 1, 344,
		1, 344, 1, 344, 3, 344, 7372, 8, 344, 1, 344, 1, 344, 1, 344, 1, 344, 5,
		344, 7378, 8, 344, 10, 344, 12, 344, 7381, 9, 344, 1, 345, 1, 345, 1, 345,
		3, 345, 7386, 8, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1,
		345, 1, 345, 3, 345, 7396, 8, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345,
		1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 3, 345, 7409, 8, 345, 1,
		345, 1, 345, 1, 345, 1, 345, 3, 345, 7415, 8, 345, 1, 345, 1, 345, 1, 345,
		1, 345, 3, 345, 7421, 8, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1,
		345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 3,
		345, 7437, 8, 345, 1, 345, 1, 345, 1, 345, 1, 345, 3, 345, 7443, 8, 345,
		1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 5, 345, 7452, 8,
		345, 10, 345, 12, 345, 7455, 9, 345, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 5, 346, 7471, 8, 346, 10, 346, 12, 346, 7474, 9, 346, 1, 346, 1, 346,
		1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 4, 346, 7483, 8, 346, 11, 346,
		12, 346, 7484, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346,
		1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346,
		7502, 8, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 5, 346, 7519,
		8, 346, 10, 346, 12, 346, 7522, 9, 346, 1, 347, 1, 347, 1, 348, 1, 348,
		1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348,
		1, 348, 1, 348, 1, 348, 3, 348, 7540, 8, 348, 1, 349, 1, 349, 1, 349, 1,
		349, 1, 349, 1, 349, 1, 349, 3, 349, 7549, 8, 349, 1, 350, 1, 350, 1, 350,
		1, 350, 1, 350, 1, 350, 1, 350, 3, 350, 7558, 8, 350, 1, 351, 1, 351, 1,
		352, 1, 352, 1, 352, 1, 352, 1, 352, 3, 352, 7567, 8, 352, 1, 353, 1, 353,
		1, 354, 1, 354, 1, 355, 1, 355, 1, 356, 1, 356, 1, 357, 1, 357, 1, 358,
		1, 358, 1, 359, 1, 359, 1, 359, 0, 3, 688, 690, 692, 360, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
		294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
		324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
		354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
		384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
		414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442,
		444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472,
		474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502,
		504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532,
		534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562,
		564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592,
		594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622,
		624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652,
		654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682,
		684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712,
		714, 716, 718, 0, 153, 2, 0, 40, 40, 151, 151, 2, 0, 532, 532, 538, 538,
		3, 0, 69, 69, 159, 159, 181, 181, 5, 0, 43, 43, 384, 384, 454, 454, 458,
		458, 524, 524, 4, 0, 43, 43, 419, 419, 530, 530, 613, 613, 2, 0, 515, 515,
		1169, 1169, 2, 0, 78, 78, 142, 142, 2, 0, 15, 15, 334, 334, 3, 0, 45, 45,
		85, 85, 184, 184, 2, 0, 434, 434, 559, 559, 3, 0, 507, 507, 653, 653, 662,
		662, 2, 0, 392, 392, 460, 460, 2, 0, 352, 352, 474, 474, 2, 0, 20, 20,
		1145, 1145, 2, 0, 192, 192, 1145, 1145, 2, 0, 43, 43, 1159, 1160, 3, 0,
		350, 350, 443, 443, 605, 605, 2, 0, 459, 459, 677, 677, 2, 0, 522, 522,
		689, 689, 3, 0, 80, 80, 84, 84, 125, 125, 3, 0, 43, 43, 402, 402, 431,
		431, 3, 0, 43, 43, 398, 398, 799, 799, 3, 0, 640, 640, 676, 676, 1118,
		1118, 2, 0, 81, 81, 91, 91, 3, 0, 436, 436, 549, 549, 615, 615, 2, 0, 69,
		69, 159, 159, 1, 0, 356, 357, 1, 0, 1159, 1160, 2, 0, 1169, 1169, 1177,
		1177, 2, 0, 81, 81, 388, 388, 2, 0, 546, 546, 1169, 1169, 2, 0, 547, 547,
		1169, 1169, 3, 0, 430, 430, 469, 469, 522, 522, 7, 0, 43, 43, 370, 370,
		372, 372, 402, 402, 431, 431, 575, 575, 1177, 1177, 2, 0, 515, 515, 531,
		531, 1, 0, 1160, 1161, 2, 0, 5, 5, 52, 52, 4, 0, 43, 43, 384, 384, 454,
		454, 458, 458, 2, 0, 27, 27, 31, 31, 2, 0, 12, 12, 175, 175, 2, 0, 192,
		192, 681, 681, 3, 0, 43, 43, 384, 384, 454, 454, 2, 0, 22, 22, 145, 145,
		3, 0, 44, 44, 75, 75, 106, 106, 2, 0, 106, 106, 374, 374, 2, 0, 365, 365,
		427, 427, 2, 0, 101, 101, 603, 603, 2, 0, 44, 44, 106, 106, 2, 0, 6, 6,
		50, 50, 2, 0, 188, 188, 673, 673, 4, 0, 430, 430, 469, 469, 521, 521, 563,
		563, 2, 0, 430, 430, 521, 521, 2, 0, 13, 13, 46, 46, 3, 0, 66, 66, 78,
		78, 186, 186, 2, 0, 35, 35, 83, 83, 2, 0, 97, 97, 149, 149, 2, 0, 6, 6,
		50, 51, 1, 0, 629, 630, 2, 0, 172, 172, 749, 749, 2, 0, 439, 439, 611,
		611, 2, 0, 226, 226, 478, 478, 5, 0, 107, 107, 483, 484, 486, 486, 490,
		498, 577, 577, 4, 0, 480, 481, 485, 485, 487, 488, 578, 578, 3, 0, 108,
		108, 479, 479, 489, 489, 2, 0, 462, 462, 631, 631, 2, 0, 625, 625, 627,
		627, 2, 0, 344, 344, 632, 632, 2, 0, 90, 90, 593, 593, 2, 0, 52, 52, 390,
		390, 3, 0, 32, 32, 61, 61, 179, 179, 3, 0, 132, 132, 172, 172, 437, 437,
		2, 0, 192, 192, 1113, 1113, 3, 0, 12, 12, 20, 20, 187, 187, 2, 0, 12, 12,
		187, 187, 2, 0, 43, 43, 121, 121, 2, 0, 103, 103, 182, 182, 4, 0, 360,
		360, 478, 478, 616, 616, 1123, 1123, 3, 0, 41, 41, 152, 152, 675, 675,
		3, 0, 707, 707, 1126, 1126, 1128, 1128, 2, 0, 115, 115, 474, 474, 2, 0,
		422, 422, 570, 570, 4, 0, 206, 206, 208, 208, 214, 214, 641, 641, 2, 0,
		1129, 1129, 1145, 1145, 2, 0, 68, 68, 80, 80, 7, 0, 132, 132, 172, 172,
		177, 177, 415, 415, 437, 437, 609, 609, 675, 675, 2, 0, 514, 514, 637,
		637, 2, 0, 412, 412, 679, 679, 2, 0, 132, 132, 437, 437, 3, 0, 81, 81,
		92, 92, 452, 452, 2, 0, 616, 616, 1123, 1123, 1, 0, 703, 706, 3, 0, 439,
		439, 474, 474, 611, 611, 2, 0, 637, 637, 674, 674, 2, 0, 345, 345, 478,
		478, 2, 0, 617, 617, 1124, 1124, 2, 0, 376, 376, 568, 568, 6, 0, 226, 226,
		409, 409, 411, 411, 438, 438, 576, 576, 618, 618, 2, 0, 46, 47, 62, 62,
		3, 0, 422, 422, 551, 551, 892, 892, 2, 0, 466, 466, 655, 655, 10, 0, 359,
		359, 367, 367, 378, 380, 387, 387, 508, 508, 516, 516, 642, 642, 649, 649,
		843, 843, 1011, 1011, 2, 0, 36, 36, 168, 168, 2, 0, 117, 117, 1002, 1002,
		11, 0, 359, 359, 367, 367, 378, 380, 387, 387, 508, 508, 516, 516, 594,
		594, 642, 642, 649, 649, 843, 843, 1011, 1011, 1, 0, 1182, 1183, 4, 0,
		375, 375, 794, 805, 1169, 1169, 1177, 1178, 2, 0, 404, 404, 1169, 1169,
		3, 0, 1159, 1161, 1170, 1170, 1172, 1172, 2, 0, 63, 63, 178, 178, 2, 0,
		116, 116, 1173, 1173, 5, 0, 26, 26, 222, 224, 231, 231, 233, 236, 519,
		519, 2, 0, 26, 26, 223, 223, 2, 0, 26, 26, 222, 222, 1, 0, 196, 207, 3,
		0, 183, 183, 195, 195, 614, 614, 2, 0, 211, 216, 431, 431, 6, 0, 217, 217,
		228, 228, 230, 230, 232, 232, 239, 239, 348, 349, 4, 0, 218, 221, 226,
		227, 229, 229, 346, 346, 2, 0, 154, 154, 237, 237, 2, 0, 466, 466, 810,
		818, 2, 0, 226, 226, 519, 519, 5, 0, 200, 200, 206, 206, 217, 218, 220,
		220, 466, 466, 2, 0, 183, 183, 614, 614, 1, 0, 1114, 1115, 2, 0, 521, 521,
		1117, 1117, 2, 0, 315, 318, 322, 322, 4, 0, 38, 38, 151, 151, 313, 318,
		331, 331, 1, 0, 325, 326, 3, 0, 18, 18, 95, 95, 176, 176, 2, 0, 222, 222,
		226, 226, 2, 0, 217, 218, 220, 220, 3, 0, 13, 13, 46, 46, 1000, 1000, 3,
		0, 286, 286, 298, 299, 309, 309, 3, 0, 287, 289, 305, 308, 310, 312, 2,
		0, 295, 295, 297, 297, 2, 0, 293, 293, 296, 296, 2, 0, 291, 292, 302, 304,
		2, 0, 134, 134, 603, 603, 2, 0, 433, 433, 560, 560, 2, 0, 536, 536, 552,
		552, 2, 0, 114, 114, 1148, 1148, 3, 0, 63, 63, 178, 178, 666, 666, 2, 0,
		138, 138, 150, 150, 3, 0, 6, 6, 337, 337, 621, 621, 3, 0, 114, 114, 1141,
		1142, 1148, 1149, 1, 0, 1138, 1144, 2, 0, 226, 226, 753, 793, 1, 0, 806,
		809, 5, 0, 716, 717, 732, 734, 740, 740, 746, 747, 749, 749, 1, 0, 695,
		702, 3, 0, 217, 221, 234, 234, 237, 237, 52, 0, 14, 14, 17, 17, 19, 19,
		30, 30, 36, 38, 43, 43, 49, 49, 56, 56, 59, 59, 73, 73, 79, 79, 94, 94,
		104, 104, 110, 111, 117, 117, 121, 121, 124, 124, 130, 131, 158, 158, 168,
		168, 170, 170, 239, 239, 283, 290, 294, 294, 298, 299, 305, 312, 332, 432,
		434, 458, 460, 545, 548, 559, 561, 594, 596, 639, 641, 676, 678, 679, 681,
		688, 690, 694, 703, 707, 709, 715, 718, 719, 724, 725, 727, 731, 735, 739,
		741, 741, 743, 745, 748, 748, 750, 752, 799, 799, 843, 843, 882, 882, 1006,
		1006, 1011, 1011, 1113, 1128, 23, 0, 40, 40, 97, 97, 149, 149, 151, 151,
		217, 219, 221, 221, 251, 282, 290, 293, 295, 297, 300, 304, 324, 324, 459,
		459, 677, 677, 695, 702, 743, 743, 810, 810, 813, 842, 844, 881, 883, 1005,
		1007, 1010, 1012, 1112, 1114, 1116, 1144, 1144, 8966, 0, 721, 1, 0, 0,
		0, 2, 740, 1, 0, 0, 0, 4, 755, 1, 0, 0, 0, 6, 766, 1, 0, 0, 0, 8, 782,
		1, 0, 0, 0, 10, 825, 1, 0, 0, 0, 12, 838, 1, 0, 0, 0, 14, 849, 1, 0, 0,
		0, 16, 866, 1, 0, 0, 0, 18, 871, 1, 0, 0, 0, 20, 883, 1, 0, 0, 0, 22, 911,
		1, 0, 0, 0, 24, 920, 1, 0, 0, 0, 26, 922, 1, 0, 0, 0, 28, 934, 1, 0, 0,
		0, 30, 964, 1, 0, 0, 0, 32, 1009, 1, 0, 0, 0, 34, 1060, 1, 0, 0, 0, 36,
		1089, 1, 0, 0, 0, 38, 1128, 1, 0, 0, 0, 40, 1141, 1, 0, 0, 0, 42, 1247,
		1, 0, 0, 0, 44, 1249, 1, 0, 0, 0, 46, 1267, 1, 0, 0, 0, 48, 1328, 1, 0,
		0, 0, 50, 1350, 1, 0, 0, 0, 52, 1356, 1, 0, 0, 0, 54, 1378, 1, 0, 0, 0,
		56, 1380, 1, 0, 0, 0, 58, 1382, 1, 0, 0, 0, 60, 1429, 1, 0, 0, 0, 62, 1487,
		1, 0, 0, 0, 64, 1522, 1, 0, 0, 0, 66, 1529, 1, 0, 0, 0, 68, 1531, 1, 0,
		0, 0, 70, 1536, 1, 0, 0, 0, 72, 1577, 1, 0, 0, 0, 74, 1583, 1, 0, 0, 0,
		76, 1585, 1, 0, 0, 0, 78, 1606, 1, 0, 0, 0, 80, 1613, 1, 0, 0, 0, 82, 1615,
		1, 0, 0, 0, 84, 1648, 1, 0, 0, 0, 86, 1651, 1, 0, 0, 0, 88, 1656, 1, 0,
		0, 0, 90, 1682, 1, 0, 0, 0, 92, 1698, 1, 0, 0, 0, 94, 1700, 1, 0, 0, 0,
		96, 1716, 1, 0, 0, 0, 98, 1718, 1, 0, 0, 0, 100, 1778, 1, 0, 0, 0, 102,
		1849, 1, 0, 0, 0, 104, 1851, 1, 0, 0, 0, 106, 1879, 1, 0, 0, 0, 108, 1887,
		1, 0, 0, 0, 110, 1917, 1, 0, 0, 0, 112, 2110, 1, 0, 0, 0, 114, 2112, 1,
		0, 0, 0, 116, 2114, 1, 0, 0, 0, 118, 2117, 1, 0, 0, 0, 120, 2191, 1, 0,
		0, 0, 122, 2214, 1, 0, 0, 0, 124, 2362, 1, 0, 0, 0, 126, 2367, 1, 0, 0,
		0, 128, 2369, 1, 0, 0, 0, 130, 2379, 1, 0, 0, 0, 132, 2435, 1, 0, 0, 0,
		134, 2455, 1, 0, 0, 0, 136, 2457, 1, 0, 0, 0, 138, 2492, 1, 0, 0, 0, 140,
		2501, 1, 0, 0, 0, 142, 2508, 1, 0, 0, 0, 144, 2531, 1, 0, 0, 0, 146, 2540,
		1, 0, 0, 0, 148, 2555, 1, 0, 0, 0, 150, 2580, 1, 0, 0, 0, 152, 2600, 1,
		0, 0, 0, 154, 2632, 1, 0, 0, 0, 156, 3066, 1, 0, 0, 0, 158, 3068, 1, 0,
		0, 0, 160, 3075, 1, 0, 0, 0, 162, 3082, 1, 0, 0, 0, 164, 3111, 1, 0, 0,
		0, 166, 3119, 1, 0, 0, 0, 168, 3126, 1, 0, 0, 0, 170, 3133, 1, 0, 0, 0,
		172, 3140, 1, 0, 0, 0, 174, 3155, 1, 0, 0, 0, 176, 3165, 1, 0, 0, 0, 178,
		3172, 1, 0, 0, 0, 180, 3188, 1, 0, 0, 0, 182, 3234, 1, 0, 0, 0, 184, 3236,
		1, 0, 0, 0, 186, 3255, 1, 0, 0, 0, 188, 3265, 1, 0, 0, 0, 190, 3272, 1,
		0, 0, 0, 192, 3280, 1, 0, 0, 0, 194, 3292, 1, 0, 0, 0, 196, 3294, 1, 0,
		0, 0, 198, 3301, 1, 0, 0, 0, 200, 3303, 1, 0, 0, 0, 202, 3354, 1, 0, 0,
		0, 204, 3428, 1, 0, 0, 0, 206, 3487, 1, 0, 0, 0, 208, 3582, 1, 0, 0, 0,
		210, 3586, 1, 0, 0, 0, 212, 3588, 1, 0, 0, 0, 214, 3623, 1, 0, 0, 0, 216,
		3625, 1, 0, 0, 0, 218, 3633, 1, 0, 0, 0, 220, 3641, 1, 0, 0, 0, 222, 3646,
		1, 0, 0, 0, 224, 3676, 1, 0, 0, 0, 226, 3731, 1, 0, 0, 0, 228, 3740, 1,
		0, 0, 0, 230, 3760, 1, 0, 0, 0, 232, 3772, 1, 0, 0, 0, 234, 3776, 1, 0,
		0, 0, 236, 3809, 1, 0, 0, 0, 238, 3830, 1, 0, 0, 0, 240, 3840, 1, 0, 0,
		0, 242, 3844, 1, 0, 0, 0, 244, 3870, 1, 0, 0, 0, 246, 3912, 1, 0, 0, 0,
		248, 3914, 1, 0, 0, 0, 250, 3929, 1, 0, 0, 0, 252, 3981, 1, 0, 0, 0, 254,
		3991, 1, 0, 0, 0, 256, 4001, 1, 0, 0, 0, 258, 4061, 1, 0, 0, 0, 260, 4063,
		1, 0, 0, 0, 262, 4089, 1, 0, 0, 0, 264, 4095, 1, 0, 0, 0, 266, 4103, 1,
		0, 0, 0, 268, 4120, 1, 0, 0, 0, 270, 4136, 1, 0, 0, 0, 272, 4173, 1, 0,
		0, 0, 274, 4179, 1, 0, 0, 0, 276, 4188, 1, 0, 0, 0, 278, 4201, 1, 0, 0,
		0, 280, 4205, 1, 0, 0, 0, 282, 4243, 1, 0, 0, 0, 284, 4281, 1, 0, 0, 0,
		286, 4295, 1, 0, 0, 0, 288, 4303, 1, 0, 0, 0, 290, 4307, 1, 0, 0, 0, 292,
		4313, 1, 0, 0, 0, 294, 4327, 1, 0, 0, 0, 296, 4330, 1, 0, 0, 0, 298, 4348,
		1, 0, 0, 0, 300, 4352, 1, 0, 0, 0, 302, 4368, 1, 0, 0, 0, 304, 4370, 1,
		0, 0, 0, 306, 4382, 1, 0, 0, 0, 308, 4386, 1, 0, 0, 0, 310, 4403, 1, 0,
		0, 0, 312, 4420, 1, 0, 0, 0, 314, 4423, 1, 0, 0, 0, 316, 4433, 1, 0, 0,
		0, 318, 4437, 1, 0, 0, 0, 320, 4450, 1, 0, 0, 0, 322, 4453, 1, 0, 0, 0,
		324, 4458, 1, 0, 0, 0, 326, 4478, 1, 0, 0, 0, 328, 4480, 1, 0, 0, 0, 330,
		4497, 1, 0, 0, 0, 332, 4506, 1, 0, 0, 0, 334, 4515, 1, 0, 0, 0, 336, 4517,
		1, 0, 0, 0, 338, 4531, 1, 0, 0, 0, 340, 4542, 1, 0, 0, 0, 342, 4551, 1,
		0, 0, 0, 344, 4554, 1, 0, 0, 0, 346, 4562, 1, 0, 0, 0, 348, 4587, 1, 0,
		0, 0, 350, 4599, 1, 0, 0, 0, 352, 4602, 1, 0, 0, 0, 354, 4634, 1, 0, 0,
		0, 356, 4636, 1, 0, 0, 0, 358, 4638, 1, 0, 0, 0, 360, 4640, 1, 0, 0, 0,
		362, 4642, 1, 0, 0, 0, 364, 4695, 1, 0, 0, 0, 366, 4697, 1, 0, 0, 0, 368,
		4703, 1, 0, 0, 0, 370, 4723, 1, 0, 0, 0, 372, 4737, 1, 0, 0, 0, 374, 4748,
		1, 0, 0, 0, 376, 4750, 1, 0, 0, 0, 378, 4756, 1, 0, 0, 0, 380, 4766, 1,
		0, 0, 0, 382, 4770, 1, 0, 0, 0, 384, 4777, 1, 0, 0, 0, 386, 4781, 1, 0,
		0, 0, 388, 4787, 1, 0, 0, 0, 390, 4794, 1, 0, 0, 0, 392, 4800, 1, 0, 0,
		0, 394, 4806, 1, 0, 0, 0, 396, 4811, 1, 0, 0, 0, 398, 4858, 1, 0, 0, 0,
		400, 4879, 1, 0, 0, 0, 402, 4904, 1, 0, 0, 0, 404, 4907, 1, 0, 0, 0, 406,
		4913, 1, 0, 0, 0, 408, 4929, 1, 0, 0, 0, 410, 4944, 1, 0, 0, 0, 412, 4950,
		1, 0, 0, 0, 414, 4980, 1, 0, 0, 0, 416, 4982, 1, 0, 0, 0, 418, 4989, 1,
		0, 0, 0, 420, 5001, 1, 0, 0, 0, 422, 5007, 1, 0, 0, 0, 424, 5032, 1, 0,
		0, 0, 426, 5036, 1, 0, 0, 0, 428, 5040, 1, 0, 0, 0, 430, 5051, 1, 0, 0,
		0, 432, 5119, 1, 0, 0, 0, 434, 5181, 1, 0, 0, 0, 436, 5183, 1, 0, 0, 0,
		438, 5289, 1, 0, 0, 0, 440, 5313, 1, 0, 0, 0, 442, 5315, 1, 0, 0, 0, 444,
		5333, 1, 0, 0, 0, 446, 5407, 1, 0, 0, 0, 448, 5409, 1, 0, 0, 0, 450, 5422,
		1, 0, 0, 0, 452, 5433, 1, 0, 0, 0, 454, 5463, 1, 0, 0, 0, 456, 5474, 1,
		0, 0, 0, 458, 5484, 1, 0, 0, 0, 460, 5494, 1, 0, 0, 0, 462, 5534, 1, 0,
		0, 0, 464, 5536, 1, 0, 0, 0, 466, 5539, 1, 0, 0, 0, 468, 5666, 1, 0, 0,
		0, 470, 5684, 1, 0, 0, 0, 472, 5686, 1, 0, 0, 0, 474, 5690, 1, 0, 0, 0,
		476, 5728, 1, 0, 0, 0, 478, 5737, 1, 0, 0, 0, 480, 5743, 1, 0, 0, 0, 482,
		5752, 1, 0, 0, 0, 484, 5774, 1, 0, 0, 0, 486, 5776, 1, 0, 0, 0, 488, 5793,
		1, 0, 0, 0, 490, 5799, 1, 0, 0, 0, 492, 5855, 1, 0, 0, 0, 494, 6048, 1,
		0, 0, 0, 496, 6050, 1, 0, 0, 0, 498, 6068, 1, 0, 0, 0, 500, 6083, 1, 0,
		0, 0, 502, 6089, 1, 0, 0, 0, 504, 6124, 1, 0, 0, 0, 506, 6134, 1, 0, 0,
		0, 508, 6148, 1, 0, 0, 0, 510, 6150, 1, 0, 0, 0, 512, 6153, 1, 0, 0, 0,
		514, 6189, 1, 0, 0, 0, 516, 6191, 1, 0, 0, 0, 518, 6197, 1, 0, 0, 0, 520,
		6209, 1, 0, 0, 0, 522, 6213, 1, 0, 0, 0, 524, 6215, 1, 0, 0, 0, 526, 6257,
		1, 0, 0, 0, 528, 6264, 1, 0, 0, 0, 530, 6266, 1, 0, 0, 0, 532, 6289, 1,
		0, 0, 0, 534, 6295, 1, 0, 0, 0, 536, 6303, 1, 0, 0, 0, 538, 6307, 1, 0,
		0, 0, 540, 6310, 1, 0, 0, 0, 542, 6313, 1, 0, 0, 0, 544, 6334, 1, 0, 0,
		0, 546, 6355, 1, 0, 0, 0, 548, 6363, 1, 0, 0, 0, 550, 6401, 1, 0, 0, 0,
		552, 6413, 1, 0, 0, 0, 554, 6415, 1, 0, 0, 0, 556, 6421, 1, 0, 0, 0, 558,
		6425, 1, 0, 0, 0, 560, 6439, 1, 0, 0, 0, 562, 6452, 1, 0, 0, 0, 564, 6464,
		1, 0, 0, 0, 566, 6466, 1, 0, 0, 0, 568, 6472, 1, 0, 0, 0, 570, 6476, 1,
		0, 0, 0, 572, 6478, 1, 0, 0, 0, 574, 6480, 1, 0, 0, 0, 576, 6482, 1, 0,
		0, 0, 578, 6500, 1, 0, 0, 0, 580, 6516, 1, 0, 0, 0, 582, 6520, 1, 0, 0,
		0, 584, 6525, 1, 0, 0, 0, 586, 6536, 1, 0, 0, 0, 588, 6541, 1, 0, 0, 0,
		590, 6543, 1, 0, 0, 0, 592, 6547, 1, 0, 0, 0, 594, 6572, 1, 0, 0, 0, 596,
		6574, 1, 0, 0, 0, 598, 6577, 1, 0, 0, 0, 600, 6582, 1, 0, 0, 0, 602, 6598,
		1, 0, 0, 0, 604, 6722, 1, 0, 0, 0, 606, 6724, 1, 0, 0, 0, 608, 6757, 1,
		0, 0, 0, 610, 6762, 1, 0, 0, 0, 612, 6766, 1, 0, 0, 0, 614, 6772, 1, 0,
		0, 0, 616, 6780, 1, 0, 0, 0, 618, 6788, 1, 0, 0, 0, 620, 6796, 1, 0, 0,
		0, 622, 6807, 1, 0, 0, 0, 624, 6815, 1, 0, 0, 0, 626, 6823, 1, 0, 0, 0,
		628, 6831, 1, 0, 0, 0, 630, 6839, 1, 0, 0, 0, 632, 6882, 1, 0, 0, 0, 634,
		6898, 1, 0, 0, 0, 636, 6902, 1, 0, 0, 0, 638, 6904, 1, 0, 0, 0, 640, 6907,
		1, 0, 0, 0, 642, 6911, 1, 0, 0, 0, 644, 6917, 1, 0, 0, 0, 646, 6922, 1,
		0, 0, 0, 648, 6942, 1, 0, 0, 0, 650, 7122, 1, 0, 0, 0, 652, 7124, 1, 0,
		0, 0, 654, 7143, 1, 0, 0, 0, 656, 7145, 1, 0, 0, 0, 658, 7208, 1, 0, 0,
		0, 660, 7248, 1, 0, 0, 0, 662, 7250, 1, 0, 0, 0, 664, 7260, 1, 0, 0, 0,
		666, 7271, 1, 0, 0, 0, 668, 7273, 1, 0, 0, 0, 670, 7276, 1, 0, 0, 0, 672,
		7280, 1, 0, 0, 0, 674, 7282, 1, 0, 0, 0, 676, 7294, 1, 0, 0, 0, 678, 7296,
		1, 0, 0, 0, 680, 7329, 1, 0, 0, 0, 682, 7331, 1, 0, 0, 0, 684, 7340, 1,
		0, 0, 0, 686, 7358, 1, 0, 0, 0, 688, 7371, 1, 0, 0, 0, 690, 7382, 1, 0,
		0, 0, 692, 7501, 1, 0, 0, 0, 694, 7523, 1, 0, 0, 0, 696, 7539, 1, 0, 0,
		0, 698, 7548, 1, 0, 0, 0, 700, 7557, 1, 0, 0, 0, 702, 7559, 1, 0, 0, 0,
		704, 7566, 1, 0, 0, 0, 706, 7568, 1, 0, 0, 0, 708, 7570, 1, 0, 0, 0, 710,
		7572, 1, 0, 0, 0, 712, 7574, 1, 0, 0, 0, 714, 7576, 1, 0, 0, 0, 716, 7578,
		1, 0, 0, 0, 718, 7580, 1, 0, 0, 0, 720, 722, 3, 2, 1, 0, 721, 720, 1, 0,
		0, 0, 721, 722, 1, 0, 0, 0, 722, 725, 1, 0, 0, 0, 723, 724, 5, 1142, 0,
		0, 724, 726, 5, 1142, 0, 0, 725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0,
		726, 727, 1, 0, 0, 0, 727, 728, 5, 0, 0, 1, 728, 1, 1, 0, 0, 0, 729, 732,
		3, 4, 2, 0, 730, 731, 5, 1142, 0, 0, 731, 733, 5, 1142, 0, 0, 732, 730,
		1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733, 735, 1, 0, 0, 0, 734, 736, 5, 1157,
		0, 0, 735, 734, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 739, 1, 0, 0, 0,
		737, 739, 3, 8, 4, 0, 738, 729, 1, 0, 0, 0, 738, 737, 1, 0, 0, 0, 739,
		742, 1, 0, 0, 0, 740, 738, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 752,
		1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 743, 749, 3, 4, 2, 0, 744, 745, 5, 1142,
		0, 0, 745, 747, 5, 1142, 0, 0, 746, 744, 1, 0, 0, 0, 746, 747, 1, 0, 0,
		0, 747, 748, 1, 0, 0, 0, 748, 750, 5, 1157, 0, 0, 749, 746, 1, 0, 0, 0,
		749, 750, 1, 0, 0, 0, 750, 753, 1, 0, 0, 0, 751, 753, 3, 8, 4, 0, 752,
		743, 1, 0, 0, 0, 752, 751, 1, 0, 0, 0, 753, 3, 1, 0, 0, 0, 754, 756, 3,
		6, 3, 0, 755, 754, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 764, 1, 0, 0,
		0, 757, 765, 3, 10, 5, 0, 758, 765, 3, 12, 6, 0, 759, 765, 3, 14, 7, 0,
		760, 765, 3, 16, 8, 0, 761, 765, 3, 18, 9, 0, 762, 765, 3, 22, 11, 0, 763,
		765, 3, 24, 12, 0, 764, 757, 1, 0, 0, 0, 764, 758, 1, 0, 0, 0, 764, 759,
		1, 0, 0, 0, 764, 760, 1, 0, 0, 0, 764, 761, 1, 0, 0, 0, 764, 762, 1, 0,
		0, 0, 764, 763, 1, 0, 0, 0, 765, 5, 1, 0, 0, 0, 766, 767, 5, 154, 0, 0,
		767, 768, 5, 170, 0, 0, 768, 769, 5, 1177, 0, 0, 769, 770, 5, 1145, 0,
		0, 770, 777, 3, 602, 301, 0, 771, 772, 5, 1156, 0, 0, 772, 773, 5, 1177,
		0, 0, 773, 774, 5, 1145, 0, 0, 774, 776, 3, 602, 301, 0, 775, 771, 1, 0,
		0, 0, 776, 779, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 777, 778, 1, 0, 0, 0,
		778, 780, 1, 0, 0, 0, 779, 777, 1, 0, 0, 0, 780, 781, 5, 65, 0, 0, 781,
		7, 1, 0, 0, 0, 782, 783, 5, 1157, 0, 0, 783, 9, 1, 0, 0, 0, 784, 826, 3,
		26, 13, 0, 785, 826, 3, 28, 14, 0, 786, 826, 3, 30, 15, 0, 787, 826, 3,
		32, 16, 0, 788, 826, 3, 34, 17, 0, 789, 826, 3, 36, 18, 0, 790, 826, 3,
		40, 20, 0, 791, 826, 3, 42, 21, 0, 792, 826, 3, 44, 22, 0, 793, 826, 3,
		46, 23, 0, 794, 826, 3, 48, 24, 0, 795, 826, 3, 58, 29, 0, 796, 826, 3,
		38, 19, 0, 797, 826, 3, 60, 30, 0, 798, 826, 3, 134, 67, 0, 799, 826, 3,
		136, 68, 0, 800, 826, 3, 138, 69, 0, 801, 826, 3, 140, 70, 0, 802, 826,
		3, 142, 71, 0, 803, 826, 3, 144, 72, 0, 804, 826, 3, 146, 73, 0, 805, 826,
		3, 148, 74, 0, 806, 826, 3, 150, 75, 0, 807, 826, 3, 152, 76, 0, 808, 826,
		3, 154, 77, 0, 809, 826, 3, 158, 79, 0, 810, 826, 3, 160, 80, 0, 811, 826,
		3, 162, 81, 0, 812, 826, 3, 164, 82, 0, 813, 826, 3, 166, 83, 0, 814, 826,
		3, 168, 84, 0, 815, 826, 3, 170, 85, 0, 816, 826, 3, 172, 86, 0, 817, 826,
		3, 174, 87, 0, 818, 826, 3, 176, 88, 0, 819, 826, 3, 178, 89, 0, 820, 826,
		3, 180, 90, 0, 821, 826, 3, 184, 92, 0, 822, 826, 3, 182, 91, 0, 823, 826,
		3, 186, 93, 0, 824, 826, 3, 190, 95, 0, 825, 784, 1, 0, 0, 0, 825, 785,
		1, 0, 0, 0, 825, 786, 1, 0, 0, 0, 825, 787, 1, 0, 0, 0, 825, 788, 1, 0,
		0, 0, 825, 789, 1, 0, 0, 0, 825, 790, 1, 0, 0, 0, 825, 791, 1, 0, 0, 0,
		825, 792, 1, 0, 0, 0, 825, 793, 1, 0, 0, 0, 825, 794, 1, 0, 0, 0, 825,
		795, 1, 0, 0, 0, 825, 796, 1, 0, 0, 0, 825, 797, 1, 0, 0, 0, 825, 798,
		1, 0, 0, 0, 825, 799, 1, 0, 0, 0, 825, 800, 1, 0, 0, 0, 825, 801, 1, 0,
		0, 0, 825, 802, 1, 0, 0, 0, 825, 803, 1, 0, 0, 0, 825, 804, 1, 0, 0, 0,
		825, 805, 1, 0, 0, 0, 825, 806, 1, 0, 0, 0, 825, 807, 1, 0, 0, 0, 825,
		808, 1, 0, 0, 0, 825, 809, 1, 0, 0, 0, 825, 810, 1, 0, 0, 0, 825, 811,
		1, 0, 0, 0, 825, 812, 1, 0, 0, 0, 825, 813, 1, 0, 0, 0, 825, 814, 1, 0,
		0, 0, 825, 815, 1, 0, 0, 0, 825, 816, 1, 0, 0, 0, 825, 817, 1, 0, 0, 0,
		825, 818, 1, 0, 0, 0, 825, 819, 1, 0, 0, 0, 825, 820, 1, 0, 0, 0, 825,
		821, 1, 0, 0, 0, 825, 822, 1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 825, 824,
		1, 0, 0, 0, 826, 11, 1, 0, 0, 0, 827, 839, 3, 208, 104, 0, 828, 839, 3,
		200, 100, 0, 829, 839, 3, 210, 105, 0, 830, 839, 3, 194, 97, 0, 831, 839,
		3, 206, 103, 0, 832, 839, 3, 192, 96, 0, 833, 839, 3, 202, 101, 0, 834,
		839, 3, 204, 102, 0, 835, 839, 3, 196, 98, 0, 836, 839, 3, 198, 99, 0,
		837, 839, 3, 212, 106, 0, 838, 827, 1, 0, 0, 0, 838, 828, 1, 0, 0, 0, 838,
		829, 1, 0, 0, 0, 838, 830, 1, 0, 0, 0, 838, 831, 1, 0, 0, 0, 838, 832,
		1, 0, 0, 0, 838, 833, 1, 0, 0, 0, 838, 834, 1, 0, 0, 0, 838, 835, 1, 0,
		0, 0, 838, 836, 1, 0, 0, 0, 838, 837, 1, 0, 0, 0, 839, 13, 1, 0, 0, 0,
		840, 850, 3, 304, 152, 0, 841, 850, 3, 306, 153, 0, 842, 850, 3, 308, 154,
		0, 843, 850, 3, 310, 155, 0, 844, 850, 3, 312, 156, 0, 845, 850, 3, 314,
		157, 0, 846, 850, 3, 316, 158, 0, 847, 850, 3, 318, 159, 0, 848, 850, 3,
		320, 160, 0, 849, 840, 1, 0, 0, 0, 849, 841, 1, 0, 0, 0, 849, 842, 1, 0,
		0, 0, 849, 843, 1, 0, 0, 0, 849, 844, 1, 0, 0, 0, 849, 845, 1, 0, 0, 0,
		849, 846, 1, 0, 0, 0, 849, 847, 1, 0, 0, 0, 849, 848, 1, 0, 0, 0, 850,
		15, 1, 0, 0, 0, 851, 867, 3, 336, 168, 0, 852, 867, 3, 338, 169, 0, 853,
		867, 3, 340, 170, 0, 854, 867, 3, 342, 171, 0, 855, 867, 3, 344, 172, 0,
		856, 867, 3, 346, 173, 0, 857, 867, 3, 348, 174, 0, 858, 867, 3, 350, 175,
		0, 859, 867, 3, 352, 176, 0, 860, 867, 3, 376, 188, 0, 861, 867, 3, 378,
		189, 0, 862, 867, 3, 380, 190, 0, 863, 867, 3, 382, 191, 0, 864, 867, 3,
		384, 192, 0, 865, 867, 3, 386, 193, 0, 866, 851, 1, 0, 0, 0, 866, 852,
		1, 0, 0, 0, 866, 853, 1, 0, 0, 0, 866, 854, 1, 0, 0, 0, 866, 855, 1, 0,
		0, 0, 866, 856, 1, 0, 0, 0, 866, 857, 1, 0, 0, 0, 866, 858, 1, 0, 0, 0,
		866, 859, 1, 0, 0, 0, 866, 860, 1, 0, 0, 0, 866, 861, 1, 0, 0, 0, 866,
		862, 1, 0, 0, 0, 866, 863, 1, 0, 0, 0, 866, 864, 1, 0, 0, 0, 866, 865,
		1, 0, 0, 0, 867, 17, 1, 0, 0, 0, 868, 872, 3, 388, 194, 0, 869, 872, 3,
		390, 195, 0, 870, 872, 3, 392, 196, 0, 871, 868, 1, 0, 0, 0, 871, 869,
		1, 0, 0, 0, 871, 870, 1, 0, 0, 0, 872, 19, 1, 0, 0, 0, 873, 884, 3, 396,
		198, 0, 874, 884, 3, 398, 199, 0, 875, 884, 3, 400, 200, 0, 876, 884, 3,
		404, 202, 0, 877, 884, 3, 406, 203, 0, 878, 884, 3, 408, 204, 0, 879, 884,
		3, 412, 206, 0, 880, 884, 3, 402, 201, 0, 881, 884, 3, 410, 205, 0, 882,
		884, 3, 414, 207, 0, 883, 873, 1, 0, 0, 0, 883, 874, 1, 0, 0, 0, 883, 875,
		1, 0, 0, 0, 883, 876, 1, 0, 0, 0, 883, 877, 1, 0, 0, 0, 883, 878, 1, 0,
		0, 0, 883, 879, 1, 0, 0, 0, 883, 880, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0,
		883, 882, 1, 0, 0, 0, 884, 21, 1, 0, 0, 0, 885, 912, 3, 432, 216, 0, 886,
		912, 3, 434, 217, 0, 887, 912, 3, 436, 218, 0, 888, 912, 3, 438, 219, 0,
		889, 912, 3, 442, 221, 0, 890, 912, 3, 444, 222, 0, 891, 912, 3, 446, 223,
		0, 892, 912, 3, 448, 224, 0, 893, 912, 3, 474, 237, 0, 894, 912, 3, 476,
		238, 0, 895, 912, 3, 478, 239, 0, 896, 912, 3, 480, 240, 0, 897, 912, 3,
		482, 241, 0, 898, 912, 3, 486, 243, 0, 899, 912, 3, 488, 244, 0, 900, 912,
		3, 490, 245, 0, 901, 912, 3, 492, 246, 0, 902, 912, 3, 494, 247, 0, 903,
		912, 3, 510, 255, 0, 904, 912, 3, 512, 256, 0, 905, 912, 3, 514, 257, 0,
		906, 912, 3, 516, 258, 0, 907, 912, 3, 518, 259, 0, 908, 912, 3, 520, 260,
		0, 909, 912, 3, 522, 261, 0, 910, 912, 3, 496, 248, 0, 911, 885, 1, 0,
		0, 0, 911, 886, 1, 0, 0, 0, 911, 887, 1, 0, 0, 0, 911, 888, 1, 0, 0, 0,
		911, 889, 1, 0, 0, 0, 911, 890, 1, 0, 0, 0, 911, 891, 1, 0, 0, 0, 911,
		892, 1, 0, 0, 0, 911, 893, 1, 0, 0, 0, 911, 894, 1, 0, 0, 0, 911, 895,
		1, 0, 0, 0, 911, 896, 1, 0, 0, 0, 911, 897, 1, 0, 0, 0, 911, 898, 1, 0,
		0, 0, 911, 899, 1, 0, 0, 0, 911, 900, 1, 0, 0, 0, 911, 901, 1, 0, 0, 0,
		911, 902, 1, 0, 0, 0, 911, 903, 1, 0, 0, 0, 911, 904, 1, 0, 0, 0, 911,
		905, 1, 0, 0, 0, 911, 906, 1, 0, 0, 0, 911, 907, 1, 0, 0, 0, 911, 908,
		1, 0, 0, 0, 911, 909, 1, 0, 0, 0, 911, 910, 1, 0, 0, 0, 912, 23, 1, 0,
		0, 0, 913, 921, 3, 532, 266, 0, 914, 921, 3, 534, 267, 0, 915, 921, 3,
		538, 269, 0, 916, 921, 3, 540, 270, 0, 917, 921, 3, 542, 271, 0, 918, 921,
		3, 544, 272, 0, 919, 921, 3, 548, 274, 0, 920, 913, 1, 0, 0, 0, 920, 914,
		1, 0, 0, 0, 920, 915, 1, 0, 0, 0, 920, 916, 1, 0, 0, 0, 920, 917, 1, 0,
		0, 0, 920, 918, 1, 0, 0, 0, 920, 919, 1, 0, 0, 0, 921, 25, 1, 0, 0, 0,
		922, 923, 5, 34, 0, 0, 923, 925, 7, 0, 0, 0, 924, 926, 3, 640, 320, 0,
		925, 924, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927,
		931, 3, 584, 292, 0, 928, 930, 3, 64, 32, 0, 929, 928, 1, 0, 0, 0, 930,
		933, 1, 0, 0, 0, 931, 929, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 27, 1,
		0, 0, 0, 933, 931, 1, 0, 0, 0, 934, 936, 5, 34, 0, 0, 935, 937, 3, 70,
		35, 0, 936, 935, 1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0,
		938, 940, 5, 415, 0, 0, 939, 941, 3, 640, 320, 0, 940, 939, 1, 0, 0, 0,
		940, 941, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 943, 3, 554, 277, 0, 943,
		944, 5, 118, 0, 0, 944, 945, 5, 607, 0, 0, 945, 952, 3, 72, 36, 0, 946,
		947, 5, 118, 0, 0, 947, 949, 5, 371, 0, 0, 948, 950, 5, 114, 0, 0, 949,
		948, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 953,
		5, 562, 0, 0, 952, 946, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 955, 1,
		0, 0, 0, 954, 956, 3, 80, 40, 0, 955, 954, 1, 0, 0, 0, 955, 956, 1, 0,
		0, 0, 956, 959, 1, 0, 0, 0, 957, 958, 5, 368, 0, 0, 958, 960, 5, 1169,
		0, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0,
		961, 962, 5, 399, 0, 0, 962, 963, 3, 394, 197, 0, 963, 29, 1, 0, 0, 0,
		964, 966, 5, 34, 0, 0, 965, 967, 3, 642, 321, 0, 966, 965, 1, 0, 0, 0,
		966, 967, 1, 0, 0, 0, 967, 969, 1, 0, 0, 0, 968, 970, 7, 1, 0, 0, 969,
		968, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 972, 1, 0, 0, 0, 971, 973,
		7, 2, 0, 0, 972, 971, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 974, 1, 0,
		0, 0, 974, 976, 5, 81, 0, 0, 975, 977, 3, 640, 320, 0, 976, 975, 1, 0,
		0, 0, 976, 977, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 980, 3, 584, 292,
		0, 979, 981, 3, 82, 41, 0, 980, 979, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0,
		981, 982, 1, 0, 0, 0, 982, 983, 5, 118, 0, 0, 983, 984, 3, 556, 278, 0,
		984, 986, 3, 620, 310, 0, 985, 987, 3, 644, 322, 0, 986, 985, 1, 0, 0,
		0, 986, 987, 1, 0, 0, 0, 987, 991, 1, 0, 0, 0, 988, 990, 3, 84, 42, 0,
		989, 988, 1, 0, 0, 0, 990, 993, 1, 0, 0, 0, 991, 989, 1, 0, 0, 0, 991,
		992, 1, 0, 0, 0, 992, 1006, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0, 994, 996,
		5, 336, 0, 0, 995, 997, 5, 1145, 0, 0, 996, 995, 1, 0, 0, 0, 996, 997,
		1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 1005, 7, 3, 0, 0, 999, 1001, 5,
		103, 0, 0, 1000, 1002, 5, 1145, 0, 0, 1001, 1000, 1, 0, 0, 0, 1001, 1002,
		1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1005, 7, 4, 0, 0, 1004, 994,
		1, 0, 0, 0, 1004, 999, 1, 0, 0, 0, 1005, 1008, 1, 0, 0, 0, 1006, 1004,
		1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 31, 1, 0, 0, 0, 1008, 1006, 1,
		0, 0, 0, 1009, 1010, 5, 34, 0, 0, 1010, 1011, 5, 476, 0, 0, 1011, 1012,
		5, 73, 0, 0, 1012, 1013, 3, 584, 292, 0, 1013, 1014, 5, 5, 0, 0, 1014,
		1015, 5, 663, 0, 0, 1015, 1021, 5, 1169, 0, 0, 1016, 1018, 5, 453, 0, 0,
		1017, 1019, 5, 1145, 0, 0, 1018, 1017, 1, 0, 0, 0, 1018, 1019, 1, 0, 0,
		0, 1019, 1020, 1, 0, 0, 0, 1020, 1022, 3, 592, 296, 0, 1021, 1016, 1, 0,
		0, 0, 1021, 1022, 1, 0, 0, 0, 1022, 1028, 1, 0, 0, 0, 1023, 1025, 5, 664,
		0, 0, 1024, 1026, 5, 1145, 0, 0, 1025, 1024, 1, 0, 0, 0, 1025, 1026, 1,
		0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1029, 3, 592, 296, 0, 1028, 1023,
		1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1035, 1, 0, 0, 0, 1030, 1032,
		5, 574, 0, 0, 1031, 1033, 5, 1145, 0, 0, 1032, 1031, 1, 0, 0, 0, 1032,
		1033, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036, 3, 592, 296, 0, 1035,
		1030, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1042, 1, 0, 0, 0, 1037,
		1039, 5, 529, 0, 0, 1038, 1040, 5, 1145, 0, 0, 1039, 1038, 1, 0, 0, 0,
		1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1043, 3, 584, 292,
		0, 1042, 1037, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1045, 1, 0, 0,
		0, 1044, 1046, 5, 678, 0, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0,
		0, 0, 1046, 1052, 1, 0, 0, 0, 1047, 1049, 5, 368, 0, 0, 1048, 1050, 5,
		1145, 0, 0, 1049, 1048, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1051,
		1, 0, 0, 0, 1051, 1053, 5, 1169, 0, 0, 1052, 1047, 1, 0, 0, 0, 1052, 1053,
		1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1056, 5, 409, 0, 0, 1055, 1057,
		5, 1145, 0, 0, 1056, 1055, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 1058,
		1, 0, 0, 0, 1058, 1059, 3, 572, 286, 0, 1059, 33, 1, 0, 0, 0, 1060, 1062,
		5, 34, 0, 0, 1061, 1063, 3, 642, 321, 0, 1062, 1061, 1, 0, 0, 0, 1062,
		1063, 1, 0, 0, 0, 1063, 1065, 1, 0, 0, 0, 1064, 1066, 3, 70, 35, 0, 1065,
		1064, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067,
		1068, 5, 132, 0, 0, 1068, 1069, 3, 554, 277, 0, 1069, 1071, 5, 1154, 0,
		0, 1070, 1072, 3, 86, 43, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0,
		0, 0, 1072, 1077, 1, 0, 0, 0, 1073, 1074, 5, 1156, 0, 0, 1074, 1076, 3,
		86, 43, 0, 1075, 1073, 1, 0, 0, 0, 1076, 1079, 1, 0, 0, 0, 1077, 1075,
		1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1080, 1, 0, 0, 0, 1079, 1077,
		1, 0, 0, 0, 1080, 1084, 5, 1155, 0, 0, 1081, 1083, 3, 90, 45, 0, 1082,
		1081, 1, 0, 0, 0, 1083, 1086, 1, 0, 0, 0, 1084, 1082, 1, 0, 0, 0, 1084,
		1085, 1, 0, 0, 0, 1085, 1087, 1, 0, 0, 0, 1086, 1084, 1, 0, 0, 0, 1087,
		1088, 3, 394, 197, 0, 1088, 35, 1, 0, 0, 0, 1089, 1091, 5, 34, 0, 0, 1090,
		1092, 3, 642, 321, 0, 1091, 1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092,
		1094, 1, 0, 0, 0, 1093, 1095, 3, 70, 35, 0, 1094, 1093, 1, 0, 0, 0, 1094,
		1095, 1, 0, 0, 0, 1095, 1097, 1, 0, 0, 0, 1096, 1098, 5, 335, 0, 0, 1097,
		1096, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099,
		1101, 5, 437, 0, 0, 1100, 1102, 3, 640, 320, 0, 1101, 1100, 1, 0, 0, 0,
		1101, 1102, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1104, 3, 554, 277,
		0, 1104, 1106, 5, 1154, 0, 0, 1105, 1107, 3, 88, 44, 0, 1106, 1105, 1,
		0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 1112, 1, 0, 0, 0, 1108, 1109, 5,
		1156, 0, 0, 1109, 1111, 3, 88, 44, 0, 1110, 1108, 1, 0, 0, 0, 1111, 1114,
		1, 0, 0, 0, 1112, 1110, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0, 1113, 1115,
		1, 0, 0, 0, 1114, 1112, 1, 0, 0, 0, 1115, 1116, 5, 1155, 0, 0, 1116, 1117,
		5, 596, 0, 0, 1117, 1121, 3, 604, 302, 0, 1118, 1120, 3, 90, 45, 0, 1119,
		1118, 1, 0, 0, 0, 1120, 1123, 1, 0, 0, 0, 1121, 1119, 1, 0, 0, 0, 1121,
		1122, 1, 0, 0, 0, 1122, 1126, 1, 0, 0, 0, 1123, 1121, 1, 0, 0, 0, 1124,
		1127, 3, 394, 197, 0, 1125, 1127, 3, 410, 205, 0, 1126, 1124, 1, 0, 0,
		0, 1126, 1125, 1, 0, 0, 0, 1127, 37, 1, 0, 0, 0, 1128, 1129, 5, 34, 0,
		0, 1129, 1131, 5, 598, 0, 0, 1130, 1132, 3, 640, 320, 0, 1131, 1130, 1,
		0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1138, 3,
		558, 279, 0, 1134, 1135, 5, 1156, 0, 0, 1135, 1137, 3, 558, 279, 0, 1136,
		1134, 1, 0, 0, 0, 1137, 1140, 1, 0, 0, 0, 1138, 1136, 1, 0, 0, 0, 1138,
		1139, 1, 0, 0, 0, 1139, 39, 1, 0, 0, 0, 1140, 1138, 1, 0, 0, 0, 1141, 1142,
		5, 34, 0, 0, 1142, 1143, 5, 610, 0, 0, 1143, 1144, 3, 584, 292, 0, 1144,
		1145, 5, 67, 0, 0, 1145, 1146, 5, 388, 0, 0, 1146, 1147, 5, 683, 0, 0,
		1147, 1148, 7, 5, 0, 0, 1148, 1149, 5, 542, 0, 0, 1149, 1150, 5, 1154,
		0, 0, 1150, 1155, 3, 92, 46, 0, 1151, 1152, 5, 1156, 0, 0, 1152, 1154,
		3, 92, 46, 0, 1153, 1151, 1, 0, 0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153,
		1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 1158, 1, 0, 0, 0, 1157, 1155,
		1, 0, 0, 0, 1158, 1159, 5, 1155, 0, 0, 1159, 41, 1, 0, 0, 0, 1160, 1162,
		5, 34, 0, 0, 1161, 1163, 3, 642, 321, 0, 1162, 1161, 1, 0, 0, 0, 1162,
		1163, 1, 0, 0, 0, 1163, 1165, 1, 0, 0, 0, 1164, 1166, 5, 652, 0, 0, 1165,
		1164, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167,
		1169, 5, 172, 0, 0, 1168, 1170, 3, 640, 320, 0, 1169, 1168, 1, 0, 0, 0,
		1169, 1170, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1179, 3, 556, 278,
		0, 1172, 1173, 5, 98, 0, 0, 1173, 1180, 3, 556, 278, 0, 1174, 1175, 5,
		1154, 0, 0, 1175, 1176, 5, 98, 0, 0, 1176, 1177, 3, 556, 278, 0, 1177,
		1178, 5, 1155, 0, 0, 1178, 1180, 1, 0, 0, 0, 1179, 1172, 1, 0, 0, 0, 1179,
		1174, 1, 0, 0, 0, 1180, 1248, 1, 0, 0, 0, 1181, 1183, 5, 34, 0, 0, 1182,
		1184, 3, 642, 321, 0, 1183, 1182, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184,
		1186, 1, 0, 0, 0, 1185, 1187, 5, 652, 0, 0, 1186, 1185, 1, 0, 0, 0, 1186,
		1187, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1190, 5, 172, 0, 0, 1189,
		1191, 3, 640, 320, 0, 1190, 1189, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191,
		1192, 1, 0, 0, 0, 1192, 1194, 3, 556, 278, 0, 1193, 1195, 3, 94, 47, 0,
		1194, 1193, 1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1206, 1, 0, 0, 0,
		1196, 1203, 3, 112, 56, 0, 1197, 1199, 5, 1156, 0, 0, 1198, 1197, 1, 0,
		0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1200, 1, 0, 0, 0, 1200, 1202, 3, 112,
		56, 0, 1201, 1198, 1, 0, 0, 0, 1202, 1205, 1, 0, 0, 0, 1203, 1201, 1, 0,
		0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1207, 1, 0, 0, 0, 1205, 1203, 1, 0,
		0, 0, 1206, 1196, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1209, 1, 0,
		0, 0, 1208, 1210, 3, 118, 59, 0, 1209, 1208, 1, 0, 0, 0, 1209, 1210, 1,
		0, 0, 0, 1210, 1212, 1, 0, 0, 0, 1211, 1213, 7, 6, 0, 0, 1212, 1211, 1,
		0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 1215, 1, 0, 0, 0, 1214, 1216, 5,
		12, 0, 0, 1215, 1214, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1217, 1,
		0, 0, 0, 1217, 1218, 3, 208, 104, 0, 1218, 1248, 1, 0, 0, 0, 1219, 1221,
		5, 34, 0, 0, 1220, 1222, 3, 642, 321, 0, 1221, 1220, 1, 0, 0, 0, 1221,
		1222, 1, 0, 0, 0, 1222, 1224, 1, 0, 0, 0, 1223, 1225, 5, 652, 0, 0, 1224,
		1223, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226,
		1228, 5, 172, 0, 0, 1227, 1229, 3, 640, 320, 0, 1228, 1227, 1, 0, 0, 0,
		1228, 1229, 1, 0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1231, 3, 556, 278,
		0, 1231, 1242, 3, 94, 47, 0, 1232, 1239, 3, 112, 56, 0, 1233, 1235, 5,
		1156, 0, 0, 1234, 1233, 1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 1236,
		1, 0, 0, 0, 1236, 1238, 3, 112, 56, 0, 1237, 1234, 1, 0, 0, 0, 1238, 1241,
		1, 0, 0, 0, 1239, 1237, 1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1243,
		1, 0, 0, 0, 1241, 1239, 1, 0, 0, 0, 1242, 1232, 1, 0, 0, 0, 1242, 1243,
		1, 0, 0, 0, 1243, 1245, 1, 0, 0, 0, 1244, 1246, 3, 118, 59, 0, 1245, 1244,
		1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1248, 1, 0, 0, 0, 1247, 1160,
		1, 0, 0, 0, 1247, 1181, 1, 0, 0, 0, 1247, 1219, 1, 0, 0, 0, 1248, 43, 1,
		0, 0, 0, 1249, 1250, 5, 34, 0, 0, 1250, 1251, 5, 650, 0, 0, 1251, 1252,
		3, 584, 292, 0, 1252, 1253, 5, 5, 0, 0, 1253, 1254, 5, 389, 0, 0, 1254,
		1258, 5, 1169, 0, 0, 1255, 1256, 5, 428, 0, 0, 1256, 1257, 5, 1145, 0,
		0, 1257, 1259, 3, 592, 296, 0, 1258, 1255, 1, 0, 0, 0, 1258, 1259, 1, 0,
		0, 0, 1259, 1265, 1, 0, 0, 0, 1260, 1262, 5, 409, 0, 0, 1261, 1263, 5,
		1145, 0, 0, 1262, 1261, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1264,
		1, 0, 0, 0, 1264, 1266, 3, 572, 286, 0, 1265, 1260, 1, 0, 0, 0, 1265, 1266,
		1, 0, 0, 0, 1266, 45, 1, 0, 0, 0, 1267, 1268, 5, 34, 0, 0, 1268, 1269,
		5, 650, 0, 0, 1269, 1270, 3, 584, 292, 0, 1270, 1271, 5, 5, 0, 0, 1271,
		1272, 5, 389, 0, 0, 1272, 1273, 5, 1169, 0, 0, 1273, 1274, 5, 186, 0, 0,
		1274, 1275, 5, 476, 0, 0, 1275, 1276, 5, 73, 0, 0, 1276, 1282, 3, 584,
		292, 0, 1277, 1279, 5, 423, 0, 0, 1278, 1280, 5, 1145, 0, 0, 1279, 1278,
		1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 1283,
		3, 592, 296, 0, 1282, 1277, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1289,
		1, 0, 0, 0, 1284, 1286, 5, 453, 0, 0, 1285, 1287, 5, 1145, 0, 0, 1286,
		1285, 1, 0, 0, 0, 1286, 1287, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288,
		1290, 3, 592, 296, 0, 1289, 1284, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290,
		1296, 1, 0, 0, 0, 1291, 1293, 5, 341, 0, 0, 1292, 1294, 5, 1145, 0, 0,
		1293, 1292, 1, 0, 0, 0, 1293, 1294, 1, 0, 0, 0, 1294, 1295, 1, 0, 0, 0,
		1295, 1297, 3, 592, 296, 0, 1296, 1291, 1, 0, 0, 0, 1296, 1297, 1, 0, 0,
		0, 1297, 1303, 1, 0, 0, 0, 1298, 1300, 5, 502, 0, 0, 1299, 1301, 5, 1145,
		0, 0, 1300, 1299, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1302, 1, 0,
		0, 0, 1302, 1304, 3, 592, 296, 0, 1303, 1298, 1, 0, 0, 0, 1303, 1304, 1,
		0, 0, 0, 1304, 1310, 1, 0, 0, 0, 1305, 1307, 5, 529, 0, 0, 1306, 1308,
		5, 1145, 0, 0, 1307, 1306, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1309,
		1, 0, 0, 0, 1309, 1311, 3, 584, 292, 0, 1310, 1305, 1, 0, 0, 0, 1310, 1311,
		1, 0, 0, 0, 1311, 1313, 1, 0, 0, 0, 1312, 1314, 5, 678, 0, 0, 1313, 1312,
		1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 1320, 1, 0, 0, 0, 1315, 1317,
		5, 368, 0, 0, 1316, 1318, 5, 1145, 0, 0, 1317, 1316, 1, 0, 0, 0, 1317,
		1318, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1321, 5, 1169, 0, 0, 1320,
		1315, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322,
		1324, 5, 409, 0, 0, 1323, 1325, 5, 1145, 0, 0, 1324, 1323, 1, 0, 0, 0,
		1324, 1325, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1327, 3, 572, 286,
		0, 1327, 47, 1, 0, 0, 0, 1328, 1330, 5, 34, 0, 0, 1329, 1331, 3, 642, 321,
		0, 1330, 1329, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 1331, 1333, 1, 0, 0,
		0, 1332, 1334, 3, 70, 35, 0, 1333, 1332, 1, 0, 0, 0, 1333, 1334, 1, 0,
		0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1336, 5, 177, 0, 0, 1336, 1337, 3,
		554, 277, 0, 1337, 1338, 7, 7, 0, 0, 1338, 1339, 7, 8, 0, 0, 1339, 1340,
		5, 118, 0, 0, 1340, 1341, 3, 556, 278, 0, 1341, 1342, 5, 65, 0, 0, 1342,
		1343, 5, 53, 0, 0, 1343, 1346, 5, 602, 0, 0, 1344, 1345, 7, 9, 0, 0, 1345,
		1347, 3, 554, 277, 0, 1346, 1344, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347,
		1348, 1, 0, 0, 0, 1348, 1349, 3, 394, 197, 0, 1349, 49, 1, 0, 0, 0, 1350,
		1352, 5, 192, 0, 0, 1351, 1353, 5, 573, 0, 0, 1352, 1351, 1, 0, 0, 0, 1352,
		1353, 1, 0, 0, 0, 1353, 1354, 1, 0, 0, 0, 1354, 1355, 3, 52, 26, 0, 1355,
		51, 1, 0, 0, 0, 1356, 1368, 3, 54, 27, 0, 1357, 1358, 5, 1154, 0, 0, 1358,
		1363, 3, 56, 28, 0, 1359, 1360, 5, 1156, 0, 0, 1360, 1362, 3, 56, 28, 0,
		1361, 1359, 1, 0, 0, 0, 1362, 1365, 1, 0, 0, 0, 1363, 1361, 1, 0, 0, 0,
		1363, 1364, 1, 0, 0, 0, 1364, 1366, 1, 0, 0, 0, 1365, 1363, 1, 0, 0, 0,
		1366, 1367, 5, 1155, 0, 0, 1367, 1369, 1, 0, 0, 0, 1368, 1357, 1, 0, 0,
		0, 1368, 1369, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 1371, 5, 12, 0,
		0, 1371, 1372, 5, 1154, 0, 0, 1372, 1373, 3, 12, 6, 0, 1373, 1376, 5, 1155,
		0, 0, 1374, 1375, 5, 1156, 0, 0, 1375, 1377, 3, 52, 26, 0, 1376, 1374,
		1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 53, 1, 0, 0, 0, 1378, 1379, 3,
		584, 292, 0, 1379, 55, 1, 0, 0, 0, 1380, 1381, 3, 584, 292, 0, 1381, 57,
		1, 0, 0, 0, 1382, 1384, 5, 34, 0, 0, 1383, 1385, 3, 642, 321, 0, 1384,
		1383, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1389, 1, 0, 0, 0, 1386,
		1387, 5, 336, 0, 0, 1387, 1388, 5, 1145, 0, 0, 1388, 1390, 7, 10, 0, 0,
		1389, 1386, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1392, 1, 0, 0, 0,
		1391, 1393, 3, 70, 35, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0, 0,
		0, 1393, 1397, 1, 0, 0, 0, 1394, 1395, 5, 160, 0, 0, 1395, 1396, 5, 608,
		0, 0, 1396, 1398, 7, 11, 0, 0, 1397, 1394, 1, 0, 0, 0, 1397, 1398, 1, 0,
		0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1400, 5, 675, 0, 0, 1400, 1405, 3,
		554, 277, 0, 1401, 1402, 5, 1154, 0, 0, 1402, 1403, 3, 616, 308, 0, 1403,
		1404, 5, 1155, 0, 0, 1404, 1406, 1, 0, 0, 0, 1405, 1401, 1, 0, 0, 0, 1405,
		1406, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1427, 5, 12, 0, 0, 1408,
		1410, 5, 1154, 0, 0, 1409, 1411, 3, 50, 25, 0, 1410, 1409, 1, 0, 0, 0,
		1410, 1411, 1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1413, 3, 208, 104,
		0, 1413, 1414, 5, 1155, 0, 0, 1414, 1428, 1, 0, 0, 0, 1415, 1417, 3, 50,
		25, 0, 1416, 1415, 1, 0, 0, 0, 1416, 1417, 1, 0, 0, 0, 1417, 1418, 1, 0,
		0, 0, 1418, 1425, 3, 208, 104, 0, 1419, 1421, 5, 192, 0, 0, 1420, 1422,
		7, 12, 0, 0, 1421, 1420, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 1423,
		1, 0, 0, 0, 1423, 1424, 5, 27, 0, 0, 1424, 1426, 5, 120, 0, 0, 1425, 1419,
		1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426, 1428, 1, 0, 0, 0, 1427, 1408,
		1, 0, 0, 0, 1427, 1416, 1, 0, 0, 0, 1428, 59, 1, 0, 0, 0, 1429, 1431, 5,
		34, 0, 0, 1430, 1432, 3, 642, 321, 0, 1431, 1430, 1, 0, 0, 0, 1431, 1432,
		1, 0, 0, 0, 1432, 1434, 1, 0, 0, 0, 1433, 1435, 5, 652, 0, 0, 1434, 1433,
		1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1436, 1, 0, 0, 0, 1436, 1438,
		5, 609, 0, 0, 1437, 1439, 3, 640, 320, 0, 1438, 1437, 1, 0, 0, 0, 1438,
		1439, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1445, 3, 554, 277, 0, 1441,
		1444, 3, 62, 31, 0, 1442, 1444, 3, 112, 56, 0, 1443, 1441, 1, 0, 0, 0,
		1443, 1442, 1, 0, 0, 0, 1444, 1447, 1, 0, 0, 0, 1445, 1443, 1, 0, 0, 0,
		1445, 1446, 1, 0, 0, 0, 1446, 61, 1, 0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1448,
		1450, 5, 451, 0, 0, 1449, 1451, 7, 13, 0, 0, 1450, 1449, 1, 0, 0, 0, 1450,
		1451, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1488, 3, 590, 295, 0, 1453,
		1455, 5, 111, 0, 0, 1454, 1456, 5, 1145, 0, 0, 1455, 1454, 1, 0, 0, 0,
		1455, 1456, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1488, 3, 590, 295,
		0, 1458, 1459, 5, 522, 0, 0, 1459, 1488, 5, 111, 0, 0, 1460, 1488, 5, 527,
		0, 0, 1461, 1463, 5, 110, 0, 0, 1462, 1464, 5, 1145, 0, 0, 1463, 1462,
		1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1488,
		3, 590, 295, 0, 1466, 1467, 5, 522, 0, 0, 1467, 1488, 5, 110, 0, 0, 1468,
		1488, 5, 526, 0, 0, 1469, 1471, 5, 632, 0, 0, 1470, 1472, 7, 14, 0, 0,
		1471, 1470, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472, 1473, 1, 0, 0, 0,
		1473, 1488, 3, 590, 295, 0, 1474, 1476, 5, 351, 0, 0, 1475, 1477, 5, 1145,
		0, 0, 1476, 1475, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0,
		0, 0, 1478, 1488, 3, 590, 295, 0, 1479, 1488, 5, 523, 0, 0, 1480, 1488,
		5, 386, 0, 0, 1481, 1488, 5, 525, 0, 0, 1482, 1484, 5, 592, 0, 0, 1483,
		1485, 7, 14, 0, 0, 1484, 1483, 1, 0, 0, 0, 1484, 1485, 1, 0, 0, 0, 1485,
		1486, 1, 0, 0, 0, 1486, 1488, 3, 590, 295, 0, 1487, 1448, 1, 0, 0, 0, 1487,
		1453, 1, 0, 0, 0, 1487, 1458, 1, 0, 0, 0, 1487, 1460, 1, 0, 0, 0, 1487,
		1461, 1, 0, 0, 0, 1487, 1466, 1, 0, 0, 0, 1487, 1468, 1, 0, 0, 0, 1487,
		1469, 1, 0, 0, 0, 1487, 1474, 1, 0, 0, 0, 1487, 1479, 1, 0, 0, 0, 1487,
		1480, 1, 0, 0, 0, 1487, 1481, 1, 0, 0, 0, 1487, 1482, 1, 0, 0, 0, 1488,
		63, 1, 0, 0, 0, 1489, 1491, 5, 43, 0, 0, 1490, 1489, 1, 0, 0, 0, 1490,
		1491, 1, 0, 0, 0, 1491, 1492, 1, 0, 0, 0, 1492, 1494, 3, 66, 33, 0, 1493,
		1495, 5, 1145, 0, 0, 1494, 1493, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495,
		1498, 1, 0, 0, 0, 1496, 1499, 3, 568, 284, 0, 1497, 1499, 5, 43, 0, 0,
		1498, 1496, 1, 0, 0, 0, 1498, 1497, 1, 0, 0, 0, 1499, 1523, 1, 0, 0, 0,
		1500, 1502, 5, 43, 0, 0, 1501, 1500, 1, 0, 0, 0, 1501, 1502, 1, 0, 0, 0,
		1502, 1503, 1, 0, 0, 0, 1503, 1505, 5, 28, 0, 0, 1504, 1506, 5, 1145, 0,
		0, 1505, 1504, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1507, 1, 0, 0,
		0, 1507, 1523, 3, 570, 285, 0, 1508, 1510, 5, 43, 0, 0, 1509, 1508, 1,
		0, 0, 0, 1509, 1510, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1513, 5,
		405, 0, 0, 1512, 1514, 5, 1145, 0, 0, 1513, 1512, 1, 0, 0, 0, 1513, 1514,
		1, 0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515, 1523, 5, 1169, 0, 0, 1516, 1517,
		5, 135, 0, 0, 1517, 1519, 5, 539, 0, 0, 1518, 1520, 5, 1145, 0, 0, 1519,
		1518, 1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521,
		1523, 7, 15, 0, 0, 1522, 1490, 1, 0, 0, 0, 1522, 1501, 1, 0, 0, 0, 1522,
		1509, 1, 0, 0, 0, 1522, 1516, 1, 0, 0, 0, 1523, 65, 1, 0, 0, 0, 1524, 1525,
		5, 26, 0, 0, 1525, 1530, 5, 154, 0, 0, 1526, 1530, 5, 848, 0, 0, 1527,
		1528, 5, 222, 0, 0, 1528, 1530, 5, 154, 0, 0, 1529, 1524, 1, 0, 0, 0, 1529,
		1526, 1, 0, 0, 0, 1529, 1527, 1, 0, 0, 0, 1530, 67, 1, 0, 0, 0, 1531, 1534,
		5, 38, 0, 0, 1532, 1533, 5, 1154, 0, 0, 1533, 1535, 5, 1155, 0, 0, 1534,
		1532, 1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 69, 1, 0, 0, 0, 1536, 1537,
		5, 392, 0, 0, 1537, 1541, 5, 1145, 0, 0, 1538, 1542, 3, 564, 282, 0, 1539,
		1542, 3, 68, 34, 0, 1540, 1542, 5, 37, 0, 0, 1541, 1538, 1, 0, 0, 0, 1541,
		1539, 1, 0, 0, 0, 1541, 1540, 1, 0, 0, 0, 1542, 71, 1, 0, 0, 0, 1543, 1544,
		5, 338, 0, 0, 1544, 1548, 3, 74, 37, 0, 1545, 1547, 3, 76, 38, 0, 1546,
		1545, 1, 0, 0, 0, 1547, 1550, 1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1548,
		1549, 1, 0, 0, 0, 1549, 1578, 1, 0, 0, 0, 1550, 1548, 1, 0, 0, 0, 1551,
		1554, 5, 417, 0, 0, 1552, 1555, 3, 590, 295, 0, 1553, 1555, 3, 688, 344,
		0, 1554, 1552, 1, 0, 0, 0, 1554, 1553, 1, 0, 0, 0, 1555, 1556, 1, 0, 0,
		0, 1556, 1565, 3, 78, 39, 0, 1557, 1558, 5, 633, 0, 0, 1558, 1562, 3, 74,
		37, 0, 1559, 1561, 3, 76, 38, 0, 1560, 1559, 1, 0, 0, 0, 1561, 1564, 1,
		0, 0, 0, 1562, 1560, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1566, 1,
		0, 0, 0, 1564, 1562, 1, 0, 0, 0, 1565, 1557, 1, 0, 0, 0, 1565, 1566, 1,
		0, 0, 0, 1566, 1575, 1, 0, 0, 0, 1567, 1568, 5, 408, 0, 0, 1568, 1572,
		3, 74, 37, 0, 1569, 1571, 3, 76, 38, 0, 1570, 1569, 1, 0, 0, 0, 1571, 1574,
		1, 0, 0, 0, 1572, 1570, 1, 0, 0, 0, 1572, 1573, 1, 0, 0, 0, 1573, 1576,
		1, 0, 0, 0, 1574, 1572, 1, 0, 0, 0, 1575, 1567, 1, 0, 0, 0, 1575, 1576,
		1, 0, 0, 0, 1576, 1578, 1, 0, 0, 0, 1577, 1543, 1, 0, 0, 0, 1577, 1551,
		1, 0, 0, 0, 1578, 73, 1, 0, 0, 0, 1579, 1584, 5, 315, 0, 0, 1580, 1584,
		3, 594, 297, 0, 1581, 1584, 3, 590, 295, 0, 1582, 1584, 3, 688, 344, 0,
		1583, 1579, 1, 0, 0, 0, 1583, 1580, 1, 0, 0, 0, 1583, 1581, 1, 0, 0, 0,
		1583, 1582, 1, 0, 0, 0, 1584, 75, 1, 0, 0, 0, 1585, 1586, 5, 1141, 0, 0,
		1586, 1589, 5, 86, 0, 0, 1587, 1590, 3, 590, 295, 0, 1588, 1590, 3, 688,
		344, 0, 1589, 1587, 1, 0, 0, 0, 1589, 1588, 1, 0, 0, 0, 1590, 1591, 1,
		0, 0, 0, 1591, 1592, 3, 78, 39, 0, 1592, 77, 1, 0, 0, 0, 1593, 1607, 3,
		712, 356, 0, 1594, 1607, 5, 221, 0, 0, 1595, 1607, 5, 240, 0, 0, 1596,
		1607, 5, 241, 0, 0, 1597, 1607, 5, 242, 0, 0, 1598, 1607, 5, 243, 0, 0,
		1599, 1607, 5, 244, 0, 0, 1600, 1607, 5, 245, 0, 0, 1601, 1607, 5, 246,
		0, 0, 1602, 1607, 5, 247, 0, 0, 1603, 1607, 5, 248, 0, 0, 1604, 1607, 5,
		249, 0, 0, 1605, 1607, 5, 250, 0, 0, 1606, 1593, 1, 0, 0, 0, 1606, 1594,
		1, 0, 0, 0, 1606, 1595, 1, 0, 0, 0, 1606, 1596, 1, 0, 0, 0, 1606, 1597,
		1, 0, 0, 0, 1606, 1598, 1, 0, 0, 0, 1606, 1599, 1, 0, 0, 0, 1606, 1600,
		1, 0, 0, 0, 1606, 1601, 1, 0, 0, 0, 1606, 1602, 1, 0, 0, 0, 1606, 1603,
		1, 0, 0, 0, 1606, 1604, 1, 0, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607, 79, 1,
		0, 0, 0, 1608, 1614, 5, 403, 0, 0, 1609, 1614, 5, 396, 0, 0, 1610, 1611,
		5, 396, 0, 0, 1611, 1612, 5, 118, 0, 0, 1612, 1614, 5, 616, 0, 0, 1613,
		1608, 1, 0, 0, 0, 1613, 1609, 1, 0, 0, 0, 1613, 1610, 1, 0, 0, 0, 1614,
		81, 1, 0, 0, 0, 1615, 1616, 5, 187, 0, 0, 1616, 1617, 7, 16, 0, 0, 1617,
		83, 1, 0, 0, 0, 1618, 1620, 5, 467, 0, 0, 1619, 1621, 5, 1145, 0, 0, 1620,
		1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622,
		1649, 3, 592, 296, 0, 1623, 1649, 3, 82, 41, 0, 1624, 1625, 5, 192, 0,
		0, 1625, 1626, 5, 548, 0, 0, 1626, 1649, 3, 584, 292, 0, 1627, 1628, 5,
		368, 0, 0, 1628, 1649, 5, 1169, 0, 0, 1629, 1649, 7, 17, 0, 0, 1630, 1632,
		5, 882, 0, 0, 1631, 1633, 5, 1145, 0, 0, 1632, 1631, 1, 0, 0, 0, 1632,
		1633, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1649, 5, 1169, 0, 0, 1635,
		1637, 5, 1006, 0, 0, 1636, 1638, 5, 1145, 0, 0, 1637, 1636, 1, 0, 0, 0,
		1637, 1638, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 0, 1639, 1649, 5, 1169, 0,
		0, 1640, 1641, 5, 362, 0, 0, 1641, 1642, 5, 1145, 0, 0, 1642, 1649, 7,
		18, 0, 0, 1643, 1647, 5, 79, 0, 0, 1644, 1645, 5, 114, 0, 0, 1645, 1647,
		5, 79, 0, 0, 1646, 1643, 1, 0, 0, 0, 1646, 1644, 1, 0, 0, 0, 1647, 1649,
		1, 0, 0, 0, 1648, 1618, 1, 0, 0, 0, 1648, 1623, 1, 0, 0, 0, 1648, 1624,
		1, 0, 0, 0, 1648, 1627, 1, 0, 0, 0, 1648, 1629, 1, 0, 0, 0, 1648, 1630,
		1, 0, 0, 0, 1648, 1635, 1, 0, 0, 0, 1648, 1640, 1, 0, 0, 0, 1648, 1646,
		1, 0, 0, 0, 1649, 85, 1, 0, 0, 0, 1650, 1652, 7, 19, 0, 0, 1651, 1650,
		1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1654,
		3, 584, 292, 0, 1654, 1655, 3, 604, 302, 0, 1655, 87, 1, 0, 0, 0, 1656,
		1657, 3, 584, 292, 0, 1657, 1658, 3, 604, 302, 0, 1658, 89, 1, 0, 0, 0,
		1659, 1660, 5, 368, 0, 0, 1660, 1683, 5, 1169, 0, 0, 1661, 1662, 5, 468,
		0, 0, 1662, 1683, 5, 160, 0, 0, 1663, 1665, 5, 114, 0, 0, 1664, 1663, 1,
		0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1683, 5,
		48, 0, 0, 1667, 1668, 5, 381, 0, 0, 1668, 1678, 5, 160, 0, 0, 1669, 1670,
		5, 522, 0, 0, 1670, 1678, 5, 160, 0, 0, 1671, 1672, 5, 136, 0, 0, 1672,
		1673, 5, 160, 0, 0, 1673, 1678, 5, 388, 0, 0, 1674, 1675, 5, 112, 0, 0,
		1675, 1676, 5, 160, 0, 0, 1676, 1678, 5, 388, 0, 0, 1677, 1667, 1, 0, 0,
		0, 1677, 1669, 1, 0, 0, 0, 1677, 1671, 1, 0, 0, 0, 1677, 1674, 1, 0, 0,
		0, 1678, 1683, 1, 0, 0, 0, 1679, 1680, 5, 160, 0, 0, 1680, 1681, 5, 608,
		0, 0, 1681, 1683, 7, 11, 0, 0, 1682, 1659, 1, 0, 0, 0, 1682, 1661, 1, 0,
		0, 0, 1682, 1664, 1, 0, 0, 0, 1682, 1677, 1, 0, 0, 0, 1682, 1679, 1, 0,
		0, 0, 1683, 91, 1, 0, 0, 0, 1684, 1685, 5, 446, 0, 0, 1685, 1699, 5, 1169,
		0, 0, 1686, 1687, 5, 40, 0, 0, 1687, 1699, 5, 1169, 0, 0, 1688, 1689, 5,
		669, 0, 0, 1689, 1699, 5, 1169, 0, 0, 1690, 1691, 5, 552, 0, 0, 1691, 1699,
		5, 1169, 0, 0, 1692, 1693, 5, 620, 0, 0, 1693, 1699, 5, 1169, 0, 0, 1694,
		1695, 5, 543, 0, 0, 1695, 1699, 5, 1169, 0, 0, 1696, 1697, 5, 558, 0, 0,
		1697, 1699, 3, 590, 295, 0, 1698, 1684, 1, 0, 0, 0, 1698, 1686, 1, 0, 0,
		0, 1698, 1688, 1, 0, 0, 0, 1698, 1690, 1, 0, 0, 0, 1698, 1692, 1, 0, 0,
		0, 1698, 1694, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1699, 93, 1, 0, 0, 0,
		1700, 1701, 5, 1154, 0, 0, 1701, 1706, 3, 96, 48, 0, 1702, 1703, 5, 1156,
		0, 0, 1703, 1705, 3, 96, 48, 0, 1704, 1702, 1, 0, 0, 0, 1705, 1708, 1,
		0, 0, 0, 1706, 1704, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1709, 1,
		0, 0, 0, 1708, 1706, 1, 0, 0, 0, 1709, 1710, 5, 1155, 0, 0, 1710, 95, 1,
		0, 0, 0, 1711, 1712, 3, 584, 292, 0, 1712, 1713, 3, 98, 49, 0, 1713, 1717,
		1, 0, 0, 0, 1714, 1717, 3, 102, 51, 0, 1715, 1717, 3, 110, 55, 0, 1716,
		1711, 1, 0, 0, 0, 1716, 1714, 1, 0, 0, 0, 1716, 1715, 1, 0, 0, 0, 1717,
		97, 1, 0, 0, 0, 1718, 1722, 3, 604, 302, 0, 1719, 1721, 3, 100, 50, 0,
		1720, 1719, 1, 0, 0, 0, 1721, 1724, 1, 0, 0, 0, 1722, 1720, 1, 0, 0, 0,
		1722, 1723, 1, 0, 0, 0, 1723, 99, 1, 0, 0, 0, 1724, 1722, 1, 0, 0, 0, 1725,
		1779, 3, 600, 300, 0, 1726, 1727, 5, 43, 0, 0, 1727, 1779, 3, 632, 316,
		0, 1728, 1779, 5, 677, 0, 0, 1729, 1779, 5, 459, 0, 0, 1730, 1735, 5, 342,
		0, 0, 1731, 1732, 5, 118, 0, 0, 1732, 1733, 5, 184, 0, 0, 1733, 1735, 3,
		634, 317, 0, 1734, 1730, 1, 0, 0, 0, 1734, 1731, 1, 0, 0, 0, 1735, 1779,
		1, 0, 0, 0, 1736, 1738, 5, 130, 0, 0, 1737, 1736, 1, 0, 0, 0, 1737, 1738,
		1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1779, 5, 91, 0, 0, 1740, 1742,
		5, 181, 0, 0, 1741, 1743, 5, 91, 0, 0, 1742, 1741, 1, 0, 0, 0, 1742, 1743,
		1, 0, 0, 0, 1743, 1779, 1, 0, 0, 0, 1744, 1745, 5, 368, 0, 0, 1745, 1779,
		5, 1169, 0, 0, 1746, 1747, 5, 366, 0, 0, 1747, 1779, 7, 20, 0, 0, 1748,
		1749, 5, 639, 0, 0, 1749, 1779, 7, 21, 0, 0, 1750, 1779, 3, 104, 52, 0,
		1751, 1752, 5, 28, 0, 0, 1752, 1779, 3, 570, 285, 0, 1753, 1754, 5, 70,
		0, 0, 1754, 1756, 5, 8, 0, 0, 1755, 1753, 1, 0, 0, 0, 1755, 1756, 1, 0,
		0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 1758, 5, 12, 0, 0, 1758, 1759, 5, 1154,
		0, 0, 1759, 1760, 3, 688, 344, 0, 1760, 1762, 5, 1155, 0, 0, 1761, 1763,
		7, 22, 0, 0, 1762, 1761, 1, 0, 0, 0, 1762, 1763, 1, 0, 0, 0, 1763, 1779,
		1, 0, 0, 0, 1764, 1765, 5, 239, 0, 0, 1765, 1766, 5, 43, 0, 0, 1766, 1779,
		5, 673, 0, 0, 1767, 1769, 5, 31, 0, 0, 1768, 1770, 3, 584, 292, 0, 1769,
		1768, 1, 0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1770, 1772, 1, 0, 0, 0, 1771,
		1767, 1, 0, 0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773,
		1774, 5, 27, 0, 0, 1774, 1775, 5, 1154, 0, 0, 1775, 1776, 3, 688, 344,
		0, 1776, 1777, 5, 1155, 0, 0, 1777, 1779, 1, 0, 0, 0, 1778, 1725, 1, 0,
		0, 0, 1778, 1726, 1, 0, 0, 0, 1778, 1728, 1, 0, 0, 0, 1778, 1729, 1, 0,
		0, 0, 1778, 1734, 1, 0, 0, 0, 1778, 1737, 1, 0, 0, 0, 1778, 1740, 1, 0,
		0, 0, 1778, 1744, 1, 0, 0, 0, 1778, 1746, 1, 0, 0, 0, 1778, 1748, 1, 0,
		0, 0, 1778, 1750, 1, 0, 0, 0, 1778, 1751, 1, 0, 0, 0, 1778, 1755, 1, 0,
		0, 0, 1778, 1764, 1, 0, 0, 0, 1778, 1771, 1, 0, 0, 0, 1779, 101, 1, 0,
		0, 0, 1780, 1782, 5, 31, 0, 0, 1781, 1783, 3, 584, 292, 0, 1782, 1781,
		1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783, 1785, 1, 0, 0, 0, 1784, 1780,
		1, 0, 0, 0, 1784, 1785, 1, 0, 0, 0, 1785, 1786, 1, 0, 0, 0, 1786, 1787,
		5, 130, 0, 0, 1787, 1789, 5, 91, 0, 0, 1788, 1790, 3, 584, 292, 0, 1789,
		1788, 1, 0, 0, 0, 1789, 1790, 1, 0, 0, 0, 1790, 1792, 1, 0, 0, 0, 1791,
		1793, 3, 82, 41, 0, 1792, 1791, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793,
		1794, 1, 0, 0, 0, 1794, 1798, 3, 620, 310, 0, 1795, 1797, 3, 84, 42, 0,
		1796, 1795, 1, 0, 0, 0, 1797, 1800, 1, 0, 0, 0, 1798, 1796, 1, 0, 0, 0,
		1798, 1799, 1, 0, 0, 0, 1799, 1850, 1, 0, 0, 0, 1800, 1798, 1, 0, 0, 0,
		1801, 1803, 5, 31, 0, 0, 1802, 1804, 3, 584, 292, 0, 1803, 1802, 1, 0,
		0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1806, 1, 0, 0, 0, 1805, 1801, 1, 0,
		0, 0, 1805, 1806, 1, 0, 0, 0, 1806, 1807, 1, 0, 0, 0, 1807, 1809, 5, 181,
		0, 0, 1808, 1810, 7, 23, 0, 0, 1809, 1808, 1, 0, 0, 0, 1809, 1810, 1, 0,
		0, 0, 1810, 1812, 1, 0, 0, 0, 1811, 1813, 3, 584, 292, 0, 1812, 1811, 1,
		0, 0, 0, 1812, 1813, 1, 0, 0, 0, 1813, 1815, 1, 0, 0, 0, 1814, 1816, 3,
		82, 41, 0, 1815, 1814, 1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1816, 1817,
		1, 0, 0, 0, 1817, 1821, 3, 620, 310, 0, 1818, 1820, 3, 84, 42, 0, 1819,
		1818, 1, 0, 0, 0, 1820, 1823, 1, 0, 0, 0, 1821, 1819, 1, 0, 0, 0, 1821,
		1822, 1, 0, 0, 0, 1822, 1850, 1, 0, 0, 0, 1823, 1821, 1, 0, 0, 0, 1824,
		1826, 5, 31, 0, 0, 1825, 1827, 3, 584, 292, 0, 1826, 1825, 1, 0, 0, 0,
		1826, 1827, 1, 0, 0, 0, 1827, 1829, 1, 0, 0, 0, 1828, 1824, 1, 0, 0, 0,
		1828, 1829, 1, 0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830, 1831, 5, 67, 0, 0,
		1831, 1833, 5, 91, 0, 0, 1832, 1834, 3, 584, 292, 0, 1833, 1832, 1, 0,
		0, 0, 1833, 1834, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 1836, 3, 620,
		310, 0, 1836, 1837, 3, 104, 52, 0, 1837, 1850, 1, 0, 0, 0, 1838, 1840,
		5, 31, 0, 0, 1839, 1841, 3, 584, 292, 0, 1840, 1839, 1, 0, 0, 0, 1840,
		1841, 1, 0, 0, 0, 1841, 1843, 1, 0, 0, 0, 1842, 1838, 1, 0, 0, 0, 1842,
		1843, 1, 0, 0, 0, 1843, 1844, 1, 0, 0, 0, 1844, 1845, 5, 27, 0, 0, 1845,
		1846, 5, 1154, 0, 0, 1846, 1847, 3, 688, 344, 0, 1847, 1848, 5, 1155, 0,
		0, 1848, 1850, 1, 0, 0, 0, 1849, 1784, 1, 0, 0, 0, 1849, 1805, 1, 0, 0,
		0, 1849, 1828, 1, 0, 0, 0, 1849, 1842, 1, 0, 0, 0, 1850, 103, 1, 0, 0,
		0, 1851, 1852, 5, 137, 0, 0, 1852, 1854, 3, 556, 278, 0, 1853, 1855, 3,
		620, 310, 0, 1854, 1853, 1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 1858,
		1, 0, 0, 0, 1856, 1857, 5, 109, 0, 0, 1857, 1859, 7, 24, 0, 0, 1858, 1856,
		1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 1859, 1861, 1, 0, 0, 0, 1860, 1862,
		3, 106, 53, 0, 1861, 1860, 1, 0, 0, 0, 1861, 1862, 1, 0, 0, 0, 1862, 105,
		1, 0, 0, 0, 1863, 1864, 5, 118, 0, 0, 1864, 1865, 5, 45, 0, 0, 1865, 1869,
		3, 108, 54, 0, 1866, 1867, 5, 118, 0, 0, 1867, 1868, 5, 184, 0, 0, 1868,
		1870, 3, 108, 54, 0, 1869, 1866, 1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870,
		1880, 1, 0, 0, 0, 1871, 1872, 5, 118, 0, 0, 1872, 1873, 5, 184, 0, 0, 1873,
		1877, 3, 108, 54, 0, 1874, 1875, 5, 118, 0, 0, 1875, 1876, 5, 45, 0, 0,
		1876, 1878, 3, 108, 54, 0, 1877, 1874, 1, 0, 0, 0, 1877, 1878, 1, 0, 0,
		0, 1878, 1880, 1, 0, 0, 0, 1879, 1863, 1, 0, 0, 0, 1879, 1871, 1, 0, 0,
		0, 1880, 107, 1, 0, 0, 0, 1881, 1888, 5, 145, 0, 0, 1882, 1888, 5, 22,
		0, 0, 1883, 1884, 5, 154, 0, 0, 1884, 1888, 5, 116, 0, 0, 1885, 1886, 5,
		522, 0, 0, 1886, 1888, 5, 333, 0, 0, 1887, 1881, 1, 0, 0, 0, 1887, 1882,
		1, 0, 0, 0, 1887, 1883, 1, 0, 0, 0, 1887, 1885, 1, 0, 0, 0, 1888, 109,
		1, 0, 0, 0, 1889, 1891, 7, 23, 0, 0, 1890, 1892, 3, 584, 292, 0, 1891,
		1890, 1, 0, 0, 0, 1891, 1892, 1, 0, 0, 0, 1892, 1894, 1, 0, 0, 0, 1893,
		1895, 3, 82, 41, 0, 1894, 1893, 1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895,
		1896, 1, 0, 0, 0, 1896, 1900, 3, 620, 310, 0, 1897, 1899, 3, 84, 42, 0,
		1898, 1897, 1, 0, 0, 0, 1899, 1902, 1, 0, 0, 0, 1900, 1898, 1, 0, 0, 0,
		1900, 1901, 1, 0, 0, 0, 1901, 1918, 1, 0, 0, 0, 1902, 1900, 1, 0, 0, 0,
		1903, 1905, 7, 25, 0, 0, 1904, 1906, 7, 23, 0, 0, 1905, 1904, 1, 0, 0,
		0, 1905, 1906, 1, 0, 0, 0, 1906, 1908, 1, 0, 0, 0, 1907, 1909, 3, 584,
		292, 0, 1908, 1907, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1910, 1,
		0, 0, 0, 1910, 1914, 3, 620, 310, 0, 1911, 1913, 3, 84, 42, 0, 1912, 1911,
		1, 0, 0, 0, 1913, 1916, 1, 0, 0, 0, 1914, 1912, 1, 0, 0, 0, 1914, 1915,
		1, 0, 0, 0, 1915, 1918, 1, 0, 0, 0, 1916, 1914, 1, 0, 0, 0, 1917, 1889,
		1, 0, 0, 0, 1917, 1903, 1, 0, 0, 0, 1918, 111, 1, 0, 0, 0, 1919, 1921,
		5, 409, 0, 0, 1920, 1922, 5, 1145, 0, 0, 1921, 1920, 1, 0, 0, 0, 1921,
		1922, 1, 0, 0, 0, 1922, 1924, 1, 0, 0, 0, 1923, 1925, 3, 572, 286, 0, 1924,
		1923, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 2111, 1, 0, 0, 0, 1926,
		1928, 5, 882, 0, 0, 1927, 1929, 5, 1145, 0, 0, 1928, 1927, 1, 0, 0, 0,
		1928, 1929, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 2111, 5, 1169, 0,
		0, 1931, 1933, 5, 341, 0, 0, 1932, 1934, 5, 1145, 0, 0, 1933, 1932, 1,
		0, 0, 0, 1933, 1934, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935, 2111, 3,
		590, 295, 0, 1936, 1938, 5, 342, 0, 0, 1937, 1939, 5, 1145, 0, 0, 1938,
		1937, 1, 0, 0, 0, 1938, 1939, 1, 0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940,
		2111, 3, 590, 295, 0, 1941, 1943, 5, 343, 0, 0, 1942, 1944, 5, 1145, 0,
		0, 1943, 1942, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945, 1, 0, 0,
		0, 1945, 2111, 3, 590, 295, 0, 1946, 1948, 5, 43, 0, 0, 1947, 1946, 1,
		0, 0, 0, 1947, 1948, 1, 0, 0, 0, 1948, 1949, 1, 0, 0, 0, 1949, 1951, 3,
		66, 33, 0, 1950, 1952, 5, 1145, 0, 0, 1951, 1950, 1, 0, 0, 0, 1951, 1952,
		1, 0, 0, 0, 1952, 1955, 1, 0, 0, 0, 1953, 1956, 3, 568, 284, 0, 1954, 1956,
		5, 43, 0, 0, 1955, 1953, 1, 0, 0, 0, 1955, 1954, 1, 0, 0, 0, 1956, 2111,
		1, 0, 0, 0, 1957, 1959, 7, 26, 0, 0, 1958, 1960, 5, 1145, 0, 0, 1959, 1958,
		1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 2111,
		7, 27, 0, 0, 1962, 1964, 5, 43, 0, 0, 1963, 1962, 1, 0, 0, 0, 1963, 1964,
		1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965, 1967, 5, 28, 0, 0, 1966, 1968,
		5, 1145, 0, 0, 1967, 1966, 1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0, 1968, 1969,
		1, 0, 0, 0, 1969, 2111, 3, 570, 285, 0, 1970, 1972, 5, 368, 0, 0, 1971,
		1973, 5, 1145, 0, 0, 1972, 1971, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973,
		1974, 1, 0, 0, 0, 1974, 2111, 5, 1169, 0, 0, 1975, 1977, 5, 373, 0, 0,
		1976, 1978, 5, 1145, 0, 0, 1977, 1976, 1, 0, 0, 0, 1977, 1978, 1, 0, 0,
		0, 1978, 1979, 1, 0, 0, 0, 1979, 2111, 7, 28, 0, 0, 1980, 1982, 5, 376,
		0, 0, 1981, 1983, 5, 1145, 0, 0, 1982, 1981, 1, 0, 0, 0, 1982, 1983, 1,
		0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 2111, 5, 1169, 0, 0, 1985, 1986,
		7, 29, 0, 0, 1986, 1988, 5, 395, 0, 0, 1987, 1989, 5, 1145, 0, 0, 1988,
		1987, 1, 0, 0, 0, 1988, 1989, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990,
		2111, 5, 1169, 0, 0, 1991, 1993, 5, 393, 0, 0, 1992, 1994, 5, 1145, 0,
		0, 1993, 1992, 1, 0, 0, 0, 1993, 1994, 1, 0, 0, 0, 1994, 1995, 1, 0, 0,
		0, 1995, 2111, 7, 27, 0, 0, 1996, 1998, 5, 405, 0, 0, 1997, 1999, 5, 1145,
		0, 0, 1998, 1997, 1, 0, 0, 0, 1998, 1999, 1, 0, 0, 0, 1999, 2000, 1, 0,
		0, 0, 2000, 2111, 5, 1169, 0, 0, 2001, 2003, 3, 574, 287, 0, 2002, 2004,
		5, 1145, 0, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 2005,
		1, 0, 0, 0, 2005, 2006, 7, 18, 0, 0, 2006, 2111, 1, 0, 0, 0, 2007, 2009,
		7, 30, 0, 0, 2008, 2010, 5, 1145, 0, 0, 2009, 2008, 1, 0, 0, 0, 2009, 2010,
		1, 0, 0, 0, 2010, 2011, 1, 0, 0, 0, 2011, 2111, 7, 27, 0, 0, 2012, 2014,
		7, 31, 0, 0, 2013, 2015, 5, 1145, 0, 0, 2014, 2013, 1, 0, 0, 0, 2014, 2015,
		1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2111, 3, 590, 295, 0, 2017, 2019,
		5, 406, 0, 0, 2018, 2020, 5, 1145, 0, 0, 2019, 2018, 1, 0, 0, 0, 2019,
		2020, 1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2111, 3, 590, 295, 0, 2022,
		2023, 5, 81, 0, 0, 2023, 2025, 5, 395, 0, 0, 2024, 2026, 5, 1145, 0, 0,
		2025, 2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0,
		2027, 2111, 5, 1169, 0, 0, 2028, 2030, 5, 455, 0, 0, 2029, 2031, 5, 1145,
		0, 0, 2030, 2029, 1, 0, 0, 0, 2030, 2031, 1, 0, 0, 0, 2031, 2032, 1, 0,
		0, 0, 2032, 2111, 7, 32, 0, 0, 2033, 2035, 5, 467, 0, 0, 2034, 2036, 5,
		1145, 0, 0, 2035, 2034, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2037,
		1, 0, 0, 0, 2037, 2111, 3, 592, 296, 0, 2038, 2040, 5, 501, 0, 0, 2039,
		2041, 5, 1145, 0, 0, 2040, 2039, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041,
		2042, 1, 0, 0, 0, 2042, 2111, 3, 590, 295, 0, 2043, 2045, 5, 511, 0, 0,
		2044, 2046, 5, 1145, 0, 0, 2045, 2044, 1, 0, 0, 0, 2045, 2046, 1, 0, 0,
		0, 2046, 2047, 1, 0, 0, 0, 2047, 2111, 3, 590, 295, 0, 2048, 2050, 5, 544,
		0, 0, 2049, 2051, 5, 1145, 0, 0, 2050, 2049, 1, 0, 0, 0, 2050, 2051, 1,
		0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2111, 7, 15, 0, 0, 2053, 2055, 5,
		552, 0, 0, 2054, 2056, 5, 1145, 0, 0, 2055, 2054, 1, 0, 0, 0, 2055, 2056,
		1, 0, 0, 0, 2056, 2057, 1, 0, 0, 0, 2057, 2111, 5, 1169, 0, 0, 2058, 2060,
		5, 604, 0, 0, 2059, 2061, 5, 1145, 0, 0, 2060, 2059, 1, 0, 0, 0, 2060,
		2061, 1, 0, 0, 0, 2061, 2062, 1, 0, 0, 0, 2062, 2111, 7, 33, 0, 0, 2063,
		2064, 5, 632, 0, 0, 2064, 2111, 5, 656, 0, 0, 2065, 2067, 5, 1006, 0, 0,
		2066, 2068, 5, 1145, 0, 0, 2067, 2066, 1, 0, 0, 0, 2067, 2068, 1, 0, 0,
		0, 2068, 2069, 1, 0, 0, 0, 2069, 2111, 5, 1169, 0, 0, 2070, 2072, 5, 634,
		0, 0, 2071, 2073, 5, 1145, 0, 0, 2072, 2071, 1, 0, 0, 0, 2072, 2073, 1,
		0, 0, 0, 2073, 2074, 1, 0, 0, 0, 2074, 2111, 7, 15, 0, 0, 2075, 2077, 5,
		635, 0, 0, 2076, 2078, 5, 1145, 0, 0, 2077, 2076, 1, 0, 0, 0, 2077, 2078,
		1, 0, 0, 0, 2078, 2079, 1, 0, 0, 0, 2079, 2111, 7, 15, 0, 0, 2080, 2082,
		5, 636, 0, 0, 2081, 2083, 5, 1145, 0, 0, 2082, 2081, 1, 0, 0, 0, 2082,
		2083, 1, 0, 0, 0, 2083, 2086, 1, 0, 0, 0, 2084, 2087, 5, 43, 0, 0, 2085,
		2087, 3, 590, 295, 0, 2086, 2084, 1, 0, 0, 0, 2086, 2085, 1, 0, 0, 0, 2087,
		2111, 1, 0, 0, 0, 2088, 2089, 5, 650, 0, 0, 2089, 2091, 3, 584, 292, 0,
		2090, 2092, 3, 116, 58, 0, 2091, 2090, 1, 0, 0, 0, 2091, 2092, 1, 0, 0,
		0, 2092, 2111, 1, 0, 0, 0, 2093, 2094, 5, 651, 0, 0, 2094, 2095, 5, 1145,
		0, 0, 2095, 2111, 3, 114, 57, 0, 2096, 2111, 3, 116, 58, 0, 2097, 2099,
		5, 657, 0, 0, 2098, 2100, 5, 1145, 0, 0, 2099, 2098, 1, 0, 0, 0, 2099,
		2100, 1, 0, 0, 0, 2100, 2101, 1, 0, 0, 0, 2101, 2111, 7, 27, 0, 0, 2102,
		2104, 5, 180, 0, 0, 2103, 2105, 5, 1145, 0, 0, 2104, 2103, 1, 0, 0, 0,
		2104, 2105, 1, 0, 0, 0, 2105, 2106, 1, 0, 0, 0, 2106, 2107, 5, 1154, 0,
		0, 2107, 2108, 3, 618, 309, 0, 2108, 2109, 5, 1155, 0, 0, 2109, 2111, 1,
		0, 0, 0, 2110, 1919, 1, 0, 0, 0, 2110, 1926, 1, 0, 0, 0, 2110, 1931, 1,
		0, 0, 0, 2110, 1936, 1, 0, 0, 0, 2110, 1941, 1, 0, 0, 0, 2110, 1947, 1,
		0, 0, 0, 2110, 1957, 1, 0, 0, 0, 2110, 1963, 1, 0, 0, 0, 2110, 1970, 1,
		0, 0, 0, 2110, 1975, 1, 0, 0, 0, 2110, 1980, 1, 0, 0, 0, 2110, 1985, 1,
		0, 0, 0, 2110, 1991, 1, 0, 0, 0, 2110, 1996, 1, 0, 0, 0, 2110, 2001, 1,
		0, 0, 0, 2110, 2007, 1, 0, 0, 0, 2110, 2012, 1, 0, 0, 0, 2110, 2017, 1,
		0, 0, 0, 2110, 2022, 1, 0, 0, 0, 2110, 2028, 1, 0, 0, 0, 2110, 2033, 1,
		0, 0, 0, 2110, 2038, 1, 0, 0, 0, 2110, 2043, 1, 0, 0, 0, 2110, 2048, 1,
		0, 0, 0, 2110, 2053, 1, 0, 0, 0, 2110, 2058, 1, 0, 0, 0, 2110, 2063, 1,
		0, 0, 0, 2110, 2065, 1, 0, 0, 0, 2110, 2070, 1, 0, 0, 0, 2110, 2075, 1,
		0, 0, 0, 2110, 2080, 1, 0, 0, 0, 2110, 2088, 1, 0, 0, 0, 2110, 2093, 1,
		0, 0, 0, 2110, 2096, 1, 0, 0, 0, 2110, 2097, 1, 0, 0, 0, 2110, 2102, 1,
		0, 0, 0, 2111, 113, 1, 0, 0, 0, 2112, 2113, 7, 34, 0, 0, 2113, 115, 1,
		0, 0, 0, 2114, 2115, 5, 639, 0, 0, 2115, 2116, 7, 21, 0, 0, 2116, 117,
		1, 0, 0, 0, 2117, 2118, 5, 129, 0, 0, 2118, 2119, 5, 20, 0, 0, 2119, 2122,
		3, 120, 60, 0, 2120, 2121, 5, 551, 0, 0, 2121, 2123, 3, 590, 295, 0, 2122,
		2120, 1, 0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2131, 1, 0, 0, 0, 2124,
		2125, 5, 644, 0, 0, 2125, 2126, 5, 20, 0, 0, 2126, 2129, 3, 122, 61, 0,
		2127, 2128, 5, 645, 0, 0, 2128, 2130, 3, 590, 295, 0, 2129, 2127, 1, 0,
		0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 2132, 1, 0, 0, 0, 2131, 2124, 1, 0,
		0, 0, 2131, 2132, 1, 0, 0, 0, 2132, 2144, 1, 0, 0, 0, 2133, 2134, 5, 1154,
		0, 0, 2134, 2139, 3, 124, 62, 0, 2135, 2136, 5, 1156, 0, 0, 2136, 2138,
		3, 124, 62, 0, 2137, 2135, 1, 0, 0, 0, 2138, 2141, 1, 0, 0, 0, 2139, 2137,
		1, 0, 0, 0, 2139, 2140, 1, 0, 0, 0, 2140, 2142, 1, 0, 0, 0, 2141, 2139,
		1, 0, 0, 0, 2142, 2143, 5, 1155, 0, 0, 2143, 2145, 1, 0, 0, 0, 2144, 2133,
		1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 119, 1, 0, 0, 0, 2146, 2148,
		5, 100, 0, 0, 2147, 2146, 1, 0, 0, 0, 2147, 2148, 1, 0, 0, 0, 2148, 2149,
		1, 0, 0, 0, 2149, 2150, 5, 443, 0, 0, 2150, 2151, 5, 1154, 0, 0, 2151,
		2152, 3, 688, 344, 0, 2152, 2153, 5, 1155, 0, 0, 2153, 2192, 1, 0, 0, 0,
		2154, 2156, 5, 100, 0, 0, 2155, 2154, 1, 0, 0, 0, 2155, 2156, 1, 0, 0,
		0, 2156, 2157, 1, 0, 0, 0, 2157, 2161, 5, 91, 0, 0, 2158, 2159, 5, 336,
		0, 0, 2159, 2160, 5, 1145, 0, 0, 2160, 2162, 7, 35, 0, 0, 2161, 2158, 1,
		0, 0, 0, 2161, 2162, 1, 0, 0, 0, 2162, 2163, 1, 0, 0, 0, 2163, 2164, 5,
		1154, 0, 0, 2164, 2165, 3, 616, 308, 0, 2165, 2166, 5, 1155, 0, 0, 2166,
		2192, 1, 0, 0, 0, 2167, 2177, 5, 134, 0, 0, 2168, 2169, 5, 1154, 0, 0,
		2169, 2170, 3, 688, 344, 0, 2170, 2171, 5, 1155, 0, 0, 2171, 2178, 1, 0,
		0, 0, 2172, 2173, 5, 365, 0, 0, 2173, 2174, 5, 1154, 0, 0, 2174, 2175,
		3, 616, 308, 0, 2175, 2176, 5, 1155, 0, 0, 2176, 2178, 1, 0, 0, 0, 2177,
		2168, 1, 0, 0, 0, 2177, 2172, 1, 0, 0, 0, 2178, 2192, 1, 0, 0, 0, 2179,
		2189, 5, 473, 0, 0, 2180, 2181, 5, 1154, 0, 0, 2181, 2182, 3, 688, 344,
		0, 2182, 2183, 5, 1155, 0, 0, 2183, 2190, 1, 0, 0, 0, 2184, 2185, 5, 365,
		0, 0, 2185, 2186, 5, 1154, 0, 0, 2186, 2187, 3, 616, 308, 0, 2187, 2188,
		5, 1155, 0, 0, 2188, 2190, 1, 0, 0, 0, 2189, 2180, 1, 0, 0, 0, 2189, 2184,
		1, 0, 0, 0, 2190, 2192, 1, 0, 0, 0, 2191, 2147, 1, 0, 0, 0, 2191, 2155,
		1, 0, 0, 0, 2191, 2167, 1, 0, 0, 0, 2191, 2179, 1, 0, 0, 0, 2192, 121,
		1, 0, 0, 0, 2193, 2195, 5, 100, 0, 0, 2194, 2193, 1, 0, 0, 0, 2194, 2195,
		1, 0, 0, 0, 2195, 2196, 1, 0, 0, 0, 2196, 2197, 5, 443, 0, 0, 2197, 2198,
		5, 1154, 0, 0, 2198, 2199, 3, 688, 344, 0, 2199, 2200, 5, 1155, 0, 0, 2200,
		2215, 1, 0, 0, 0, 2201, 2203, 5, 100, 0, 0, 2202, 2201, 1, 0, 0, 0, 2202,
		2203, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2208, 5, 91, 0, 0, 2205,
		2206, 5, 336, 0, 0, 2206, 2207, 5, 1145, 0, 0, 2207, 2209, 7, 35, 0, 0,
		2208, 2205, 1, 0, 0, 0, 2208, 2209, 1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0,
		2210, 2211, 5, 1154, 0, 0, 2211, 2212, 3, 616, 308, 0, 2212, 2213, 5, 1155,
		0, 0, 2213, 2215, 1, 0, 0, 0, 2214, 2194, 1, 0, 0, 0, 2214, 2202, 1, 0,
		0, 0, 2215, 123, 1, 0, 0, 0, 2216, 2217, 5, 129, 0, 0, 2217, 2218, 3, 584,
		292, 0, 2218, 2219, 5, 188, 0, 0, 2219, 2220, 5, 471, 0, 0, 2220, 2221,
		5, 654, 0, 0, 2221, 2222, 5, 1154, 0, 0, 2222, 2227, 3, 126, 63, 0, 2223,
		2224, 5, 1156, 0, 0, 2224, 2226, 3, 126, 63, 0, 2225, 2223, 1, 0, 0, 0,
		2226, 2229, 1, 0, 0, 0, 2227, 2225, 1, 0, 0, 0, 2227, 2228, 1, 0, 0, 0,
		2228, 2230, 1, 0, 0, 0, 2229, 2227, 1, 0, 0, 0, 2230, 2234, 5, 1155, 0,
		0, 2231, 2233, 3, 132, 66, 0, 2232, 2231, 1, 0, 0, 0, 2233, 2236, 1, 0,
		0, 0, 2234, 2232, 1, 0, 0, 0, 2234, 2235, 1, 0, 0, 0, 2235, 2248, 1, 0,
		0, 0, 2236, 2234, 1, 0, 0, 0, 2237, 2238, 5, 1154, 0, 0, 2238, 2243, 3,
		130, 65, 0, 2239, 2240, 5, 1156, 0, 0, 2240, 2242, 3, 130, 65, 0, 2241,
		2239, 1, 0, 0, 0, 2242, 2245, 1, 0, 0, 0, 2243, 2241, 1, 0, 0, 0, 2243,
		2244, 1, 0, 0, 0, 2244, 2246, 1, 0, 0, 0, 2245, 2243, 1, 0, 0, 0, 2246,
		2247, 5, 1155, 0, 0, 2247, 2249, 1, 0, 0, 0, 2248, 2237, 1, 0, 0, 0, 2248,
		2249, 1, 0, 0, 0, 2249, 2363, 1, 0, 0, 0, 2250, 2251, 5, 129, 0, 0, 2251,
		2252, 3, 584, 292, 0, 2252, 2253, 5, 188, 0, 0, 2253, 2254, 5, 471, 0,
		0, 2254, 2255, 5, 654, 0, 0, 2255, 2259, 3, 126, 63, 0, 2256, 2258, 3,
		132, 66, 0, 2257, 2256, 1, 0, 0, 0, 2258, 2261, 1, 0, 0, 0, 2259, 2257,
		1, 0, 0, 0, 2259, 2260, 1, 0, 0, 0, 2260, 2273, 1, 0, 0, 0, 2261, 2259,
		1, 0, 0, 0, 2262, 2263, 5, 1154, 0, 0, 2263, 2268, 3, 130, 65, 0, 2264,
		2265, 5, 1156, 0, 0, 2265, 2267, 3, 130, 65, 0, 2266, 2264, 1, 0, 0, 0,
		2267, 2270, 1, 0, 0, 0, 2268, 2266, 1, 0, 0, 0, 2268, 2269, 1, 0, 0, 0,
		2269, 2271, 1, 0, 0, 0, 2270, 2268, 1, 0, 0, 0, 2271, 2272, 5, 1155, 0,
		0, 2272, 2274, 1, 0, 0, 0, 2273, 2262, 1, 0, 0, 0, 2273, 2274, 1, 0, 0,
		0, 2274, 2363, 1, 0, 0, 0, 2275, 2276, 5, 129, 0, 0, 2276, 2277, 3, 584,
		292, 0, 2277, 2278, 5, 188, 0, 0, 2278, 2279, 5, 80, 0, 0, 2279, 2280,
		5, 1154, 0, 0, 2280, 2285, 3, 126, 63, 0, 2281, 2282, 5, 1156, 0, 0, 2282,
		2284, 3, 126, 63, 0, 2283, 2281, 1, 0, 0, 0, 2284, 2287, 1, 0, 0, 0, 2285,
		2283, 1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2288, 1, 0, 0, 0, 2287,
		2285, 1, 0, 0, 0, 2288, 2292, 5, 1155, 0, 0, 2289, 2291, 3, 132, 66, 0,
		2290, 2289, 1, 0, 0, 0, 2291, 2294, 1, 0, 0, 0, 2292, 2290, 1, 0, 0, 0,
		2292, 2293, 1, 0, 0, 0, 2293, 2306, 1, 0, 0, 0, 2294, 2292, 1, 0, 0, 0,
		2295, 2296, 5, 1154, 0, 0, 2296, 2301, 3, 130, 65, 0, 2297, 2298, 5, 1156,
		0, 0, 2298, 2300, 3, 130, 65, 0, 2299, 2297, 1, 0, 0, 0, 2300, 2303, 1,
		0, 0, 0, 2301, 2299, 1, 0, 0, 0, 2301, 2302, 1, 0, 0, 0, 2302, 2304, 1,
		0, 0, 0, 2303, 2301, 1, 0, 0, 0, 2304, 2305, 5, 1155, 0, 0, 2305, 2307,
		1, 0, 0, 0, 2306, 2295, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 2307, 2363,
		1, 0, 0, 0, 2308, 2309, 5, 129, 0, 0, 2309, 2310, 3, 584, 292, 0, 2310,
		2311, 5, 188, 0, 0, 2311, 2312, 5, 80, 0, 0, 2312, 2313, 5, 1154, 0, 0,
		2313, 2318, 3, 128, 64, 0, 2314, 2315, 5, 1156, 0, 0, 2315, 2317, 3, 128,
		64, 0, 2316, 2314, 1, 0, 0, 0, 2317, 2320, 1, 0, 0, 0, 2318, 2316, 1, 0,
		0, 0, 2318, 2319, 1, 0, 0, 0, 2319, 2321, 1, 0, 0, 0, 2320, 2318, 1, 0,
		0, 0, 2321, 2325, 5, 1155, 0, 0, 2322, 2324, 3, 132, 66, 0, 2323, 2322,
		1, 0, 0, 0, 2324, 2327, 1, 0, 0, 0, 2325, 2323, 1, 0, 0, 0, 2325, 2326,
		1, 0, 0, 0, 2326, 2339, 1, 0, 0, 0, 2327, 2325, 1, 0, 0, 0, 2328, 2329,
		5, 1154, 0, 0, 2329, 2334, 3, 130, 65, 0, 2330, 2331, 5, 1156, 0, 0, 2331,
		2333, 3, 130, 65, 0, 2332, 2330, 1, 0, 0, 0, 2333, 2336, 1, 0, 0, 0, 2334,
		2332, 1, 0, 0, 0, 2334, 2335, 1, 0, 0, 0, 2335, 2337, 1, 0, 0, 0, 2336,
		2334, 1, 0, 0, 0, 2337, 2338, 5, 1155, 0, 0, 2338, 2340, 1, 0, 0, 0, 2339,
		2328, 1, 0, 0, 0, 2339, 2340, 1, 0, 0, 0, 2340, 2363, 1, 0, 0, 0, 2341,
		2342, 5, 129, 0, 0, 2342, 2346, 3, 584, 292, 0, 2343, 2345, 3, 132, 66,
		0, 2344, 2343, 1, 0, 0, 0, 2345, 2348, 1, 0, 0, 0, 2346, 2344, 1, 0, 0,
		0, 2346, 2347, 1, 0, 0, 0, 2347, 2360, 1, 0, 0, 0, 2348, 2346, 1, 0, 0,
		0, 2349, 2350, 5, 1154, 0, 0, 2350, 2355, 3, 130, 65, 0, 2351, 2352, 5,
		1156, 0, 0, 2352, 2354, 3, 130, 65, 0, 2353, 2351, 1, 0, 0, 0, 2354, 2357,
		1, 0, 0, 0, 2355, 2353, 1, 0, 0, 0, 2355, 2356, 1, 0, 0, 0, 2356, 2358,
		1, 0, 0, 0, 2357, 2355, 1, 0, 0, 0, 2358, 2359, 5, 1155, 0, 0, 2359, 2361,
		1, 0, 0, 0, 2360, 2349, 1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0, 2361, 2363,
		1, 0, 0, 0, 2362, 2216, 1, 0, 0, 0, 2362, 2250, 1, 0, 0, 0, 2362, 2275,
		1, 0, 0, 0, 2362, 2308, 1, 0, 0, 0, 2362, 2341, 1, 0, 0, 0, 2363, 125,
		1, 0, 0, 0, 2364, 2368, 3, 602, 301, 0, 2365, 2368, 3, 688, 344, 0, 2366,
		2368, 5, 110, 0, 0, 2367, 2364, 1, 0, 0, 0, 2367, 2365, 1, 0, 0, 0, 2367,
		2366, 1, 0, 0, 0, 2368, 127, 1, 0, 0, 0, 2369, 2370, 5, 1154, 0, 0, 2370,
		2373, 3, 126, 63, 0, 2371, 2372, 5, 1156, 0, 0, 2372, 2374, 3, 126, 63,
		0, 2373, 2371, 1, 0, 0, 0, 2374, 2375, 1, 0, 0, 0, 2375, 2373, 1, 0, 0,
		0, 2375, 2376, 1, 0, 0, 0, 2376, 2377, 1, 0, 0, 0, 2377, 2378, 5, 1155,
		0, 0, 2378, 129, 1, 0, 0, 0, 2379, 2380, 5, 644, 0, 0, 2380, 2384, 3, 584,
		292, 0, 2381, 2383, 3, 132, 66, 0, 2382, 2381, 1, 0, 0, 0, 2383, 2386,
		1, 0, 0, 0, 2384, 2382, 1, 0, 0, 0, 2384, 2385, 1, 0, 0, 0, 2385, 131,
		1, 0, 0, 0, 2386, 2384, 1, 0, 0, 0, 2387, 2389, 5, 43, 0, 0, 2388, 2387,
		1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0, 2389, 2391, 1, 0, 0, 0, 2390, 2392,
		5, 639, 0, 0, 2391, 2390, 1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392, 2393,
		1, 0, 0, 0, 2393, 2395, 5, 409, 0, 0, 2394, 2396, 5, 1145, 0, 0, 2395,
		2394, 1, 0, 0, 0, 2395, 2396, 1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397,
		2436, 3, 572, 286, 0, 2398, 2400, 5, 368, 0, 0, 2399, 2401, 5, 1145, 0,
		0, 2400, 2399, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2402, 1, 0, 0,
		0, 2402, 2436, 5, 1169, 0, 0, 2403, 2404, 5, 388, 0, 0, 2404, 2406, 5,
		395, 0, 0, 2405, 2407, 5, 1145, 0, 0, 2406, 2405, 1, 0, 0, 0, 2406, 2407,
		1, 0, 0, 0, 2407, 2408, 1, 0, 0, 0, 2408, 2436, 5, 1169, 0, 0, 2409, 2410,
		5, 81, 0, 0, 2410, 2412, 5, 395, 0, 0, 2411, 2413, 5, 1145, 0, 0, 2412,
		2411, 1, 0, 0, 0, 2412, 2413, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0, 2414,
		2436, 5, 1169, 0, 0, 2415, 2417, 5, 501, 0, 0, 2416, 2418, 5, 1145, 0,
		0, 2417, 2416, 1, 0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2419, 1, 0, 0,
		0, 2419, 2436, 3, 590, 295, 0, 2420, 2422, 5, 511, 0, 0, 2421, 2423, 5,
		1145, 0, 0, 2422, 2421, 1, 0, 0, 0, 2422, 2423, 1, 0, 0, 0, 2423, 2424,
		1, 0, 0, 0, 2424, 2436, 3, 590, 295, 0, 2425, 2427, 5, 650, 0, 0, 2426,
		2428, 5, 1145, 0, 0, 2427, 2426, 1, 0, 0, 0, 2427, 2428, 1, 0, 0, 0, 2428,
		2429, 1, 0, 0, 0, 2429, 2436, 3, 584, 292, 0, 2430, 2432, 5, 529, 0, 0,
		2431, 2433, 5, 1145, 0, 0, 2432, 2431, 1, 0, 0, 0, 2432, 2433, 1, 0, 0,
		0, 2433, 2434, 1, 0, 0, 0, 2434, 2436, 3, 584, 292, 0, 2435, 2388, 1, 0,
		0, 0, 2435, 2398, 1, 0, 0, 0, 2435, 2403, 1, 0, 0, 0, 2435, 2409, 1, 0,
		0, 0, 2435, 2415, 1, 0, 0, 0, 2435, 2420, 1, 0, 0, 0, 2435, 2425, 1, 0,
		0, 0, 2435, 2430, 1, 0, 0, 0, 2436, 133, 1, 0, 0, 0, 2437, 2438, 5, 7,
		0, 0, 2438, 2440, 7, 0, 0, 0, 2439, 2441, 3, 584, 292, 0, 2440, 2439, 1,
		0, 0, 0, 2440, 2441, 1, 0, 0, 0, 2441, 2443, 1, 0, 0, 0, 2442, 2444, 3,
		64, 32, 0, 2443, 2442, 1, 0, 0, 0, 2444, 2445, 1, 0, 0, 0, 2445, 2443,
		1, 0, 0, 0, 2445, 2446, 1, 0, 0, 0, 2446, 2456, 1, 0, 0, 0, 2447, 2448,
		5, 7, 0, 0, 2448, 2449, 7, 0, 0, 0, 2449, 2450, 3, 584, 292, 0, 2450, 2451,
		5, 668, 0, 0, 2451, 2452, 5, 388, 0, 0, 2452, 2453, 5, 395, 0, 0, 2453,
		2454, 5, 517, 0, 0, 2454, 2456, 1, 0, 0, 0, 2455, 2437, 1, 0, 0, 0, 2455,
		2447, 1, 0, 0, 0, 2456, 135, 1, 0, 0, 0, 2457, 2459, 5, 7, 0, 0, 2458,
		2460, 3, 70, 35, 0, 2459, 2458, 1, 0, 0, 0, 2459, 2460, 1, 0, 0, 0, 2460,
		2461, 1, 0, 0, 0, 2461, 2462, 5, 415, 0, 0, 2462, 2466, 3, 554, 277, 0,
		2463, 2464, 5, 118, 0, 0, 2464, 2465, 5, 607, 0, 0, 2465, 2467, 3, 72,
		36, 0, 2466, 2463, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2474, 1, 0,
		0, 0, 2468, 2469, 5, 118, 0, 0, 2469, 2471, 5, 371, 0, 0, 2470, 2472, 5,
		114, 0, 0, 2471, 2470, 1, 0, 0, 0, 2471, 2472, 1, 0, 0, 0, 2472, 2473,
		1, 0, 0, 0, 2473, 2475, 5, 562, 0, 0, 2474, 2468, 1, 0, 0, 0, 2474, 2475,
		1, 0, 0, 0, 2475, 2479, 1, 0, 0, 0, 2476, 2477, 5, 140, 0, 0, 2477, 2478,
		5, 175, 0, 0, 2478, 2480, 3, 554, 277, 0, 2479, 2476, 1, 0, 0, 0, 2479,
		2480, 1, 0, 0, 0, 2480, 2482, 1, 0, 0, 0, 2481, 2483, 3, 80, 40, 0, 2482,
		2481, 1, 0, 0, 0, 2482, 2483, 1, 0, 0, 0, 2483, 2486, 1, 0, 0, 0, 2484,
		2485, 5, 368, 0, 0, 2485, 2487, 5, 1169, 0, 0, 2486, 2484, 1, 0, 0, 0,
		2486, 2487, 1, 0, 0, 0, 2487, 2490, 1, 0, 0, 0, 2488, 2489, 5, 399, 0,
		0, 2489, 2491, 3, 394, 197, 0, 2490, 2488, 1, 0, 0, 0, 2490, 2491, 1, 0,
		0, 0, 2491, 137, 1, 0, 0, 0, 2492, 2493, 5, 7, 0, 0, 2493, 2494, 5, 437,
		0, 0, 2494, 2498, 3, 554, 277, 0, 2495, 2497, 3, 90, 45, 0, 2496, 2495,
		1, 0, 0, 0, 2497, 2500, 1, 0, 0, 0, 2498, 2496, 1, 0, 0, 0, 2498, 2499,
		1, 0, 0, 0, 2499, 139, 1, 0, 0, 0, 2500, 2498, 1, 0, 0, 0, 2501, 2502,
		5, 7, 0, 0, 2502, 2503, 5, 457, 0, 0, 2503, 2504, 5, 601, 0, 0, 2504, 2505,
		5, 798, 0, 0, 2505, 2506, 5, 478, 0, 0, 2506, 2507, 5, 91, 0, 0, 2507,
		141, 1, 0, 0, 0, 2508, 2509, 5, 7, 0, 0, 2509, 2510, 5, 476, 0, 0, 2510,
		2511, 5, 73, 0, 0, 2511, 2512, 3, 584, 292, 0, 2512, 2513, 5, 5, 0, 0,
		2513, 2514, 5, 663, 0, 0, 2514, 2520, 5, 1169, 0, 0, 2515, 2517, 5, 453,
		0, 0, 2516, 2518, 5, 1145, 0, 0, 2517, 2516, 1, 0, 0, 0, 2517, 2518, 1,
		0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 2521, 3, 592, 296, 0, 2520, 2515,
		1, 0, 0, 0, 2520, 2521, 1, 0, 0, 0, 2521, 2523, 1, 0, 0, 0, 2522, 2524,
		5, 678, 0, 0, 2523, 2522, 1, 0, 0, 0, 2523, 2524, 1, 0, 0, 0, 2524, 2525,
		1, 0, 0, 0, 2525, 2527, 5, 409, 0, 0, 2526, 2528, 5, 1145, 0, 0, 2527,
		2526, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 2529, 1, 0, 0, 0, 2529,
		2530, 3, 572, 286, 0, 2530, 143, 1, 0, 0, 0, 2531, 2532, 5, 7, 0, 0, 2532,
		2533, 5, 132, 0, 0, 2533, 2537, 3, 554, 277, 0, 2534, 2536, 3, 90, 45,
		0, 2535, 2534, 1, 0, 0, 0, 2536, 2539, 1, 0, 0, 0, 2537, 2535, 1, 0, 0,
		0, 2537, 2538, 1, 0, 0, 0, 2538, 145, 1, 0, 0, 0, 2539, 2537, 1, 0, 0,
		0, 2540, 2541, 5, 7, 0, 0, 2541, 2542, 5, 610, 0, 0, 2542, 2543, 3, 584,
		292, 0, 2543, 2544, 5, 542, 0, 0, 2544, 2545, 5, 1154, 0, 0, 2545, 2550,
		3, 92, 46, 0, 2546, 2547, 5, 1156, 0, 0, 2547, 2549, 3, 92, 46, 0, 2548,
		2546, 1, 0, 0, 0, 2549, 2552, 1, 0, 0, 0, 2550, 2548, 1, 0, 0, 0, 2550,
		2551, 1, 0, 0, 0, 2551, 2553, 1, 0, 0, 0, 2552, 2550, 1, 0, 0, 0, 2553,
		2554, 5, 1155, 0, 0, 2554, 147, 1, 0, 0, 0, 2555, 2557, 5, 7, 0, 0, 2556,
		2558, 7, 1, 0, 0, 2557, 2556, 1, 0, 0, 0, 2557, 2558, 1, 0, 0, 0, 2558,
		2560, 1, 0, 0, 0, 2559, 2561, 5, 78, 0, 0, 2560, 2559, 1, 0, 0, 0, 2560,
		2561, 1, 0, 0, 0, 2561, 2562, 1, 0, 0, 0, 2562, 2563, 5, 172, 0, 0, 2563,
		2565, 3, 556, 278, 0, 2564, 2566, 3, 644, 322, 0, 2565, 2564, 1, 0, 0,
		0, 2565, 2566, 1, 0, 0, 0, 2566, 2575, 1, 0, 0, 0, 2567, 2572, 3, 156,
		78, 0, 2568, 2569, 5, 1156, 0, 0, 2569, 2571, 3, 156, 78, 0, 2570, 2568,
		1, 0, 0, 0, 2571, 2574, 1, 0, 0, 0, 2572, 2570, 1, 0, 0, 0, 2572, 2573,
		1, 0, 0, 0, 2573, 2576, 1, 0, 0, 0, 2574, 2572, 1, 0, 0, 0, 2575, 2567,
		1, 0, 0, 0, 2575, 2576, 1, 0, 0, 0, 2576, 2578, 1, 0, 0, 0, 2577, 2579,
		3, 118, 59, 0, 2578, 2577, 1, 0, 0, 0, 2578, 2579, 1, 0, 0, 0, 2579, 149,
		1, 0, 0, 0, 2580, 2581, 5, 7, 0, 0, 2581, 2582, 5, 650, 0, 0, 2582, 2583,
		3, 584, 292, 0, 2583, 2584, 7, 36, 0, 0, 2584, 2585, 5, 389, 0, 0, 2585,
		2589, 5, 1169, 0, 0, 2586, 2587, 5, 453, 0, 0, 2587, 2588, 5, 1145, 0,
		0, 2588, 2590, 3, 592, 296, 0, 2589, 2586, 1, 0, 0, 0, 2589, 2590, 1, 0,
		0, 0, 2590, 2592, 1, 0, 0, 0, 2591, 2593, 5, 678, 0, 0, 2592, 2591, 1,
		0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593, 2594, 1, 0, 0, 0, 2594, 2596, 5,
		409, 0, 0, 2595, 2597, 5, 1145, 0, 0, 2596, 2595, 1, 0, 0, 0, 2596, 2597,
		1, 0, 0, 0, 2597, 2598, 1, 0, 0, 0, 2598, 2599, 3, 572, 286, 0, 2599, 151,
		1, 0, 0, 0, 2600, 2604, 5, 7, 0, 0, 2601, 2602, 5, 336, 0, 0, 2602, 2603,
		5, 1145, 0, 0, 2603, 2605, 7, 10, 0, 0, 2604, 2601, 1, 0, 0, 0, 2604, 2605,
		1, 0, 0, 0, 2605, 2607, 1, 0, 0, 0, 2606, 2608, 3, 70, 35, 0, 2607, 2606,
		1, 0, 0, 0, 2607, 2608, 1, 0, 0, 0, 2608, 2612, 1, 0, 0, 0, 2609, 2610,
		5, 160, 0, 0, 2610, 2611, 5, 608, 0, 0, 2611, 2613, 7, 11, 0, 0, 2612,
		2609, 1, 0, 0, 0, 2612, 2613, 1, 0, 0, 0, 2613, 2614, 1, 0, 0, 0, 2614,
		2615, 5, 675, 0, 0, 2615, 2620, 3, 554, 277, 0, 2616, 2617, 5, 1154, 0,
		0, 2617, 2618, 3, 616, 308, 0, 2618, 2619, 5, 1155, 0, 0, 2619, 2621, 1,
		0, 0, 0, 2620, 2616, 1, 0, 0, 0, 2620, 2621, 1, 0, 0, 0, 2621, 2622, 1,
		0, 0, 0, 2622, 2623, 5, 12, 0, 0, 2623, 2630, 3, 208, 104, 0, 2624, 2626,
		5, 192, 0, 0, 2625, 2627, 7, 12, 0, 0, 2626, 2625, 1, 0, 0, 0, 2626, 2627,
		1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 2629, 5, 27, 0, 0, 2629, 2631,
		5, 120, 0, 0, 2630, 2624, 1, 0, 0, 0, 2630, 2631, 1, 0, 0, 0, 2631, 153,
		1, 0, 0, 0, 2632, 2633, 5, 7, 0, 0, 2633, 2635, 5, 609, 0, 0, 2634, 2636,
		3, 638, 319, 0, 2635, 2634, 1, 0, 0, 0, 2635, 2636, 1, 0, 0, 0, 2636, 2637,
		1, 0, 0, 0, 2637, 2639, 3, 554, 277, 0, 2638, 2640, 3, 62, 31, 0, 2639,
		2638, 1, 0, 0, 0, 2640, 2641, 1, 0, 0, 0, 2641, 2639, 1, 0, 0, 0, 2641,
		2642, 1, 0, 0, 0, 2642, 155, 1, 0, 0, 0, 2643, 2650, 3, 112, 56, 0, 2644,
		2646, 5, 1156, 0, 0, 2645, 2644, 1, 0, 0, 0, 2645, 2646, 1, 0, 0, 0, 2646,
		2647, 1, 0, 0, 0, 2647, 2649, 3, 112, 56, 0, 2648, 2645, 1, 0, 0, 0, 2649,
		2652, 1, 0, 0, 0, 2650, 2648, 1, 0, 0, 0, 2650, 2651, 1, 0, 0, 0, 2651,
		3067, 1, 0, 0, 0, 2652, 2650, 1, 0, 0, 0, 2653, 2655, 5, 5, 0, 0, 2654,
		2656, 5, 29, 0, 0, 2655, 2654, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656,
		2658, 1, 0, 0, 0, 2657, 2659, 3, 640, 320, 0, 2658, 2657, 1, 0, 0, 0, 2658,
		2659, 1, 0, 0, 0, 2659, 2660, 1, 0, 0, 0, 2660, 2661, 3, 584, 292, 0, 2661,
		2665, 3, 98, 49, 0, 2662, 2666, 5, 430, 0, 0, 2663, 2664, 5, 334, 0, 0,
		2664, 2666, 3, 584, 292, 0, 2665, 2662, 1, 0, 0, 0, 2665, 2663, 1, 0, 0,
		0, 2665, 2666, 1, 0, 0, 0, 2666, 3067, 1, 0, 0, 0, 2667, 2669, 5, 5, 0,
		0, 2668, 2670, 5, 29, 0, 0, 2669, 2668, 1, 0, 0, 0, 2669, 2670, 1, 0, 0,
		0, 2670, 2672, 1, 0, 0, 0, 2671, 2673, 3, 640, 320, 0, 2672, 2671, 1, 0,
		0, 0, 2672, 2673, 1, 0, 0, 0, 2673, 2674, 1, 0, 0, 0, 2674, 2675, 5, 1154,
		0, 0, 2675, 2676, 3, 584, 292, 0, 2676, 2683, 3, 98, 49, 0, 2677, 2678,
		5, 1156, 0, 0, 2678, 2679, 3, 584, 292, 0, 2679, 2680, 3, 98, 49, 0, 2680,
		2682, 1, 0, 0, 0, 2681, 2677, 1, 0, 0, 0, 2682, 2685, 1, 0, 0, 0, 2683,
		2681, 1, 0, 0, 0, 2683, 2684, 1, 0, 0, 0, 2684, 2686, 1, 0, 0, 0, 2685,
		2683, 1, 0, 0, 0, 2686, 2687, 5, 1155, 0, 0, 2687, 3067, 1, 0, 0, 0, 2688,
		2689, 5, 5, 0, 0, 2689, 2691, 7, 23, 0, 0, 2690, 2692, 3, 640, 320, 0,
		2691, 2690, 1, 0, 0, 0, 2691, 2692, 1, 0, 0, 0, 2692, 2694, 1, 0, 0, 0,
		2693, 2695, 3, 584, 292, 0, 2694, 2693, 1, 0, 0, 0, 2694, 2695, 1, 0, 0,
		0, 2695, 2697, 1, 0, 0, 0, 2696, 2698, 3, 82, 41, 0, 2697, 2696, 1, 0,
		0, 0, 2697, 2698, 1, 0, 0, 0, 2698, 2699, 1, 0, 0, 0, 2699, 2703, 3, 620,
		310, 0, 2700, 2702, 3, 84, 42, 0, 2701, 2700, 1, 0, 0, 0, 2702, 2705, 1,
		0, 0, 0, 2703, 2701, 1, 0, 0, 0, 2703, 2704, 1, 0, 0, 0, 2704, 3067, 1,
		0, 0, 0, 2705, 2703, 1, 0, 0, 0, 2706, 2711, 5, 5, 0, 0, 2707, 2709, 5,
		31, 0, 0, 2708, 2710, 3, 584, 292, 0, 2709, 2708, 1, 0, 0, 0, 2709, 2710,
		1, 0, 0, 0, 2710, 2712, 1, 0, 0, 0, 2711, 2707, 1, 0, 0, 0, 2711, 2712,
		1, 0, 0, 0, 2712, 2713, 1, 0, 0, 0, 2713, 2714, 5, 130, 0, 0, 2714, 2716,
		5, 91, 0, 0, 2715, 2717, 3, 584, 292, 0, 2716, 2715, 1, 0, 0, 0, 2716,
		2717, 1, 0, 0, 0, 2717, 2719, 1, 0, 0, 0, 2718, 2720, 3, 82, 41, 0, 2719,
		2718, 1, 0, 0, 0, 2719, 2720, 1, 0, 0, 0, 2720, 2721, 1, 0, 0, 0, 2721,
		2725, 3, 620, 310, 0, 2722, 2724, 3, 84, 42, 0, 2723, 2722, 1, 0, 0, 0,
		2724, 2727, 1, 0, 0, 0, 2725, 2723, 1, 0, 0, 0, 2725, 2726, 1, 0, 0, 0,
		2726, 3067, 1, 0, 0, 0, 2727, 2725, 1, 0, 0, 0, 2728, 2733, 5, 5, 0, 0,
		2729, 2731, 5, 31, 0, 0, 2730, 2732, 3, 584, 292, 0, 2731, 2730, 1, 0,
		0, 0, 2731, 2732, 1, 0, 0, 0, 2732, 2734, 1, 0, 0, 0, 2733, 2729, 1, 0,
		0, 0, 2733, 2734, 1, 0, 0, 0, 2734, 2735, 1, 0, 0, 0, 2735, 2737, 5, 181,
		0, 0, 2736, 2738, 3, 640, 320, 0, 2737, 2736, 1, 0, 0, 0, 2737, 2738, 1,
		0, 0, 0, 2738, 2740, 1, 0, 0, 0, 2739, 2741, 7, 23, 0, 0, 2740, 2739, 1,
		0, 0, 0, 2740, 2741, 1, 0, 0, 0, 2741, 2743, 1, 0, 0, 0, 2742, 2744, 3,
		584, 292, 0, 2743, 2742, 1, 0, 0, 0, 2743, 2744, 1, 0, 0, 0, 2744, 2746,
		1, 0, 0, 0, 2745, 2747, 3, 82, 41, 0, 2746, 2745, 1, 0, 0, 0, 2746, 2747,
		1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 2752, 3, 620, 310, 0, 2749, 2751,
		3, 84, 42, 0, 2750, 2749, 1, 0, 0, 0, 2751, 2754, 1, 0, 0, 0, 2752, 2750,
		1, 0, 0, 0, 2752, 2753, 1, 0, 0, 0, 2753, 3067, 1, 0, 0, 0, 2754, 2752,
		1, 0, 0, 0, 2755, 2756, 5, 5, 0, 0, 2756, 2758, 7, 25, 0, 0, 2757, 2759,
		7, 23, 0, 0, 2758, 2757, 1, 0, 0, 0, 2758, 2759, 1, 0, 0, 0, 2759, 2761,
		1, 0, 0, 0, 2760, 2762, 3, 584, 292, 0, 2761, 2760, 1, 0, 0, 0, 2761, 2762,
		1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763, 2767, 3, 620, 310, 0, 2764, 2766,
		3, 84, 42, 0, 2765, 2764, 1, 0, 0, 0, 2766, 2769, 1, 0, 0, 0, 2767, 2765,
		1, 0, 0, 0, 2767, 2768, 1, 0, 0, 0, 2768, 3067, 1, 0, 0, 0, 2769, 2767,
		1, 0, 0, 0, 2770, 2775, 5, 5, 0, 0, 2771, 2773, 5, 31, 0, 0, 2772, 2774,
		3, 584, 292, 0, 2773, 2772, 1, 0, 0, 0, 2773, 2774, 1, 0, 0, 0, 2774, 2776,
		1, 0, 0, 0, 2775, 2771, 1, 0, 0, 0, 2775, 2776, 1, 0, 0, 0, 2776, 2777,
		1, 0, 0, 0, 2777, 2778, 5, 67, 0, 0, 2778, 2780, 5, 91, 0, 0, 2779, 2781,
		3, 640, 320, 0, 2780, 2779, 1, 0, 0, 0, 2780, 2781, 1, 0, 0, 0, 2781, 2783,
		1, 0, 0, 0, 2782, 2784, 3, 584, 292, 0, 2783, 2782, 1, 0, 0, 0, 2783, 2784,
		1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785, 2786, 3, 620, 310, 0, 2786, 2787,
		3, 104, 52, 0, 2787, 3067, 1, 0, 0, 0, 2788, 2793, 5, 5, 0, 0, 2789, 2791,
		5, 31, 0, 0, 2790, 2792, 3, 584, 292, 0, 2791, 2790, 1, 0, 0, 0, 2791,
		2792, 1, 0, 0, 0, 2792, 2794, 1, 0, 0, 0, 2793, 2789, 1, 0, 0, 0, 2793,
		2794, 1, 0, 0, 0, 2794, 2795, 1, 0, 0, 0, 2795, 2796, 5, 27, 0, 0, 2796,
		2797, 5, 1154, 0, 0, 2797, 2798, 3, 688, 344, 0, 2798, 2799, 5, 1155, 0,
		0, 2799, 3067, 1, 0, 0, 0, 2800, 2802, 5, 336, 0, 0, 2801, 2803, 5, 1145,
		0, 0, 2802, 2801, 1, 0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803, 2804, 1, 0,
		0, 0, 2804, 3067, 7, 37, 0, 0, 2805, 2807, 5, 7, 0, 0, 2806, 2808, 5, 29,
		0, 0, 2807, 2806, 1, 0, 0, 0, 2807, 2808, 1, 0, 0, 0, 2808, 2809, 1, 0,
		0, 0, 2809, 2815, 3, 584, 292, 0, 2810, 2811, 5, 154, 0, 0, 2811, 2812,
		5, 43, 0, 0, 2812, 2816, 3, 632, 316, 0, 2813, 2814, 5, 52, 0, 0, 2814,
		2816, 5, 43, 0, 0, 2815, 2810, 1, 0, 0, 0, 2815, 2813, 1, 0, 0, 0, 2816,
		3067, 1, 0, 0, 0, 2817, 2819, 5, 25, 0, 0, 2818, 2820, 5, 29, 0, 0, 2819,
		2818, 1, 0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820, 2822, 1, 0, 0, 0, 2821,
		2823, 3, 638, 319, 0, 2822, 2821, 1, 0, 0, 0, 2822, 2823, 1, 0, 0, 0, 2823,
		2824, 1, 0, 0, 0, 2824, 2825, 3, 584, 292, 0, 2825, 2826, 3, 584, 292,
		0, 2826, 2830, 3, 98, 49, 0, 2827, 2831, 5, 430, 0, 0, 2828, 2829, 5, 334,
		0, 0, 2829, 2831, 3, 584, 292, 0, 2830, 2827, 1, 0, 0, 0, 2830, 2828, 1,
		0, 0, 0, 2830, 2831, 1, 0, 0, 0, 2831, 3067, 1, 0, 0, 0, 2832, 2833, 5,
		140, 0, 0, 2833, 2834, 5, 29, 0, 0, 2834, 2835, 3, 584, 292, 0, 2835, 2836,
		5, 175, 0, 0, 2836, 2837, 3, 584, 292, 0, 2837, 3067, 1, 0, 0, 0, 2838,
		2840, 5, 103, 0, 0, 2839, 2841, 5, 1145, 0, 0, 2840, 2839, 1, 0, 0, 0,
		2840, 2841, 1, 0, 0, 0, 2841, 2842, 1, 0, 0, 0, 2842, 3067, 7, 4, 0, 0,
		2843, 2845, 5, 513, 0, 0, 2844, 2846, 5, 29, 0, 0, 2845, 2844, 1, 0, 0,
		0, 2845, 2846, 1, 0, 0, 0, 2846, 2848, 1, 0, 0, 0, 2847, 2849, 3, 638,
		319, 0, 2848, 2847, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2850, 1,
		0, 0, 0, 2850, 2851, 3, 584, 292, 0, 2851, 2855, 3, 98, 49, 0, 2852, 2856,
		5, 430, 0, 0, 2853, 2854, 5, 334, 0, 0, 2854, 2856, 3, 584, 292, 0, 2855,
		2852, 1, 0, 0, 0, 2855, 2853, 1, 0, 0, 0, 2855, 2856, 1, 0, 0, 0, 2856,
		3067, 1, 0, 0, 0, 2857, 2859, 5, 52, 0, 0, 2858, 2860, 5, 29, 0, 0, 2859,
		2858, 1, 0, 0, 0, 2859, 2860, 1, 0, 0, 0, 2860, 2862, 1, 0, 0, 0, 2861,
		2863, 3, 638, 319, 0, 2862, 2861, 1, 0, 0, 0, 2862, 2863, 1, 0, 0, 0, 2863,
		2864, 1, 0, 0, 0, 2864, 2866, 3, 584, 292, 0, 2865, 2867, 5, 145, 0, 0,
		2866, 2865, 1, 0, 0, 0, 2866, 2867, 1, 0, 0, 0, 2867, 3067, 1, 0, 0, 0,
		2868, 2869, 5, 52, 0, 0, 2869, 2871, 7, 38, 0, 0, 2870, 2872, 3, 638, 319,
		0, 2871, 2870, 1, 0, 0, 0, 2871, 2872, 1, 0, 0, 0, 2872, 2873, 1, 0, 0,
		0, 2873, 3067, 3, 584, 292, 0, 2874, 2875, 5, 52, 0, 0, 2875, 2876, 5,
		130, 0, 0, 2876, 3067, 5, 91, 0, 0, 2877, 2878, 5, 52, 0, 0, 2878, 2880,
		7, 23, 0, 0, 2879, 2881, 3, 638, 319, 0, 2880, 2879, 1, 0, 0, 0, 2880,
		2881, 1, 0, 0, 0, 2881, 2882, 1, 0, 0, 0, 2882, 3067, 3, 584, 292, 0, 2883,
		2884, 5, 140, 0, 0, 2884, 2885, 7, 23, 0, 0, 2885, 2886, 3, 584, 292, 0,
		2886, 2887, 5, 175, 0, 0, 2887, 2888, 3, 584, 292, 0, 2888, 3067, 1, 0,
		0, 0, 2889, 2890, 5, 7, 0, 0, 2890, 2891, 5, 81, 0, 0, 2891, 2892, 3, 584,
		292, 0, 2892, 2893, 7, 17, 0, 0, 2893, 3067, 1, 0, 0, 0, 2894, 2895, 5,
		52, 0, 0, 2895, 2896, 5, 67, 0, 0, 2896, 2898, 5, 91, 0, 0, 2897, 2899,
		3, 638, 319, 0, 2898, 2897, 1, 0, 0, 0, 2898, 2899, 1, 0, 0, 0, 2899, 2900,
		1, 0, 0, 0, 2900, 3067, 3, 584, 292, 0, 2901, 2902, 5, 396, 0, 0, 2902,
		3067, 5, 92, 0, 0, 2903, 2904, 5, 403, 0, 0, 2904, 3067, 5, 92, 0, 0, 2905,
		2907, 5, 140, 0, 0, 2906, 2908, 7, 39, 0, 0, 2907, 2906, 1, 0, 0, 0, 2907,
		2908, 1, 0, 0, 0, 2908, 2911, 1, 0, 0, 0, 2909, 2912, 3, 584, 292, 0, 2910,
		2912, 3, 554, 277, 0, 2911, 2909, 1, 0, 0, 0, 2911, 2910, 1, 0, 0, 0, 2912,
		3067, 1, 0, 0, 0, 2913, 2914, 5, 124, 0, 0, 2914, 2915, 5, 20, 0, 0, 2915,
		3067, 3, 616, 308, 0, 2916, 2917, 5, 33, 0, 0, 2917, 2918, 5, 175, 0, 0,
		2918, 2919, 5, 26, 0, 0, 2919, 2920, 5, 154, 0, 0, 2920, 2923, 3, 568,
		284, 0, 2921, 2922, 5, 28, 0, 0, 2922, 2924, 3, 570, 285, 0, 2923, 2921,
		1, 0, 0, 0, 2923, 2924, 1, 0, 0, 0, 2924, 3067, 1, 0, 0, 0, 2925, 2927,
		5, 43, 0, 0, 2926, 2925, 1, 0, 0, 0, 2926, 2927, 1, 0, 0, 0, 2927, 2928,
		1, 0, 0, 0, 2928, 2929, 5, 26, 0, 0, 2929, 2930, 5, 154, 0, 0, 2930, 2931,
		5, 1145, 0, 0, 2931, 2935, 3, 568, 284, 0, 2932, 2933, 5, 28, 0, 0, 2933,
		2934, 5, 1145, 0, 0, 2934, 2936, 3, 570, 285, 0, 2935, 2932, 1, 0, 0, 0,
		2935, 2936, 1, 0, 0, 0, 2936, 3067, 1, 0, 0, 0, 2937, 2938, 5, 397, 0,
		0, 2938, 3067, 5, 650, 0, 0, 2939, 2940, 5, 450, 0, 0, 2940, 3067, 5, 650,
		0, 0, 2941, 3067, 5, 66, 0, 0, 2942, 2943, 7, 40, 0, 0, 2943, 3067, 5,
		672, 0, 0, 2944, 2945, 5, 5, 0, 0, 2945, 2947, 5, 129, 0, 0, 2946, 2948,
		3, 640, 320, 0, 2947, 2946, 1, 0, 0, 0, 2947, 2948, 1, 0, 0, 0, 2948, 2949,
		1, 0, 0, 0, 2949, 2950, 5, 1154, 0, 0, 2950, 2955, 3, 124, 62, 0, 2951,
		2952, 5, 1156, 0, 0, 2952, 2954, 3, 124, 62, 0, 2953, 2951, 1, 0, 0, 0,
		2954, 2957, 1, 0, 0, 0, 2955, 2953, 1, 0, 0, 0, 2955, 2956, 1, 0, 0, 0,
		2956, 2958, 1, 0, 0, 0, 2957, 2955, 1, 0, 0, 0, 2958, 2959, 5, 1155, 0,
		0, 2959, 3067, 1, 0, 0, 0, 2960, 2961, 5, 52, 0, 0, 2961, 2963, 5, 129,
		0, 0, 2962, 2964, 3, 638, 319, 0, 2963, 2962, 1, 0, 0, 0, 2963, 2964, 1,
		0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 3067, 3, 616, 308, 0, 2966, 2967,
		5, 397, 0, 0, 2967, 2970, 5, 129, 0, 0, 2968, 2971, 3, 616, 308, 0, 2969,
		2971, 5, 6, 0, 0, 2970, 2968, 1, 0, 0, 0, 2970, 2969, 1, 0, 0, 0, 2971,
		2972, 1, 0, 0, 0, 2972, 3067, 5, 650, 0, 0, 2973, 2974, 5, 450, 0, 0, 2974,
		2977, 5, 129, 0, 0, 2975, 2978, 3, 616, 308, 0, 2976, 2978, 5, 6, 0, 0,
		2977, 2975, 1, 0, 0, 0, 2977, 2976, 1, 0, 0, 0, 2978, 2979, 1, 0, 0, 0,
		2979, 3067, 5, 650, 0, 0, 2980, 2981, 5, 659, 0, 0, 2981, 2984, 5, 129,
		0, 0, 2982, 2985, 3, 616, 308, 0, 2983, 2985, 5, 6, 0, 0, 2984, 2982, 1,
		0, 0, 0, 2984, 2983, 1, 0, 0, 0, 2985, 3067, 1, 0, 0, 0, 2986, 2987, 5,
		363, 0, 0, 2987, 2988, 5, 129, 0, 0, 2988, 3067, 3, 590, 295, 0, 2989,
		2990, 5, 581, 0, 0, 2990, 2991, 5, 129, 0, 0, 2991, 2992, 3, 616, 308,
		0, 2992, 2993, 5, 87, 0, 0, 2993, 2994, 5, 1154, 0, 0, 2994, 2999, 3, 124,
		62, 0, 2995, 2996, 5, 1156, 0, 0, 2996, 2998, 3, 124, 62, 0, 2997, 2995,
		1, 0, 0, 0, 2998, 3001, 1, 0, 0, 0, 2999, 2997, 1, 0, 0, 0, 2999, 3000,
		1, 0, 0, 0, 3000, 3002, 1, 0, 0, 0, 3001, 2999, 1, 0, 0, 0, 3002, 3003,
		5, 1155, 0, 0, 3003, 3067, 1, 0, 0, 0, 3004, 3005, 5, 418, 0, 0, 3005,
		3006, 5, 129, 0, 0, 3006, 3007, 3, 584, 292, 0, 3007, 3008, 5, 192, 0,
		0, 3008, 3009, 5, 172, 0, 0, 3009, 3012, 3, 556, 278, 0, 3010, 3011, 7,
		40, 0, 0, 3011, 3013, 5, 672, 0, 0, 3012, 3010, 1, 0, 0, 0, 3012, 3013,
		1, 0, 0, 0, 3013, 3067, 1, 0, 0, 0, 3014, 3015, 5, 9, 0, 0, 3015, 3018,
		5, 129, 0, 0, 3016, 3019, 3, 616, 308, 0, 3017, 3019, 5, 6, 0, 0, 3018,
		3016, 1, 0, 0, 0, 3018, 3017, 1, 0, 0, 0, 3019, 3067, 1, 0, 0, 0, 3020,
		3021, 5, 27, 0, 0, 3021, 3024, 5, 129, 0, 0, 3022, 3025, 3, 616, 308, 0,
		3023, 3025, 5, 6, 0, 0, 3024, 3022, 1, 0, 0, 0, 3024, 3023, 1, 0, 0, 0,
		3025, 3067, 1, 0, 0, 0, 3026, 3027, 5, 119, 0, 0, 3027, 3030, 5, 129, 0,
		0, 3028, 3031, 3, 616, 308, 0, 3029, 3031, 5, 6, 0, 0, 3030, 3028, 1, 0,
		0, 0, 3030, 3029, 1, 0, 0, 0, 3031, 3067, 1, 0, 0, 0, 3032, 3033, 5, 571,
		0, 0, 3033, 3036, 5, 129, 0, 0, 3034, 3037, 3, 616, 308, 0, 3035, 3037,
		5, 6, 0, 0, 3036, 3034, 1, 0, 0, 0, 3036, 3035, 1, 0, 0, 0, 3037, 3067,
		1, 0, 0, 0, 3038, 3039, 5, 582, 0, 0, 3039, 3042, 5, 129, 0, 0, 3040, 3043,
		3, 616, 308, 0, 3041, 3043, 5, 6, 0, 0, 3042, 3040, 1, 0, 0, 0, 3042, 3041,
		1, 0, 0, 0, 3043, 3067, 1, 0, 0, 0, 3044, 3045, 5, 580, 0, 0, 3045, 3067,
		5, 550, 0, 0, 3046, 3047, 5, 668, 0, 0, 3047, 3067, 5, 550, 0, 0, 3048,
		3050, 5, 5, 0, 0, 3049, 3051, 5, 29, 0, 0, 3050, 3049, 1, 0, 0, 0, 3050,
		3051, 1, 0, 0, 0, 3051, 3053, 1, 0, 0, 0, 3052, 3054, 3, 640, 320, 0, 3053,
		3052, 1, 0, 0, 0, 3053, 3054, 1, 0, 0, 0, 3054, 3055, 1, 0, 0, 0, 3055,
		3056, 5, 1154, 0, 0, 3056, 3061, 3, 96, 48, 0, 3057, 3058, 5, 1156, 0,
		0, 3058, 3060, 3, 96, 48, 0, 3059, 3057, 1, 0, 0, 0, 3060, 3063, 1, 0,
		0, 0, 3061, 3059, 1, 0, 0, 0, 3061, 3062, 1, 0, 0, 0, 3062, 3064, 1, 0,
		0, 0, 3063, 3061, 1, 0, 0, 0, 3064, 3065, 5, 1155, 0, 0, 3065, 3067, 1,
		0, 0, 0, 3066, 2643, 1, 0, 0, 0, 3066, 2653, 1, 0, 0, 0, 3066, 2667, 1,
		0, 0, 0, 3066, 2688, 1, 0, 0, 0, 3066, 2706, 1, 0, 0, 0, 3066, 2728, 1,
		0, 0, 0, 3066, 2755, 1, 0, 0, 0, 3066, 2770, 1, 0, 0, 0, 3066, 2788, 1,
		0, 0, 0, 3066, 2800, 1, 0, 0, 0, 3066, 2805, 1, 0, 0, 0, 3066, 2817, 1,
		0, 0, 0, 3066, 2832, 1, 0, 0, 0, 3066, 2838, 1, 0, 0, 0, 3066, 2843, 1,
		0, 0, 0, 3066, 2857, 1, 0, 0, 0, 3066, 2868, 1, 0, 0, 0, 3066, 2874, 1,
		0, 0, 0, 3066, 2877, 1, 0, 0, 0, 3066, 2883, 1, 0, 0, 0, 3066, 2889, 1,
		0, 0, 0, 3066, 2894, 1, 0, 0, 0, 3066, 2901, 1, 0, 0, 0, 3066, 2903, 1,
		0, 0, 0, 3066, 2905, 1, 0, 0, 0, 3066, 2913, 1, 0, 0, 0, 3066, 2916, 1,
		0, 0, 0, 3066, 2926, 1, 0, 0, 0, 3066, 2937, 1, 0, 0, 0, 3066, 2939, 1,
		0, 0, 0, 3066, 2941, 1, 0, 0, 0, 3066, 2942, 1, 0, 0, 0, 3066, 2944, 1,
		0, 0, 0, 3066, 2960, 1, 0, 0, 0, 3066, 2966, 1, 0, 0, 0, 3066, 2973, 1,
		0, 0, 0, 3066, 2980, 1, 0, 0, 0, 3066, 2986, 1, 0, 0, 0, 3066, 2989, 1,
		0, 0, 0, 3066, 3004, 1, 0, 0, 0, 3066, 3014, 1, 0, 0, 0, 3066, 3020, 1,
		0, 0, 0, 3066, 3026, 1, 0, 0, 0, 3066, 3032, 1, 0, 0, 0, 3066, 3038, 1,
		0, 0, 0, 3066, 3044, 1, 0, 0, 0, 3066, 3046, 1, 0, 0, 0, 3066, 3048, 1,
		0, 0, 0, 3067, 157, 1, 0, 0, 0, 3068, 3069, 5, 52, 0, 0, 3069, 3071, 7,
		0, 0, 0, 3070, 3072, 3, 638, 319, 0, 3071, 3070, 1, 0, 0, 0, 3071, 3072,
		1, 0, 0, 0, 3072, 3073, 1, 0, 0, 0, 3073, 3074, 3, 584, 292, 0, 3074, 159,
		1, 0, 0, 0, 3075, 3076, 5, 52, 0, 0, 3076, 3078, 5, 415, 0, 0, 3077, 3079,
		3, 638, 319, 0, 3078, 3077, 1, 0, 0, 0, 3078, 3079, 1, 0, 0, 0, 3079, 3080,
		1, 0, 0, 0, 3080, 3081, 3, 554, 277, 0, 3081, 161, 1, 0, 0, 0, 3082, 3083,
		5, 52, 0, 0, 3083, 3085, 5, 81, 0, 0, 3084, 3086, 3, 638, 319, 0, 3085,
		3084, 1, 0, 0, 0, 3085, 3086, 1, 0, 0, 0, 3086, 3088, 1, 0, 0, 0, 3087,
		3089, 7, 1, 0, 0, 3088, 3087, 1, 0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089,
		3090, 1, 0, 0, 0, 3090, 3091, 3, 584, 292, 0, 3091, 3092, 5, 118, 0, 0,
		3092, 3105, 3, 556, 278, 0, 3093, 3095, 5, 336, 0, 0, 3094, 3096, 5, 1145,
		0, 0, 3095, 3094, 1, 0, 0, 0, 3095, 3096, 1, 0, 0, 0, 3096, 3097, 1, 0,
		0, 0, 3097, 3104, 7, 41, 0, 0, 3098, 3100, 5, 103, 0, 0, 3099, 3101, 5,
		1145, 0, 0, 3100, 3099, 1, 0, 0, 0, 3100, 3101, 1, 0, 0, 0, 3101, 3102,
		1, 0, 0, 0, 3102, 3104, 7, 4, 0, 0, 3103, 3093, 1, 0, 0, 0, 3103, 3098,
		1, 0, 0, 0, 3104, 3107, 1, 0, 0, 0, 3105, 3103, 1, 0, 0, 0, 3105, 3106,
		1, 0, 0, 0, 3106, 3109, 1, 0, 0, 0, 3107, 3105, 1, 0, 0, 0, 3108, 3110,
		3, 644, 322, 0, 3109, 3108, 1, 0, 0, 0, 3109, 3110, 1, 0, 0, 0, 3110, 163,
		1, 0, 0, 0, 3111, 3112, 5, 52, 0, 0, 3112, 3113, 5, 476, 0, 0, 3113, 3114,
		5, 73, 0, 0, 3114, 3115, 3, 584, 292, 0, 3115, 3116, 5, 409, 0, 0, 3116,
		3117, 5, 1145, 0, 0, 3117, 3118, 3, 572, 286, 0, 3118, 165, 1, 0, 0, 0,
		3119, 3120, 5, 52, 0, 0, 3120, 3122, 5, 132, 0, 0, 3121, 3123, 3, 638,
		319, 0, 3122, 3121, 1, 0, 0, 0, 3122, 3123, 1, 0, 0, 0, 3123, 3124, 1,
		0, 0, 0, 3124, 3125, 3, 554, 277, 0, 3125, 167, 1, 0, 0, 0, 3126, 3127,
		5, 52, 0, 0, 3127, 3129, 5, 437, 0, 0, 3128, 3130, 3, 638, 319, 0, 3129,
		3128, 1, 0, 0, 0, 3129, 3130, 1, 0, 0, 0, 3130, 3131, 1, 0, 0, 0, 3131,
		3132, 3, 554, 277, 0, 3132, 169, 1, 0, 0, 0, 3133, 3134, 5, 52, 0, 0, 3134,
		3136, 5, 610, 0, 0, 3135, 3137, 3, 638, 319, 0, 3136, 3135, 1, 0, 0, 0,
		3136, 3137, 1, 0, 0, 0, 3137, 3138, 1, 0, 0, 0, 3138, 3139, 3, 584, 292,
		0, 3139, 171, 1, 0, 0, 0, 3140, 3142, 5, 52, 0, 0, 3141, 3143, 5, 652,
		0, 0, 3142, 3141, 1, 0, 0, 0, 3142, 3143, 1, 0, 0, 0, 3143, 3144, 1, 0,
		0, 0, 3144, 3146, 5, 172, 0, 0, 3145, 3147, 3, 638, 319, 0, 3146, 3145,
		1, 0, 0, 0, 3146, 3147, 1, 0, 0, 0, 3147, 3148, 1, 0, 0, 0, 3148, 3150,
		3, 618, 309, 0, 3149, 3151, 3, 644, 322, 0, 3150, 3149, 1, 0, 0, 0, 3150,
		3151, 1, 0, 0, 0, 3151, 3153, 1, 0, 0, 0, 3152, 3154, 7, 42, 0, 0, 3153,
		3152, 1, 0, 0, 0, 3153, 3154, 1, 0, 0, 0, 3154, 173, 1, 0, 0, 0, 3155,
		3156, 5, 52, 0, 0, 3156, 3157, 5, 650, 0, 0, 3157, 3163, 3, 584, 292, 0,
		3158, 3160, 5, 409, 0, 0, 3159, 3161, 5, 1145, 0, 0, 3160, 3159, 1, 0,
		0, 0, 3160, 3161, 1, 0, 0, 0, 3161, 3162, 1, 0, 0, 0, 3162, 3164, 3, 572,
		286, 0, 3163, 3158, 1, 0, 0, 0, 3163, 3164, 1, 0, 0, 0, 3164, 175, 1, 0,
		0, 0, 3165, 3166, 5, 52, 0, 0, 3166, 3168, 5, 177, 0, 0, 3167, 3169, 3,
		638, 319, 0, 3168, 3167, 1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3170,
		1, 0, 0, 0, 3170, 3171, 3, 554, 277, 0, 3171, 177, 1, 0, 0, 0, 3172, 3173,
		5, 52, 0, 0, 3173, 3175, 5, 675, 0, 0, 3174, 3176, 3, 638, 319, 0, 3175,
		3174, 1, 0, 0, 0, 3175, 3176, 1, 0, 0, 0, 3176, 3177, 1, 0, 0, 0, 3177,
		3182, 3, 554, 277, 0, 3178, 3179, 5, 1156, 0, 0, 3179, 3181, 3, 554, 277,
		0, 3180, 3178, 1, 0, 0, 0, 3181, 3184, 1, 0, 0, 0, 3182, 3180, 1, 0, 0,
		0, 3182, 3183, 1, 0, 0, 0, 3183, 3186, 1, 0, 0, 0, 3184, 3182, 1, 0, 0,
		0, 3185, 3187, 7, 42, 0, 0, 3186, 3185, 1, 0, 0, 0, 3186, 3187, 1, 0, 0,
		0, 3187, 179, 1, 0, 0, 0, 3188, 3189, 5, 52, 0, 0, 3189, 3191, 5, 598,
		0, 0, 3190, 3192, 3, 638, 319, 0, 3191, 3190, 1, 0, 0, 0, 3191, 3192, 1,
		0, 0, 0, 3192, 3193, 1, 0, 0, 0, 3193, 3198, 3, 558, 279, 0, 3194, 3195,
		5, 1156, 0, 0, 3195, 3197, 3, 558, 279, 0, 3196, 3194, 1, 0, 0, 0, 3197,
		3200, 1, 0, 0, 0, 3198, 3196, 1, 0, 0, 0, 3198, 3199, 1, 0, 0, 0, 3199,
		181, 1, 0, 0, 0, 3200, 3198, 1, 0, 0, 0, 3201, 3202, 5, 154, 0, 0, 3202,
		3203, 5, 43, 0, 0, 3203, 3214, 5, 598, 0, 0, 3204, 3215, 5, 530, 0, 0,
		3205, 3215, 5, 6, 0, 0, 3206, 3211, 3, 558, 279, 0, 3207, 3208, 5, 1156,
		0, 0, 3208, 3210, 3, 558, 279, 0, 3209, 3207, 1, 0, 0, 0, 3210, 3213, 1,
		0, 0, 0, 3211, 3209, 1, 0, 0, 0, 3211, 3212, 1, 0, 0, 0, 3212, 3215, 1,
		0, 0, 0, 3213, 3211, 1, 0, 0, 0, 3214, 3204, 1, 0, 0, 0, 3214, 3205, 1,
		0, 0, 0, 3214, 3206, 1, 0, 0, 0, 3215, 3216, 1, 0, 0, 0, 3216, 3219, 5,
		175, 0, 0, 3217, 3220, 3, 564, 282, 0, 3218, 3220, 3, 584, 292, 0, 3219,
		3217, 1, 0, 0, 0, 3219, 3218, 1, 0, 0, 0, 3220, 3228, 1, 0, 0, 0, 3221,
		3224, 5, 1156, 0, 0, 3222, 3225, 3, 564, 282, 0, 3223, 3225, 3, 584, 292,
		0, 3224, 3222, 1, 0, 0, 0, 3224, 3223, 1, 0, 0, 0, 3225, 3227, 1, 0, 0,
		0, 3226, 3221, 1, 0, 0, 0, 3227, 3230, 1, 0, 0, 0, 3228, 3226, 1, 0, 0,
		0, 3228, 3229, 1, 0, 0, 0, 3229, 3235, 1, 0, 0, 0, 3230, 3228, 1, 0, 0,
		0, 3231, 3232, 5, 154, 0, 0, 3232, 3233, 5, 598, 0, 0, 3233, 3235, 3, 440,
		220, 0, 3234, 3201, 1, 0, 0, 0, 3234, 3231, 1, 0, 0, 0, 3235, 183, 1, 0,
		0, 0, 3236, 3238, 5, 52, 0, 0, 3237, 3239, 5, 652, 0, 0, 3238, 3237, 1,
		0, 0, 0, 3238, 3239, 1, 0, 0, 0, 3239, 3240, 1, 0, 0, 0, 3240, 3242, 5,
		609, 0, 0, 3241, 3243, 3, 638, 319, 0, 3242, 3241, 1, 0, 0, 0, 3242, 3243,
		1, 0, 0, 0, 3243, 3245, 1, 0, 0, 0, 3244, 3246, 5, 3, 0, 0, 3245, 3244,
		1, 0, 0, 0, 3245, 3246, 1, 0, 0, 0, 3246, 3247, 1, 0, 0, 0, 3247, 3252,
		3, 554, 277, 0, 3248, 3249, 5, 1156, 0, 0, 3249, 3251, 3, 554, 277, 0,
		3250, 3248, 1, 0, 0, 0, 3251, 3254, 1, 0, 0, 0, 3252, 3250, 1, 0, 0, 0,
		3252, 3253, 1, 0, 0, 0, 3253, 185, 1, 0, 0, 0, 3254, 3252, 1, 0, 0, 0,
		3255, 3256, 5, 140, 0, 0, 3256, 3257, 5, 172, 0, 0, 3257, 3262, 3, 188,
		94, 0, 3258, 3259, 5, 1156, 0, 0, 3259, 3261, 3, 188, 94, 0, 3260, 3258,
		1, 0, 0, 0, 3261, 3264, 1, 0, 0, 0, 3262, 3260, 1, 0, 0, 0, 3262, 3263,
		1, 0, 0, 0, 3263, 187, 1, 0, 0, 0, 3264, 3262, 1, 0, 0, 0, 3265, 3267,
		3, 556, 278, 0, 3266, 3268, 3, 644, 322, 0, 3267, 3266, 1, 0, 0, 0, 3267,
		3268, 1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0, 3269, 3270, 5, 175, 0, 0, 3270,
		3271, 3, 556, 278, 0, 3271, 189, 1, 0, 0, 0, 3272, 3274, 5, 659, 0, 0,
		3273, 3275, 5, 172, 0, 0, 3274, 3273, 1, 0, 0, 0, 3274, 3275, 1, 0, 0,
		0, 3275, 3276, 1, 0, 0, 0, 3276, 3278, 3, 556, 278, 0, 3277, 3279, 3, 644,
		322, 0, 3278, 3277, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 191, 1, 0,
		0, 0, 3280, 3281, 5, 21, 0, 0, 3281, 3288, 3, 554, 277, 0, 3282, 3285,
		5, 1154, 0, 0, 3283, 3286, 3, 626, 313, 0, 3284, 3286, 3, 622, 311, 0,
		3285, 3283, 1, 0, 0, 0, 3285, 3284, 1, 0, 0, 0, 3285, 3286, 1, 0, 0, 0,
		3286, 3287, 1, 0, 0, 0, 3287, 3289, 5, 1155, 0, 0, 3288, 3282, 1, 0, 0,
		0, 3288, 3289, 1, 0, 0, 0, 3289, 193, 1, 0, 0, 0, 3290, 3293, 3, 222, 111,
		0, 3291, 3293, 3, 224, 112, 0, 3292, 3290, 1, 0, 0, 0, 3292, 3291, 1, 0,
		0, 0, 3293, 195, 1, 0, 0, 0, 3294, 3295, 5, 399, 0, 0, 3295, 3296, 3, 622,
		311, 0, 3296, 197, 1, 0, 0, 0, 3297, 3302, 3, 226, 113, 0, 3298, 3302,
		3, 228, 114, 0, 3299, 3302, 3, 230, 115, 0, 3300, 3302, 3, 232, 116, 0,
		3301, 3297, 1, 0, 0, 0, 3301, 3298, 1, 0, 0, 0, 3301, 3299, 1, 0, 0, 0,
		3301, 3300, 1, 0, 0, 0, 3302, 199, 1, 0, 0, 0, 3303, 3305, 5, 85, 0, 0,
		3304, 3306, 7, 43, 0, 0, 3305, 3304, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0,
		3306, 3308, 1, 0, 0, 0, 3307, 3309, 5, 78, 0, 0, 3308, 3307, 1, 0, 0, 0,
		3308, 3309, 1, 0, 0, 0, 3309, 3311, 1, 0, 0, 0, 3310, 3312, 5, 87, 0, 0,
		3311, 3310, 1, 0, 0, 0, 3311, 3312, 1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0,
		3313, 3320, 3, 556, 278, 0, 3314, 3315, 5, 129, 0, 0, 3315, 3317, 5, 1154,
		0, 0, 3316, 3318, 3, 616, 308, 0, 3317, 3316, 1, 0, 0, 0, 3317, 3318, 1,
		0, 0, 0, 3318, 3319, 1, 0, 0, 0, 3319, 3321, 5, 1155, 0, 0, 3320, 3314,
		1, 0, 0, 0, 3320, 3321, 1, 0, 0, 0, 3321, 3338, 1, 0, 0, 0, 3322, 3323,
		5, 1154, 0, 0, 3323, 3324, 3, 616, 308, 0, 3324, 3325, 5, 1155, 0, 0, 3325,
		3327, 1, 0, 0, 0, 3326, 3322, 1, 0, 0, 0, 3326, 3327, 1, 0, 0, 0, 3327,
		3328, 1, 0, 0, 0, 3328, 3339, 3, 214, 107, 0, 3329, 3330, 5, 154, 0, 0,
		3330, 3335, 3, 216, 108, 0, 3331, 3332, 5, 1156, 0, 0, 3332, 3334, 3, 216,
		108, 0, 3333, 3331, 1, 0, 0, 0, 3334, 3337, 1, 0, 0, 0, 3335, 3333, 1,
		0, 0, 0, 3335, 3336, 1, 0, 0, 0, 3336, 3339, 1, 0, 0, 0, 3337, 3335, 1,
		0, 0, 0, 3338, 3326, 1, 0, 0, 0, 3338, 3329, 1, 0, 0, 0, 3339, 3352, 1,
		0, 0, 0, 3340, 3341, 5, 118, 0, 0, 3341, 3342, 5, 401, 0, 0, 3342, 3343,
		5, 91, 0, 0, 3343, 3344, 5, 184, 0, 0, 3344, 3349, 3, 216, 108, 0, 3345,
		3346, 5, 1156, 0, 0, 3346, 3348, 3, 216, 108, 0, 3347, 3345, 1, 0, 0, 0,
		3348, 3351, 1, 0, 0, 0, 3349, 3347, 1, 0, 0, 0, 3349, 3350, 1, 0, 0, 0,
		3350, 3353, 1, 0, 0, 0, 3351, 3349, 1, 0, 0, 0, 3352, 3340, 1, 0, 0, 0,
		3352, 3353, 1, 0, 0, 0, 3353, 201, 1, 0, 0, 0, 3354, 3355, 5, 102, 0, 0,
		3355, 3357, 5, 388, 0, 0, 3356, 3358, 7, 44, 0, 0, 3357, 3356, 1, 0, 0,
		0, 3357, 3358, 1, 0, 0, 0, 3358, 3360, 1, 0, 0, 0, 3359, 3361, 5, 474,
		0, 0, 3360, 3359, 1, 0, 0, 0, 3360, 3361, 1, 0, 0, 0, 3361, 3362, 1, 0,
		0, 0, 3362, 3363, 5, 82, 0, 0, 3363, 3365, 5, 1169, 0, 0, 3364, 3366, 7,
		6, 0, 0, 3365, 3364, 1, 0, 0, 0, 3365, 3366, 1, 0, 0, 0, 3366, 3367, 1,
		0, 0, 0, 3367, 3368, 5, 87, 0, 0, 3368, 3369, 5, 172, 0, 0, 3369, 3375,
		3, 556, 278, 0, 3370, 3371, 5, 129, 0, 0, 3371, 3372, 5, 1154, 0, 0, 3372,
		3373, 3, 616, 308, 0, 3373, 3374, 5, 1155, 0, 0, 3374, 3376, 1, 0, 0, 0,
		3375, 3370, 1, 0, 0, 0, 3375, 3376, 1, 0, 0, 0, 3376, 3380, 1, 0, 0, 0,
		3377, 3378, 5, 26, 0, 0, 3378, 3379, 5, 154, 0, 0, 3379, 3381, 3, 568,
		284, 0, 3380, 3377, 1, 0, 0, 0, 3380, 3381, 1, 0, 0, 0, 3381, 3388, 1,
		0, 0, 0, 3382, 3384, 7, 45, 0, 0, 3383, 3385, 3, 286, 143, 0, 3384, 3383,
		1, 0, 0, 0, 3385, 3386, 1, 0, 0, 0, 3386, 3384, 1, 0, 0, 0, 3386, 3387,
		1, 0, 0, 0, 3387, 3389, 1, 0, 0, 0, 3388, 3382, 1, 0, 0, 0, 3388, 3389,
		1, 0, 0, 0, 3389, 3396, 1, 0, 0, 0, 3390, 3392, 5, 101, 0, 0, 3391, 3393,
		3, 288, 144, 0, 3392, 3391, 1, 0, 0, 0, 3393, 3394, 1, 0, 0, 0, 3394, 3392,
		1, 0, 0, 0, 3394, 3395, 1, 0, 0, 0, 3395, 3397, 1, 0, 0, 0, 3396, 3390,
		1, 0, 0, 0, 3396, 3397, 1, 0, 0, 0, 3397, 3402, 1, 0, 0, 0, 3398, 3399,
		5, 78, 0, 0, 3399, 3400, 3, 590, 295, 0, 3400, 3401, 7, 46, 0, 0, 3401,
		3403, 1, 0, 0, 0, 3402, 3398, 1, 0, 0, 0, 3402, 3403, 1, 0, 0, 0, 3403,
		3415, 1, 0, 0, 0, 3404, 3405, 5, 1154, 0, 0, 3405, 3410, 3, 218, 109, 0,
		3406, 3407, 5, 1156, 0, 0, 3407, 3409, 3, 218, 109, 0, 3408, 3406, 1, 0,
		0, 0, 3409, 3412, 1, 0, 0, 0, 3410, 3408, 1, 0, 0, 0, 3410, 3411, 1, 0,
		0, 0, 3411, 3413, 1, 0, 0, 0, 3412, 3410, 1, 0, 0, 0, 3413, 3414, 5, 1155,
		0, 0, 3414, 3416, 1, 0, 0, 0, 3415, 3404, 1, 0, 0, 0, 3415, 3416, 1, 0,
		0, 0, 3416, 3426, 1, 0, 0, 0, 3417, 3418, 5, 154, 0, 0, 3418, 3423, 3,
		216, 108, 0, 3419, 3420, 5, 1156, 0, 0, 3420, 3422, 3, 216, 108, 0, 3421,
		3419, 1, 0, 0, 0, 3422, 3425, 1, 0, 0, 0, 3423, 3421, 1, 0, 0, 0, 3423,
		3424, 1, 0, 0, 0, 3424, 3427, 1, 0, 0, 0, 3425, 3423, 1, 0, 0, 0, 3426,
		3417, 1, 0, 0, 0, 3426, 3427, 1, 0, 0, 0, 3427, 203, 1, 0, 0, 0, 3428,
		3429, 5, 102, 0, 0, 3429, 3431, 5, 688, 0, 0, 3430, 3432, 7, 44, 0, 0,
		3431, 3430, 1, 0, 0, 0, 3431, 3432, 1, 0, 0, 0, 3432, 3434, 1, 0, 0, 0,
		3433, 3435, 5, 474, 0, 0, 3434, 3433, 1, 0, 0, 0, 3434, 3435, 1, 0, 0,
		0, 3435, 3436, 1, 0, 0, 0, 3436, 3437, 5, 82, 0, 0, 3437, 3439, 5, 1169,
		0, 0, 3438, 3440, 7, 6, 0, 0, 3439, 3438, 1, 0, 0, 0, 3439, 3440, 1, 0,
		0, 0, 3440, 3441, 1, 0, 0, 0, 3441, 3442, 5, 87, 0, 0, 3442, 3443, 5, 172,
		0, 0, 3443, 3447, 3, 556, 278, 0, 3444, 3445, 5, 26, 0, 0, 3445, 3446,
		5, 154, 0, 0, 3446, 3448, 3, 568, 284, 0, 3447, 3444, 1, 0, 0, 0, 3447,
		3448, 1, 0, 0, 0, 3448, 3455, 1, 0, 0, 0, 3449, 3450, 5, 603, 0, 0, 3450,
		3451, 5, 448, 0, 0, 3451, 3452, 5, 20, 0, 0, 3452, 3453, 5, 1147, 0, 0,
		3453, 3454, 5, 1169, 0, 0, 3454, 3456, 5, 1146, 0, 0, 3455, 3449, 1, 0,
		0, 0, 3455, 3456, 1, 0, 0, 0, 3456, 3461, 1, 0, 0, 0, 3457, 3458, 5, 78,
		0, 0, 3458, 3459, 3, 590, 295, 0, 3459, 3460, 7, 46, 0, 0, 3460, 3462,
		1, 0, 0, 0, 3461, 3457, 1, 0, 0, 0, 3461, 3462, 1, 0, 0, 0, 3462, 3474,
		1, 0, 0, 0, 3463, 3464, 5, 1154, 0, 0, 3464, 3469, 3, 218, 109, 0, 3465,
		3466, 5, 1156, 0, 0, 3466, 3468, 3, 218, 109, 0, 3467, 3465, 1, 0, 0, 0,
		3468, 3471, 1, 0, 0, 0, 3469, 3467, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0,
		3470, 3472, 1, 0, 0, 0, 3471, 3469, 1, 0, 0, 0, 3472, 3473, 5, 1155, 0,
		0, 3473, 3475, 1, 0, 0, 0, 3474, 3463, 1, 0, 0, 0, 3474, 3475, 1, 0, 0,
		0, 3475, 3485, 1, 0, 0, 0, 3476, 3477, 5, 154, 0, 0, 3477, 3482, 3, 216,
		108, 0, 3478, 3479, 5, 1156, 0, 0, 3479, 3481, 3, 216, 108, 0, 3480, 3478,
		1, 0, 0, 0, 3481, 3484, 1, 0, 0, 0, 3482, 3480, 1, 0, 0, 0, 3482, 3483,
		1, 0, 0, 0, 3483, 3486, 1, 0, 0, 0, 3484, 3482, 1, 0, 0, 0, 3485, 3476,
		1, 0, 0, 0, 3485, 3486, 1, 0, 0, 0, 3486, 205, 1, 0, 0, 0, 3487, 3489,
		5, 142, 0, 0, 3488, 3490, 7, 47, 0, 0, 3489, 3488, 1, 0, 0, 0, 3489, 3490,
		1, 0, 0, 0, 3490, 3492, 1, 0, 0, 0, 3491, 3493, 5, 87, 0, 0, 3492, 3491,
		1, 0, 0, 0, 3492, 3493, 1, 0, 0, 0, 3493, 3494, 1, 0, 0, 0, 3494, 3500,
		3, 556, 278, 0, 3495, 3496, 5, 129, 0, 0, 3496, 3497, 5, 1154, 0, 0, 3497,
		3498, 3, 616, 308, 0, 3498, 3499, 5, 1155, 0, 0, 3499, 3501, 1, 0, 0, 0,
		3500, 3495, 1, 0, 0, 0, 3500, 3501, 1, 0, 0, 0, 3501, 3518, 1, 0, 0, 0,
		3502, 3503, 5, 1154, 0, 0, 3503, 3504, 3, 616, 308, 0, 3504, 3505, 5, 1155,
		0, 0, 3505, 3507, 1, 0, 0, 0, 3506, 3502, 1, 0, 0, 0, 3506, 3507, 1, 0,
		0, 0, 3507, 3508, 1, 0, 0, 0, 3508, 3519, 3, 214, 107, 0, 3509, 3510, 5,
		154, 0, 0, 3510, 3515, 3, 216, 108, 0, 3511, 3512, 5, 1156, 0, 0, 3512,
		3514, 3, 216, 108, 0, 3513, 3511, 1, 0, 0, 0, 3514, 3517, 1, 0, 0, 0, 3515,
		3513, 1, 0, 0, 0, 3515, 3516, 1, 0, 0, 0, 3516, 3519, 1, 0, 0, 0, 3517,
		3515, 1, 0, 0, 0, 3518, 3506, 1, 0, 0, 0, 3518, 3509, 1, 0, 0, 0, 3519,
		207, 1, 0, 0, 0, 3520, 3522, 3, 258, 129, 0, 3521, 3523, 3, 220, 110, 0,
		3522, 3521, 1, 0, 0, 0, 3522, 3523, 1, 0, 0, 0, 3523, 3583, 1, 0, 0, 0,
		3524, 3526, 3, 254, 127, 0, 3525, 3527, 3, 220, 110, 0, 3526, 3525, 1,
		0, 0, 0, 3526, 3527, 1, 0, 0, 0, 3527, 3583, 1, 0, 0, 0, 3528, 3530, 3,
		260, 130, 0, 3529, 3531, 3, 264, 132, 0, 3530, 3529, 1, 0, 0, 0, 3531,
		3532, 1, 0, 0, 0, 3532, 3530, 1, 0, 0, 0, 3532, 3533, 1, 0, 0, 0, 3533,
		3542, 1, 0, 0, 0, 3534, 3536, 5, 180, 0, 0, 3535, 3537, 7, 48, 0, 0, 3536,
		3535, 1, 0, 0, 0, 3536, 3537, 1, 0, 0, 0, 3537, 3540, 1, 0, 0, 0, 3538,
		3541, 3, 258, 129, 0, 3539, 3541, 3, 254, 127, 0, 3540, 3538, 1, 0, 0,
		0, 3540, 3539, 1, 0, 0, 0, 3541, 3543, 1, 0, 0, 0, 3542, 3534, 1, 0, 0,
		0, 3542, 3543, 1, 0, 0, 0, 3543, 3545, 1, 0, 0, 0, 3544, 3546, 3, 238,
		119, 0, 3545, 3544, 1, 0, 0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 3548, 1,
		0, 0, 0, 3547, 3549, 3, 300, 150, 0, 3548, 3547, 1, 0, 0, 0, 3548, 3549,
		1, 0, 0, 0, 3549, 3551, 1, 0, 0, 0, 3550, 3552, 3, 220, 110, 0, 3551, 3550,
		1, 0, 0, 0, 3551, 3552, 1, 0, 0, 0, 3552, 3583, 1, 0, 0, 0, 3553, 3555,
		3, 256, 128, 0, 3554, 3556, 3, 262, 131, 0, 3555, 3554, 1, 0, 0, 0, 3556,
		3557, 1, 0, 0, 0, 3557, 3555, 1, 0, 0, 0, 3557, 3558, 1, 0, 0, 0, 3558,
		3564, 1, 0, 0, 0, 3559, 3561, 5, 180, 0, 0, 3560, 3562, 7, 48, 0, 0, 3561,
		3560, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 3562, 3563, 1, 0, 0, 0, 3563,
		3565, 3, 254, 127, 0, 3564, 3559, 1, 0, 0, 0, 3564, 3565, 1, 0, 0, 0, 3565,
		3567, 1, 0, 0, 0, 3566, 3568, 3, 238, 119, 0, 3567, 3566, 1, 0, 0, 0, 3567,
		3568, 1, 0, 0, 0, 3568, 3570, 1, 0, 0, 0, 3569, 3571, 3, 300, 150, 0, 3570,
		3569, 1, 0, 0, 0, 3570, 3571, 1, 0, 0, 0, 3571, 3573, 1, 0, 0, 0, 3572,
		3574, 3, 220, 110, 0, 3573, 3572, 1, 0, 0, 0, 3573, 3574, 1, 0, 0, 0, 3574,
		3583, 1, 0, 0, 0, 3575, 3578, 3, 260, 130, 0, 3576, 3577, 5, 1156, 0, 0,
		3577, 3579, 3, 266, 133, 0, 3578, 3576, 1, 0, 0, 0, 3579, 3580, 1, 0, 0,
		0, 3580, 3578, 1, 0, 0, 0, 3580, 3581, 1, 0, 0, 0, 3581, 3583, 1, 0, 0,
		0, 3582, 3520, 1, 0, 0, 0, 3582, 3524, 1, 0, 0, 0, 3582, 3528, 1, 0, 0,
		0, 3582, 3553, 1, 0, 0, 0, 3582, 3575, 1, 0, 0, 0, 3583, 209, 1, 0, 0,
		0, 3584, 3587, 3, 234, 117, 0, 3585, 3587, 3, 236, 118, 0, 3586, 3584,
		1, 0, 0, 0, 3586, 3585, 1, 0, 0, 0, 3587, 211, 1, 0, 0, 0, 3588, 3589,
		5, 188, 0, 0, 3589, 3591, 5, 1154, 0, 0, 3590, 3592, 3, 624, 312, 0, 3591,
		3590, 1, 0, 0, 0, 3591, 3592, 1, 0, 0, 0, 3592, 3593, 1, 0, 0, 0, 3593,
		3602, 5, 1155, 0, 0, 3594, 3595, 5, 1156, 0, 0, 3595, 3597, 5, 1154, 0,
		0, 3596, 3598, 3, 624, 312, 0, 3597, 3596, 1, 0, 0, 0, 3597, 3598, 1, 0,
		0, 0, 3598, 3599, 1, 0, 0, 0, 3599, 3601, 5, 1155, 0, 0, 3600, 3594, 1,
		0, 0, 0, 3601, 3604, 1, 0, 0, 0, 3602, 3600, 1, 0, 0, 0, 3602, 3603, 1,
		0, 0, 0, 3603, 213, 1, 0, 0, 0, 3604, 3602, 1, 0, 0, 0, 3605, 3624, 3,
		208, 104, 0, 3606, 3607, 7, 49, 0, 0, 3607, 3609, 5, 1154, 0, 0, 3608,
		3610, 3, 624, 312, 0, 3609, 3608, 1, 0, 0, 0, 3609, 3610, 1, 0, 0, 0, 3610,
		3611, 1, 0, 0, 0, 3611, 3620, 5, 1155, 0, 0, 3612, 3613, 5, 1156, 0, 0,
		3613, 3615, 5, 1154, 0, 0, 3614, 3616, 3, 624, 312, 0, 3615, 3614, 1, 0,
		0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617, 3619, 5, 1155,
		0, 0, 3618, 3612, 1, 0, 0, 0, 3619, 3622, 1, 0, 0, 0, 3620, 3618, 1, 0,
		0, 0, 3620, 3621, 1, 0, 0, 0, 3621, 3624, 1, 0, 0, 0, 3622, 3620, 1, 0,
		0, 0, 3623, 3605, 1, 0, 0, 0, 3623, 3606, 1, 0, 0, 0, 3624, 215, 1, 0,
		0, 0, 3625, 3626, 3, 560, 280, 0, 3626, 3629, 5, 1145, 0, 0, 3627, 3630,
		3, 688, 344, 0, 3628, 3630, 5, 43, 0, 0, 3629, 3627, 1, 0, 0, 0, 3629,
		3628, 1, 0, 0, 0, 3630, 217, 1, 0, 0, 0, 3631, 3634, 3, 584, 292, 0, 3632,
		3634, 5, 1182, 0, 0, 3633, 3631, 1, 0, 0, 0, 3633, 3632, 1, 0, 0, 0, 3634,
		219, 1, 0, 0, 0, 3635, 3636, 5, 65, 0, 0, 3636, 3642, 5, 184, 0, 0, 3637,
		3638, 5, 103, 0, 0, 3638, 3639, 5, 80, 0, 0, 3639, 3640, 5, 612, 0, 0,
		3640, 3642, 5, 512, 0, 0, 3641, 3635, 1, 0, 0, 0, 3641, 3637, 1, 0, 0,
		0, 3642, 3644, 1, 0, 0, 0, 3643, 3645, 3, 646, 323, 0, 3644, 3643, 1, 0,
		0, 0, 3644, 3645, 1, 0, 0, 0, 3645, 221, 1, 0, 0, 0, 3646, 3648, 5, 45,
		0, 0, 3647, 3649, 5, 106, 0, 0, 3648, 3647, 1, 0, 0, 0, 3648, 3649, 1,
		0, 0, 0, 3649, 3651, 1, 0, 0, 0, 3650, 3652, 5, 570, 0, 0, 3651, 3650,
		1, 0, 0, 0, 3651, 3652, 1, 0, 0, 0, 3652, 3654, 1, 0, 0, 0, 3653, 3655,
		5, 78, 0, 0, 3654, 3653, 1, 0, 0, 0, 3654, 3655, 1, 0, 0, 0, 3655, 3656,
		1, 0, 0, 0, 3656, 3657, 5, 68, 0, 0, 3657, 3663, 3, 556, 278, 0, 3658,
		3659, 5, 129, 0, 0, 3659, 3660, 5, 1154, 0, 0, 3660, 3661, 3, 616, 308,
		0, 3661, 3662, 5, 1155, 0, 0, 3662, 3664, 1, 0, 0, 0, 3663, 3658, 1, 0,
		0, 0, 3663, 3664, 1, 0, 0, 0, 3664, 3667, 1, 0, 0, 0, 3665, 3666, 5, 190,
		0, 0, 3666, 3668, 3, 688, 344, 0, 3667, 3665, 1, 0, 0, 0, 3667, 3668, 1,
		0, 0, 0, 3668, 3670, 1, 0, 0, 0, 3669, 3671, 3, 238, 119, 0, 3670, 3669,
		1, 0, 0, 0, 3670, 3671, 1, 0, 0, 0, 3671, 3674, 1, 0, 0, 0, 3672, 3673,
		5, 99, 0, 0, 3673, 3675, 3, 302, 151, 0, 3674, 3672, 1, 0, 0, 0, 3674,
		3675, 1, 0, 0, 0, 3675, 223, 1, 0, 0, 0, 3676, 3678, 5, 45, 0, 0, 3677,
		3679, 5, 106, 0, 0, 3678, 3677, 1, 0, 0, 0, 3678, 3679, 1, 0, 0, 0, 3679,
		3681, 1, 0, 0, 0, 3680, 3682, 5, 570, 0, 0, 3681, 3680, 1, 0, 0, 0, 3681,
		3682, 1, 0, 0, 0, 3682, 3684, 1, 0, 0, 0, 3683, 3685, 5, 78, 0, 0, 3684,
		3683, 1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685, 3725, 1, 0, 0, 0, 3686,
		3689, 3, 556, 278, 0, 3687, 3688, 5, 1153, 0, 0, 3688, 3690, 5, 1138, 0,
		0, 3689, 3687, 1, 0, 0, 0, 3689, 3690, 1, 0, 0, 0, 3690, 3699, 1, 0, 0,
		0, 3691, 3692, 5, 1156, 0, 0, 3692, 3695, 3, 556, 278, 0, 3693, 3694, 5,
		1153, 0, 0, 3694, 3696, 5, 1138, 0, 0, 3695, 3693, 1, 0, 0, 0, 3695, 3696,
		1, 0, 0, 0, 3696, 3698, 1, 0, 0, 0, 3697, 3691, 1, 0, 0, 0, 3698, 3701,
		1, 0, 0, 0, 3699, 3697, 1, 0, 0, 0, 3699, 3700, 1, 0, 0, 0, 3700, 3702,
		1, 0, 0, 0, 3701, 3699, 1, 0, 0, 0, 3702, 3703, 5, 68, 0, 0, 3703, 3704,
		3, 242, 121, 0, 3704, 3726, 1, 0, 0, 0, 3705, 3706, 5, 68, 0, 0, 3706,
		3709, 3, 556, 278, 0, 3707, 3708, 5, 1153, 0, 0, 3708, 3710, 5, 1138, 0,
		0, 3709, 3707, 1, 0, 0, 0, 3709, 3710, 1, 0, 0, 0, 3710, 3719, 1, 0, 0,
		0, 3711, 3712, 5, 1156, 0, 0, 3712, 3715, 3, 556, 278, 0, 3713, 3714, 5,
		1153, 0, 0, 3714, 3716, 5, 1138, 0, 0, 3715, 3713, 1, 0, 0, 0, 3715, 3716,
		1, 0, 0, 0, 3716, 3718, 1, 0, 0, 0, 3717, 3711, 1, 0, 0, 0, 3718, 3721,
		1, 0, 0, 0, 3719, 3717, 1, 0, 0, 0, 3719, 3720, 1, 0, 0, 0, 3720, 3722,
		1, 0, 0, 0, 3721, 3719, 1, 0, 0, 0, 3722, 3723, 5, 187, 0, 0, 3723, 3724,
		3, 242, 121, 0, 3724, 3726, 1, 0, 0, 0, 3725, 3686, 1, 0, 0, 0, 3725, 3705,
		1, 0, 0, 0, 3726, 3729, 1, 0, 0, 0, 3727, 3728, 5, 190, 0, 0, 3728, 3730,
		3, 688, 344, 0, 3729, 3727, 1, 0, 0, 0, 3729, 3730, 1, 0, 0, 0, 3730, 225,
		1, 0, 0, 0, 3731, 3732, 5, 442, 0, 0, 3732, 3733, 3, 556, 278, 0, 3733,
		3738, 5, 540, 0, 0, 3734, 3736, 5, 12, 0, 0, 3735, 3734, 1, 0, 0, 0, 3735,
		3736, 1, 0, 0, 0, 3736, 3737, 1, 0, 0, 0, 3737, 3739, 3, 584, 292, 0, 3738,
		3735, 1, 0, 0, 0, 3738, 3739, 1, 0, 0, 0, 3739, 227, 1, 0, 0, 0, 3740,
		3741, 5, 442, 0, 0, 3741, 3742, 3, 556, 278, 0, 3742, 3743, 5, 135, 0,
		0, 3743, 3750, 3, 584, 292, 0, 3744, 3745, 3, 696, 348, 0, 3745, 3746,
		5, 1154, 0, 0, 3746, 3747, 3, 626, 313, 0, 3747, 3748, 5, 1155, 0, 0, 3748,
		3751, 1, 0, 0, 0, 3749, 3751, 7, 50, 0, 0, 3750, 3744, 1, 0, 0, 0, 3750,
		3749, 1, 0, 0, 0, 3751, 3754, 1, 0, 0, 0, 3752, 3753, 5, 190, 0, 0, 3753,
		3755, 3, 688, 344, 0, 3754, 3752, 1, 0, 0, 0, 3754, 3755, 1, 0, 0, 0, 3755,
		3758, 1, 0, 0, 0, 3756, 3757, 5, 99, 0, 0, 3757, 3759, 3, 302, 151, 0,
		3758, 3756, 1, 0, 0, 0, 3758, 3759, 1, 0, 0, 0, 3759, 229, 1, 0, 0, 0,
		3760, 3761, 5, 442, 0, 0, 3761, 3762, 3, 556, 278, 0, 3762, 3763, 5, 135,
		0, 0, 3763, 3766, 7, 51, 0, 0, 3764, 3765, 5, 190, 0, 0, 3765, 3767, 3,
		688, 344, 0, 3766, 3764, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 3770,
		1, 0, 0, 0, 3768, 3769, 5, 99, 0, 0, 3769, 3771, 3, 302, 151, 0, 3770,
		3768, 1, 0, 0, 0, 3770, 3771, 1, 0, 0, 0, 3771, 231, 1, 0, 0, 0, 3772,
		3773, 5, 442, 0, 0, 3773, 3774, 3, 556, 278, 0, 3774, 3775, 5, 361, 0,
		0, 3775, 233, 1, 0, 0, 0, 3776, 3778, 5, 184, 0, 0, 3777, 3779, 5, 106,
		0, 0, 3778, 3777, 1, 0, 0, 0, 3778, 3779, 1, 0, 0, 0, 3779, 3781, 1, 0,
		0, 0, 3780, 3782, 5, 78, 0, 0, 3781, 3780, 1, 0, 0, 0, 3781, 3782, 1, 0,
		0, 0, 3782, 3783, 1, 0, 0, 0, 3783, 3788, 3, 556, 278, 0, 3784, 3786, 5,
		12, 0, 0, 3785, 3784, 1, 0, 0, 0, 3785, 3786, 1, 0, 0, 0, 3786, 3787, 1,
		0, 0, 0, 3787, 3789, 3, 584, 292, 0, 3788, 3785, 1, 0, 0, 0, 3788, 3789,
		1, 0, 0, 0, 3789, 3790, 1, 0, 0, 0, 3790, 3791, 5, 154, 0, 0, 3791, 3796,
		3, 216, 108, 0, 3792, 3793, 5, 1156, 0, 0, 3793, 3795, 3, 216, 108, 0,
		3794, 3792, 1, 0, 0, 0, 3795, 3798, 1, 0, 0, 0, 3796, 3794, 1, 0, 0, 0,
		3796, 3797, 1, 0, 0, 0, 3797, 3801, 1, 0, 0, 0, 3798, 3796, 1, 0, 0, 0,
		3799, 3800, 5, 190, 0, 0, 3800, 3802, 3, 688, 344, 0, 3801, 3799, 1, 0,
		0, 0, 3801, 3802, 1, 0, 0, 0, 3802, 3804, 1, 0, 0, 0, 3803, 3805, 3, 238,
		119, 0, 3804, 3803, 1, 0, 0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 3807, 1,
		0, 0, 0, 3806, 3808, 3, 300, 150, 0, 3807, 3806, 1, 0, 0, 0, 3807, 3808,
		1, 0, 0, 0, 3808, 235, 1, 0, 0, 0, 3809, 3811, 5, 184, 0, 0, 3810, 3812,
		5, 106, 0, 0, 3811, 3810, 1, 0, 0, 0, 3811, 3812, 1, 0, 0, 0, 3812, 3814,
		1, 0, 0, 0, 3813, 3815, 5, 78, 0, 0, 3814, 3813, 1, 0, 0, 0, 3814, 3815,
		1, 0, 0, 0, 3815, 3816, 1, 0, 0, 0, 3816, 3817, 3, 242, 121, 0, 3817, 3818,
		5, 154, 0, 0, 3818, 3823, 3, 216, 108, 0, 3819, 3820, 5, 1156, 0, 0, 3820,
		3822, 3, 216, 108, 0, 3821, 3819, 1, 0, 0, 0, 3822, 3825, 1, 0, 0, 0, 3823,
		3821, 1, 0, 0, 0, 3823, 3824, 1, 0, 0, 0, 3824, 3828, 1, 0, 0, 0, 3825,
		3823, 1, 0, 0, 0, 3826, 3827, 5, 190, 0, 0, 3827, 3829, 3, 688, 344, 0,
		3828, 3826, 1, 0, 0, 0, 3828, 3829, 1, 0, 0, 0, 3829, 237, 1, 0, 0, 0,
		3830, 3831, 5, 124, 0, 0, 3831, 3832, 5, 20, 0, 0, 3832, 3837, 3, 240,
		120, 0, 3833, 3834, 5, 1156, 0, 0, 3834, 3836, 3, 240, 120, 0, 3835, 3833,
		1, 0, 0, 0, 3836, 3839, 1, 0, 0, 0, 3837, 3835, 1, 0, 0, 0, 3837, 3838,
		1, 0, 0, 0, 3838, 239, 1, 0, 0, 0, 3839, 3837, 1, 0, 0, 0, 3840, 3842,
		3, 688, 344, 0, 3841, 3843, 7, 52, 0, 0, 3842, 3841, 1, 0, 0, 0, 3842,
		3843, 1, 0, 0, 0, 3843, 241, 1, 0, 0, 0, 3844, 3849, 3, 244, 122, 0, 3845,
		3846, 5, 1156, 0, 0, 3846, 3848, 3, 244, 122, 0, 3847, 3845, 1, 0, 0, 0,
		3848, 3851, 1, 0, 0, 0, 3849, 3847, 1, 0, 0, 0, 3849, 3850, 1, 0, 0, 0,
		3850, 243, 1, 0, 0, 0, 3851, 3849, 1, 0, 0, 0, 3852, 3856, 3, 246, 123,
		0, 3853, 3855, 3, 252, 126, 0, 3854, 3853, 1, 0, 0, 0, 3855, 3858, 1, 0,
		0, 0, 3856, 3854, 1, 0, 0, 0, 3856, 3857, 1, 0, 0, 0, 3857, 3871, 1, 0,
		0, 0, 3858, 3856, 1, 0, 0, 0, 3859, 3860, 5, 1154, 0, 0, 3860, 3864, 3,
		246, 123, 0, 3861, 3863, 3, 252, 126, 0, 3862, 3861, 1, 0, 0, 0, 3863,
		3866, 1, 0, 0, 0, 3864, 3862, 1, 0, 0, 0, 3864, 3865, 1, 0, 0, 0, 3865,
		3867, 1, 0, 0, 0, 3866, 3864, 1, 0, 0, 0, 3867, 3868, 5, 1155, 0, 0, 3868,
		3871, 1, 0, 0, 0, 3869, 3871, 3, 268, 134, 0, 3870, 3852, 1, 0, 0, 0, 3870,
		3859, 1, 0, 0, 0, 3870, 3869, 1, 0, 0, 0, 3871, 245, 1, 0, 0, 0, 3872,
		3878, 3, 556, 278, 0, 3873, 3874, 5, 129, 0, 0, 3874, 3875, 5, 1154, 0,
		0, 3875, 3876, 3, 616, 308, 0, 3876, 3877, 5, 1155, 0, 0, 3877, 3879, 1,
		0, 0, 0, 3878, 3873, 1, 0, 0, 0, 3878, 3879, 1, 0, 0, 0, 3879, 3884, 1,
		0, 0, 0, 3880, 3882, 5, 12, 0, 0, 3881, 3880, 1, 0, 0, 0, 3881, 3882, 1,
		0, 0, 0, 3882, 3883, 1, 0, 0, 0, 3883, 3885, 3, 584, 292, 0, 3884, 3881,
		1, 0, 0, 0, 3884, 3885, 1, 0, 0, 0, 3885, 3894, 1, 0, 0, 0, 3886, 3891,
		3, 248, 124, 0, 3887, 3888, 5, 1156, 0, 0, 3888, 3890, 3, 248, 124, 0,
		3889, 3887, 1, 0, 0, 0, 3890, 3893, 1, 0, 0, 0, 3891, 3889, 1, 0, 0, 0,
		3891, 3892, 1, 0, 0, 0, 3892, 3895, 1, 0, 0, 0, 3893, 3891, 1, 0, 0, 0,
		3894, 3886, 1, 0, 0, 0, 3894, 3895, 1, 0, 0, 0, 3895, 3913, 1, 0, 0, 0,
		3896, 3902, 3, 208, 104, 0, 3897, 3898, 5, 1154, 0, 0, 3898, 3899, 3, 208,
		104, 0, 3899, 3900, 5, 1155, 0, 0, 3900, 3902, 1, 0, 0, 0, 3901, 3896,
		1, 0, 0, 0, 3901, 3897, 1, 0, 0, 0, 3902, 3904, 1, 0, 0, 0, 3903, 3905,
		5, 12, 0, 0, 3904, 3903, 1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 3906,
		1, 0, 0, 0, 3906, 3907, 3, 584, 292, 0, 3907, 3913, 1, 0, 0, 0, 3908, 3909,
		5, 1154, 0, 0, 3909, 3910, 3, 242, 121, 0, 3910, 3911, 5, 1155, 0, 0, 3911,
		3913, 1, 0, 0, 0, 3912, 3872, 1, 0, 0, 0, 3912, 3901, 1, 0, 0, 0, 3912,
		3908, 1, 0, 0, 0, 3913, 247, 1, 0, 0, 0, 3914, 3915, 7, 53, 0, 0, 3915,
		3918, 7, 23, 0, 0, 3916, 3917, 5, 65, 0, 0, 3917, 3919, 3, 250, 125, 0,
		3918, 3916, 1, 0, 0, 0, 3918, 3919, 1, 0, 0, 0, 3919, 3920, 1, 0, 0, 0,
		3920, 3921, 5, 1154, 0, 0, 3921, 3922, 3, 616, 308, 0, 3922, 3923, 5, 1155,
		0, 0, 3923, 249, 1, 0, 0, 0, 3924, 3930, 5, 90, 0, 0, 3925, 3926, 5, 124,
		0, 0, 3926, 3930, 5, 20, 0, 0, 3927, 3928, 5, 73, 0, 0, 3928, 3930, 5,
		20, 0, 0, 3929, 3924, 1, 0, 0, 0, 3929, 3925, 1, 0, 0, 0, 3929, 3927, 1,
		0, 0, 0, 3930, 251, 1, 0, 0, 0, 3931, 3933, 7, 54, 0, 0, 3932, 3931, 1,
		0, 0, 0, 3932, 3933, 1, 0, 0, 0, 3933, 3934, 1, 0, 0, 0, 3934, 3936, 5,
		90, 0, 0, 3935, 3937, 5, 94, 0, 0, 3936, 3935, 1, 0, 0, 0, 3936, 3937,
		1, 0, 0, 0, 3937, 3938, 1, 0, 0, 0, 3938, 3946, 3, 246, 123, 0, 3939, 3940,
		5, 118, 0, 0, 3940, 3947, 3, 688, 344, 0, 3941, 3942, 5, 187, 0, 0, 3942,
		3943, 5, 1154, 0, 0, 3943, 3944, 3, 616, 308, 0, 3944, 3945, 5, 1155, 0,
		0, 3945, 3947, 1, 0, 0, 0, 3946, 3939, 1, 0, 0, 0, 3946, 3941, 1, 0, 0,
		0, 3946, 3947, 1, 0, 0, 0, 3947, 3982, 1, 0, 0, 0, 3948, 3949, 5, 171,
		0, 0, 3949, 3952, 3, 246, 123, 0, 3950, 3951, 5, 118, 0, 0, 3951, 3953,
		3, 688, 344, 0, 3952, 3950, 1, 0, 0, 0, 3952, 3953, 1, 0, 0, 0, 3953, 3982,
		1, 0, 0, 0, 3954, 3956, 7, 55, 0, 0, 3955, 3957, 5, 126, 0, 0, 3956, 3955,
		1, 0, 0, 0, 3956, 3957, 1, 0, 0, 0, 3957, 3958, 1, 0, 0, 0, 3958, 3960,
		5, 90, 0, 0, 3959, 3961, 5, 94, 0, 0, 3960, 3959, 1, 0, 0, 0, 3960, 3961,
		1, 0, 0, 0, 3961, 3962, 1, 0, 0, 0, 3962, 3970, 3, 246, 123, 0, 3963, 3964,
		5, 118, 0, 0, 3964, 3971, 3, 688, 344, 0, 3965, 3966, 5, 187, 0, 0, 3966,
		3967, 5, 1154, 0, 0, 3967, 3968, 3, 616, 308, 0, 3968, 3969, 5, 1155, 0,
		0, 3969, 3971, 1, 0, 0, 0, 3970, 3963, 1, 0, 0, 0, 3970, 3965, 1, 0, 0,
		0, 3971, 3982, 1, 0, 0, 0, 3972, 3977, 5, 113, 0, 0, 3973, 3975, 7, 55,
		0, 0, 3974, 3976, 5, 126, 0, 0, 3975, 3974, 1, 0, 0, 0, 3975, 3976, 1,
		0, 0, 0, 3976, 3978, 1, 0, 0, 0, 3977, 3973, 1, 0, 0, 0, 3977, 3978, 1,
		0, 0, 0, 3978, 3979, 1, 0, 0, 0, 3979, 3980, 5, 90, 0, 0, 3980, 3982, 3,
		246, 123, 0, 3981, 3932, 1, 0, 0, 0, 3981, 3948, 1, 0, 0, 0, 3981, 3954,
		1, 0, 0, 0, 3981, 3972, 1, 0, 0, 0, 3982, 253, 1, 0, 0, 0, 3983, 3984,
		5, 1154, 0, 0, 3984, 3985, 3, 258, 129, 0, 3985, 3986, 5, 1155, 0, 0, 3986,
		3992, 1, 0, 0, 0, 3987, 3988, 5, 1154, 0, 0, 3988, 3989, 3, 254, 127, 0,
		3989, 3990, 5, 1155, 0, 0, 3990, 3992, 1, 0, 0, 0, 3991, 3983, 1, 0, 0,
		0, 3991, 3987, 1, 0, 0, 0, 3992, 255, 1, 0, 0, 0, 3993, 3994, 5, 1154,
		0, 0, 3994, 3995, 3, 260, 130, 0, 3995, 3996, 5, 1155, 0, 0, 3996, 4002,
		1, 0, 0, 0, 3997, 3998, 5, 1154, 0, 0, 3998, 3999, 3, 256, 128, 0, 3999,
		4000, 5, 1155, 0, 0, 4000, 4002, 1, 0, 0, 0, 4001, 3993, 1, 0, 0, 0, 4001,
		3997, 1, 0, 0, 0, 4002, 257, 1, 0, 0, 0, 4003, 4007, 5, 153, 0, 0, 4004,
		4006, 3, 278, 139, 0, 4005, 4004, 1, 0, 0, 0, 4006, 4009, 1, 0, 0, 0, 4007,
		4005, 1, 0, 0, 0, 4007, 4008, 1, 0, 0, 0, 4008, 4010, 1, 0, 0, 0, 4009,
		4007, 1, 0, 0, 0, 4010, 4012, 3, 280, 140, 0, 4011, 4013, 3, 284, 142,
		0, 4012, 4011, 1, 0, 0, 0, 4012, 4013, 1, 0, 0, 0, 4013, 4015, 1, 0, 0,
		0, 4014, 4016, 3, 290, 145, 0, 4015, 4014, 1, 0, 0, 0, 4015, 4016, 1, 0,
		0, 0, 4016, 4018, 1, 0, 0, 0, 4017, 4019, 3, 292, 146, 0, 4018, 4017, 1,
		0, 0, 0, 4018, 4019, 1, 0, 0, 0, 4019, 4021, 1, 0, 0, 0, 4020, 4022, 3,
		294, 147, 0, 4021, 4020, 1, 0, 0, 0, 4021, 4022, 1, 0, 0, 0, 4022, 4024,
		1, 0, 0, 0, 4023, 4025, 3, 296, 148, 0, 4024, 4023, 1, 0, 0, 0, 4024, 4025,
		1, 0, 0, 0, 4025, 4027, 1, 0, 0, 0, 4026, 4028, 3, 238, 119, 0, 4027, 4026,
		1, 0, 0, 0, 4027, 4028, 1, 0, 0, 0, 4028, 4030, 1, 0, 0, 0, 4029, 4031,
		3, 300, 150, 0, 4030, 4029, 1, 0, 0, 0, 4030, 4031, 1, 0, 0, 0, 4031, 4062,
		1, 0, 0, 0, 4032, 4036, 5, 153, 0, 0, 4033, 4035, 3, 278, 139, 0, 4034,
		4033, 1, 0, 0, 0, 4035, 4038, 1, 0, 0, 0, 4036, 4034, 1, 0, 0, 0, 4036,
		4037, 1, 0, 0, 0, 4037, 4039, 1, 0, 0, 0, 4038, 4036, 1, 0, 0, 0, 4039,
		4041, 3, 280, 140, 0, 4040, 4042, 3, 290, 145, 0, 4041, 4040, 1, 0, 0,
		0, 4041, 4042, 1, 0, 0, 0, 4042, 4044, 1, 0, 0, 0, 4043, 4045, 3, 292,
		146, 0, 4044, 4043, 1, 0, 0, 0, 4044, 4045, 1, 0, 0, 0, 4045, 4047, 1,
		0, 0, 0, 4046, 4048, 3, 294, 147, 0, 4047, 4046, 1, 0, 0, 0, 4047, 4048,
		1, 0, 0, 0, 4048, 4050, 1, 0, 0, 0, 4049, 4051, 3, 296, 148, 0, 4050, 4049,
		1, 0, 0, 0, 4050, 4051, 1, 0, 0, 0, 4051, 4053, 1, 0, 0, 0, 4052, 4054,
		3, 238, 119, 0, 4053, 4052, 1, 0, 0, 0, 4053, 4054, 1, 0, 0, 0, 4054, 4056,
		1, 0, 0, 0, 4055, 4057, 3, 300, 150, 0, 4056, 4055, 1, 0, 0, 0, 4056, 4057,
		1, 0, 0, 0, 4057, 4059, 1, 0, 0, 0, 4058, 4060, 3, 284, 142, 0, 4059, 4058,
		1, 0, 0, 0, 4059, 4060, 1, 0, 0, 0, 4060, 4062, 1, 0, 0, 0, 4061, 4003,
		1, 0, 0, 0, 4061, 4032, 1, 0, 0, 0, 4062, 259, 1, 0, 0, 0, 4063, 4067,
		5, 153, 0, 0, 4064, 4066, 3, 278, 139, 0, 4065, 4064, 1, 0, 0, 0, 4066,
		4069, 1, 0, 0, 0, 4067, 4065, 1, 0, 0, 0, 4067, 4068, 1, 0, 0, 0, 4068,
		4070, 1, 0, 0, 0, 4069, 4067, 1, 0, 0, 0, 4070, 4072, 3, 280, 140, 0, 4071,
		4073, 3, 290, 145, 0, 4072, 4071, 1, 0, 0, 0, 4072, 4073, 1, 0, 0, 0, 4073,
		4075, 1, 0, 0, 0, 4074, 4076, 3, 292, 146, 0, 4075, 4074, 1, 0, 0, 0, 4075,
		4076, 1, 0, 0, 0, 4076, 4078, 1, 0, 0, 0, 4077, 4079, 3, 294, 147, 0, 4078,
		4077, 1, 0, 0, 0, 4078, 4079, 1, 0, 0, 0, 4079, 4081, 1, 0, 0, 0, 4080,
		4082, 3, 296, 148, 0, 4081, 4080, 1, 0, 0, 0, 4081, 4082, 1, 0, 0, 0, 4082,
		4084, 1, 0, 0, 0, 4083, 4085, 3, 238, 119, 0, 4084, 4083, 1, 0, 0, 0, 4084,
		4085, 1, 0, 0, 0, 4085, 4087, 1, 0, 0, 0, 4086, 4088, 3, 300, 150, 0, 4087,
		4086, 1, 0, 0, 0, 4087, 4088, 1, 0, 0, 0, 4088, 261, 1, 0, 0, 0, 4089,
		4091, 5, 180, 0, 0, 4090, 4092, 7, 48, 0, 0, 4091, 4090, 1, 0, 0, 0, 4091,
		4092, 1, 0, 0, 0, 4092, 4093, 1, 0, 0, 0, 4093, 4094, 3, 256, 128, 0, 4094,
		263, 1, 0, 0, 0, 4095, 4097, 5, 180, 0, 0, 4096, 4098, 7, 48, 0, 0, 4097,
		4096, 1, 0, 0, 0, 4097, 4098, 1, 0, 0, 0, 4098, 4101, 1, 0, 0, 0, 4099,
		4102, 3, 260, 130, 0, 4100, 4102, 3, 256, 128, 0, 4101, 4099, 1, 0, 0,
		0, 4101, 4100, 1, 0, 0, 0, 4102, 265, 1, 0, 0, 0, 4103, 4118, 5, 94, 0,
		0, 4104, 4119, 3, 260, 130, 0, 4105, 4119, 3, 256, 128, 0, 4106, 4109,
		5, 1154, 0, 0, 4107, 4110, 3, 260, 130, 0, 4108, 4110, 3, 256, 128, 0,
		4109, 4107, 1, 0, 0, 0, 4109, 4108, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0,
		4111, 4116, 5, 1155, 0, 0, 4112, 4114, 5, 12, 0, 0, 4113, 4112, 1, 0, 0,
		0, 4113, 4114, 1, 0, 0, 0, 4114, 4115, 1, 0, 0, 0, 4115, 4117, 3, 584,
		292, 0, 4116, 4113, 1, 0, 0, 0, 4116, 4117, 1, 0, 0, 0, 4117, 4119, 1,
		0, 0, 0, 4118, 4104, 1, 0, 0, 0, 4118, 4105, 1, 0, 0, 0, 4118, 4106, 1,
		0, 0, 0, 4119, 267, 1, 0, 0, 0, 4120, 4121, 5, 278, 0, 0, 4121, 4122, 5,
		1154, 0, 0, 4122, 4123, 5, 1169, 0, 0, 4123, 4124, 5, 1156, 0, 0, 4124,
		4125, 5, 1169, 0, 0, 4125, 4126, 5, 365, 0, 0, 4126, 4127, 5, 1154, 0,
		0, 4127, 4128, 3, 270, 135, 0, 4128, 4129, 5, 1155, 0, 0, 4129, 4134, 5,
		1155, 0, 0, 4130, 4132, 5, 12, 0, 0, 4131, 4130, 1, 0, 0, 0, 4131, 4132,
		1, 0, 0, 0, 4132, 4133, 1, 0, 0, 0, 4133, 4135, 3, 584, 292, 0, 4134, 4131,
		1, 0, 0, 0, 4134, 4135, 1, 0, 0, 0, 4135, 269, 1, 0, 0, 0, 4136, 4141,
		3, 272, 136, 0, 4137, 4138, 5, 1156, 0, 0, 4138, 4140, 3, 272, 136, 0,
		4139, 4137, 1, 0, 0, 0, 4140, 4143, 1, 0, 0, 0, 4141, 4139, 1, 0, 0, 0,
		4141, 4142, 1, 0, 0, 0, 4142, 271, 1, 0, 0, 0, 4143, 4141, 1, 0, 0, 0,
		4144, 4161, 3, 560, 280, 0, 4145, 4146, 5, 65, 0, 0, 4146, 4162, 5, 284,
		0, 0, 4147, 4159, 3, 604, 302, 0, 4148, 4149, 5, 285, 0, 0, 4149, 4151,
		5, 1169, 0, 0, 4150, 4152, 3, 274, 137, 0, 4151, 4150, 1, 0, 0, 0, 4151,
		4152, 1, 0, 0, 0, 4152, 4154, 1, 0, 0, 0, 4153, 4155, 3, 276, 138, 0, 4154,
		4153, 1, 0, 0, 0, 4154, 4155, 1, 0, 0, 0, 4155, 4160, 1, 0, 0, 0, 4156,
		4157, 5, 60, 0, 0, 4157, 4158, 5, 285, 0, 0, 4158, 4160, 5, 1169, 0, 0,
		4159, 4148, 1, 0, 0, 0, 4159, 4156, 1, 0, 0, 0, 4160, 4162, 1, 0, 0, 0,
		4161, 4145, 1, 0, 0, 0, 4161, 4147, 1, 0, 0, 0, 4162, 4174, 1, 0, 0, 0,
		4163, 4165, 5, 283, 0, 0, 4164, 4166, 5, 285, 0, 0, 4165, 4164, 1, 0, 0,
		0, 4165, 4166, 1, 0, 0, 0, 4166, 4167, 1, 0, 0, 0, 4167, 4168, 5, 1169,
		0, 0, 4168, 4169, 5, 365, 0, 0, 4169, 4170, 5, 1154, 0, 0, 4170, 4171,
		3, 270, 135, 0, 4171, 4172, 5, 1155, 0, 0, 4172, 4174, 1, 0, 0, 0, 4173,
		4144, 1, 0, 0, 0, 4173, 4163, 1, 0, 0, 0, 4174, 273, 1, 0, 0, 0, 4175,
		4180, 5, 116, 0, 0, 4176, 4180, 5, 411, 0, 0, 4177, 4178, 5, 43, 0, 0,
		4178, 4180, 3, 632, 316, 0, 4179, 4175, 1, 0, 0, 0, 4179, 4176, 1, 0, 0,
		0, 4179, 4177, 1, 0, 0, 0, 4180, 4181, 1, 0, 0, 0, 4181, 4182, 5, 118,
		0, 0, 4182, 4183, 5, 56, 0, 0, 4183, 275, 1, 0, 0, 0, 4184, 4189, 5, 116,
		0, 0, 4185, 4189, 5, 411, 0, 0, 4186, 4187, 5, 43, 0, 0, 4187, 4189, 3,
		632, 316, 0, 4188, 4184, 1, 0, 0, 0, 4188, 4185, 1, 0, 0, 0, 4188, 4186,
		1, 0, 0, 0, 4189, 4190, 1, 0, 0, 0, 4190, 4191, 5, 118, 0, 0, 4191, 4192,
		5, 411, 0, 0, 4192, 277, 1, 0, 0, 0, 4193, 4202, 7, 56, 0, 0, 4194, 4202,
		5, 75, 0, 0, 4195, 4202, 5, 171, 0, 0, 4196, 4202, 5, 166, 0, 0, 4197,
		4202, 5, 164, 0, 0, 4198, 4202, 5, 628, 0, 0, 4199, 4202, 7, 57, 0, 0,
		4200, 4202, 5, 165, 0, 0, 4201, 4193, 1, 0, 0, 0, 4201, 4194, 1, 0, 0,
		0, 4201, 4195, 1, 0, 0, 0, 4201, 4196, 1, 0, 0, 0, 4201, 4197, 1, 0, 0,
		0, 4201, 4198, 1, 0, 0, 0, 4201, 4199, 1, 0, 0, 0, 4201, 4200, 1, 0, 0,
		0, 4202, 279, 1, 0, 0, 0, 4203, 4206, 5, 1138, 0, 0, 4204, 4206, 3, 282,
		141, 0, 4205, 4203, 1, 0, 0, 0, 4205, 4204, 1, 0, 0, 0, 4206, 4211, 1,
		0, 0, 0, 4207, 4208, 5, 1156, 0, 0, 4208, 4210, 3, 282, 141, 0, 4209, 4207,
		1, 0, 0, 0, 4210, 4213, 1, 0, 0, 0, 4211, 4209, 1, 0, 0, 0, 4211, 4212,
		1, 0, 0, 0, 4212, 281, 1, 0, 0, 0, 4213, 4211, 1, 0, 0, 0, 4214, 4215,
		3, 554, 277, 0, 4215, 4216, 5, 1153, 0, 0, 4216, 4217, 5, 1138, 0, 0, 4217,
		4244, 1, 0, 0, 0, 4218, 4223, 3, 560, 280, 0, 4219, 4221, 5, 12, 0, 0,
		4220, 4219, 1, 0, 0, 0, 4220, 4221, 1, 0, 0, 0, 4221, 4222, 1, 0, 0, 0,
		4222, 4224, 3, 584, 292, 0, 4223, 4220, 1, 0, 0, 0, 4223, 4224, 1, 0, 0,
		0, 4224, 4244, 1, 0, 0, 0, 4225, 4230, 3, 648, 324, 0, 4226, 4228, 5, 12,
		0, 0, 4227, 4226, 1, 0, 0, 0, 4227, 4228, 1, 0, 0, 0, 4228, 4229, 1, 0,
		0, 0, 4229, 4231, 3, 584, 292, 0, 4230, 4227, 1, 0, 0, 0, 4230, 4231, 1,
		0, 0, 0, 4231, 4244, 1, 0, 0, 0, 4232, 4233, 5, 1182, 0, 0, 4233, 4235,
		5, 1129, 0, 0, 4234, 4232, 1, 0, 0, 0, 4234, 4235, 1, 0, 0, 0, 4235, 4236,
		1, 0, 0, 0, 4236, 4241, 3, 688, 344, 0, 4237, 4239, 5, 12, 0, 0, 4238,
		4237, 1, 0, 0, 0, 4238, 4239, 1, 0, 0, 0, 4239, 4240, 1, 0, 0, 0, 4240,
		4242, 3, 584, 292, 0, 4241, 4238, 1, 0, 0, 0, 4241, 4242, 1, 0, 0, 0, 4242,
		4244, 1, 0, 0, 0, 4243, 4214, 1, 0, 0, 0, 4243, 4218, 1, 0, 0, 0, 4243,
		4225, 1, 0, 0, 0, 4243, 4234, 1, 0, 0, 0, 4244, 283, 1, 0, 0, 0, 4245,
		4246, 5, 87, 0, 0, 4246, 4251, 3, 218, 109, 0, 4247, 4248, 5, 1156, 0,
		0, 4248, 4250, 3, 218, 109, 0, 4249, 4247, 1, 0, 0, 0, 4250, 4253, 1, 0,
		0, 0, 4251, 4249, 1, 0, 0, 0, 4251, 4252, 1, 0, 0, 0, 4252, 4282, 1, 0,
		0, 0, 4253, 4251, 1, 0, 0, 0, 4254, 4255, 5, 87, 0, 0, 4255, 4256, 5, 400,
		0, 0, 4256, 4282, 5, 1169, 0, 0, 4257, 4258, 5, 87, 0, 0, 4258, 4259, 5,
		127, 0, 0, 4259, 4263, 5, 1169, 0, 0, 4260, 4261, 5, 26, 0, 0, 4261, 4262,
		5, 154, 0, 0, 4262, 4264, 3, 568, 284, 0, 4263, 4260, 1, 0, 0, 0, 4263,
		4264, 1, 0, 0, 0, 4264, 4271, 1, 0, 0, 0, 4265, 4267, 7, 45, 0, 0, 4266,
		4268, 3, 286, 143, 0, 4267, 4266, 1, 0, 0, 0, 4268, 4269, 1, 0, 0, 0, 4269,
		4267, 1, 0, 0, 0, 4269, 4270, 1, 0, 0, 0, 4270, 4272, 1, 0, 0, 0, 4271,
		4265, 1, 0, 0, 0, 4271, 4272, 1, 0, 0, 0, 4272, 4279, 1, 0, 0, 0, 4273,
		4275, 5, 101, 0, 0, 4274, 4276, 3, 288, 144, 0, 4275, 4274, 1, 0, 0, 0,
		4276, 4277, 1, 0, 0, 0, 4277, 4275, 1, 0, 0, 0, 4277, 4278, 1, 0, 0, 0,
		4278, 4280, 1, 0, 0, 0, 4279, 4273, 1, 0, 0, 0, 4279, 4280, 1, 0, 0, 0,
		4280, 4282, 1, 0, 0, 0, 4281, 4245, 1, 0, 0, 0, 4281, 4254, 1, 0, 0, 0,
		4281, 4257, 1, 0, 0, 0, 4282, 285, 1, 0, 0, 0, 4283, 4284, 5, 173, 0, 0,
		4284, 4285, 5, 20, 0, 0, 4285, 4296, 5, 1169, 0, 0, 4286, 4288, 5, 122,
		0, 0, 4287, 4286, 1, 0, 0, 0, 4287, 4288, 1, 0, 0, 0, 4288, 4289, 1, 0,
		0, 0, 4289, 4290, 5, 57, 0, 0, 4290, 4291, 5, 20, 0, 0, 4291, 4296, 5,
		1169, 0, 0, 4292, 4293, 5, 58, 0, 0, 4293, 4294, 5, 20, 0, 0, 4294, 4296,
		5, 1169, 0, 0, 4295, 4283, 1, 0, 0, 0, 4295, 4287, 1, 0, 0, 0, 4295, 4292,
		1, 0, 0, 0, 4296, 287, 1, 0, 0, 0, 4297, 4298, 5, 169, 0, 0, 4298, 4299,
		5, 20, 0, 0, 4299, 4304, 5, 1169, 0, 0, 4300, 4301, 5, 173, 0, 0, 4301,
		4302, 5, 20, 0, 0, 4302, 4304, 5, 1169, 0, 0, 4303, 4297, 1, 0, 0, 0, 4303,
		4300, 1, 0, 0, 0, 4304, 289, 1, 0, 0, 0, 4305, 4306, 5, 68, 0, 0, 4306,
		4308, 3, 242, 121, 0, 4307, 4305, 1, 0, 0, 0, 4307, 4308, 1, 0, 0, 0, 4308,
		4311, 1, 0, 0, 0, 4309, 4310, 5, 190, 0, 0, 4310, 4312, 3, 688, 344, 0,
		4311, 4309, 1, 0, 0, 0, 4311, 4312, 1, 0, 0, 0, 4312, 291, 1, 0, 0, 0,
		4313, 4314, 5, 73, 0, 0, 4314, 4315, 5, 20, 0, 0, 4315, 4320, 3, 298, 149,
		0, 4316, 4317, 5, 1156, 0, 0, 4317, 4319, 3, 298, 149, 0, 4318, 4316, 1,
		0, 0, 0, 4319, 4322, 1, 0, 0, 0, 4320, 4318, 1, 0, 0, 0, 4320, 4321, 1,
		0, 0, 0, 4321, 4325, 1, 0, 0, 0, 4322, 4320, 1, 0, 0, 0, 4323, 4324, 5,
		192, 0, 0, 4324, 4326, 5, 600, 0, 0, 4325, 4323, 1, 0, 0, 0, 4325, 4326,
		1, 0, 0, 0, 4326, 293, 1, 0, 0, 0, 4327, 4328, 5, 74, 0, 0, 4328, 4329,
		3, 688, 344, 0, 4329, 295, 1, 0, 0, 0, 4330, 4331, 5, 680, 0, 0, 4331,
		4332, 3, 666, 333, 0, 4332, 4333, 5, 12, 0, 0, 4333, 4334, 5, 1154, 0,
		0, 4334, 4335, 3, 664, 332, 0, 4335, 4345, 5, 1155, 0, 0, 4336, 4337, 5,
		1156, 0, 0, 4337, 4338, 3, 666, 333, 0, 4338, 4339, 5, 12, 0, 0, 4339,
		4340, 5, 1154, 0, 0, 4340, 4341, 3, 664, 332, 0, 4341, 4342, 5, 1155, 0,
		0, 4342, 4344, 1, 0, 0, 0, 4343, 4336, 1, 0, 0, 0, 4344, 4347, 1, 0, 0,
		0, 4345, 4343, 1, 0, 0, 0, 4345, 4346, 1, 0, 0, 0, 4346, 297, 1, 0, 0,
		0, 4347, 4345, 1, 0, 0, 0, 4348, 4350, 3, 688, 344, 0, 4349, 4351, 7, 52,
		0, 0, 4350, 4349, 1, 0, 0, 0, 4350, 4351, 1, 0, 0, 0, 4351, 299, 1, 0,
		0, 0, 4352, 4363, 5, 99, 0, 0, 4353, 4354, 3, 302, 151, 0, 4354, 4355,
		5, 1156, 0, 0, 4355, 4357, 1, 0, 0, 0, 4356, 4353, 1, 0, 0, 0, 4356, 4357,
		1, 0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 4364, 3, 302, 151, 0, 4359, 4360,
		3, 302, 151, 0, 4360, 4361, 5, 533, 0, 0, 4361, 4362, 3, 302, 151, 0, 4362,
		4364, 1, 0, 0, 0, 4363, 4356, 1, 0, 0, 0, 4363, 4359, 1, 0, 0, 0, 4364,
		301, 1, 0, 0, 0, 4365, 4369, 3, 590, 295, 0, 4366, 4369, 3, 566, 283, 0,
		4367, 4369, 3, 586, 293, 0, 4368, 4365, 1, 0, 0, 0, 4368, 4366, 1, 0, 0,
		0, 4368, 4367, 1, 0, 0, 0, 4369, 303, 1, 0, 0, 0, 4370, 4371, 5, 632, 0,
		0, 4371, 4380, 5, 656, 0, 0, 4372, 4377, 3, 326, 163, 0, 4373, 4374, 5,
		1156, 0, 0, 4374, 4376, 3, 326, 163, 0, 4375, 4373, 1, 0, 0, 0, 4376, 4379,
		1, 0, 0, 0, 4377, 4375, 1, 0, 0, 0, 4377, 4378, 1, 0, 0, 0, 4378, 4381,
		1, 0, 0, 0, 4379, 4377, 1, 0, 0, 0, 4380, 4372, 1, 0, 0, 0, 4380, 4381,
		1, 0, 0, 0, 4381, 305, 1, 0, 0, 0, 4382, 4384, 5, 344, 0, 0, 4383, 4385,
		5, 682, 0, 0, 4384, 4383, 1, 0, 0, 0, 4384, 4385, 1, 0, 0, 0, 4385, 307,
		1, 0, 0, 0, 4386, 4388, 5, 369, 0, 0, 4387, 4389, 5, 682, 0, 0, 4388, 4387,
		1, 0, 0, 0, 4388, 4389, 1, 0, 0, 0, 4389, 4395, 1, 0, 0, 0, 4390, 4392,
		5, 10, 0, 0, 4391, 4393, 5, 522, 0, 0, 4392, 4391, 1, 0, 0, 0, 4392, 4393,
		1, 0, 0, 0, 4393, 4394, 1, 0, 0, 0, 4394, 4396, 5, 353, 0, 0, 4395, 4390,
		1, 0, 0, 0, 4395, 4396, 1, 0, 0, 0, 4396, 4401, 1, 0, 0, 0, 4397, 4399,
		5, 522, 0, 0, 4398, 4397, 1, 0, 0, 0, 4398, 4399, 1, 0, 0, 0, 4399, 4400,
		1, 0, 0, 0, 4400, 4402, 5, 139, 0, 0, 4401, 4398, 1, 0, 0, 0, 4401, 4402,
		1, 0, 0, 0, 4402, 309, 1, 0, 0, 0, 4403, 4405, 5, 599, 0, 0, 4404, 4406,
		5, 682, 0, 0, 4405, 4404, 1, 0, 0, 0, 4405, 4406, 1, 0, 0, 0, 4406, 4412,
		1, 0, 0, 0, 4407, 4409, 5, 10, 0, 0, 4408, 4410, 5, 522, 0, 0, 4409, 4408,
		1, 0, 0, 0, 4409, 4410, 1, 0, 0, 0, 4410, 4411, 1, 0, 0, 0, 4411, 4413,
		5, 353, 0, 0, 4412, 4407, 1, 0, 0, 0, 4412, 4413, 1, 0, 0, 0, 4413, 4418,
		1, 0, 0, 0, 4414, 4416, 5, 522, 0, 0, 4415, 4414, 1, 0, 0, 0, 4415, 4416,
		1, 0, 0, 0, 4416, 4417, 1, 0, 0, 0, 4417, 4419, 5, 139, 0, 0, 4418, 4415,
		1, 0, 0, 0, 4418, 4419, 1, 0, 0, 0, 4419, 311, 1, 0, 0, 0, 4420, 4421,
		5, 606, 0, 0, 4421, 4422, 3, 584, 292, 0, 4422, 313, 1, 0, 0, 0, 4423,
		4425, 5, 599, 0, 0, 4424, 4426, 5, 682, 0, 0, 4425, 4424, 1, 0, 0, 0, 4425,
		4426, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427, 4429, 5, 175, 0, 0, 4428,
		4430, 5, 606, 0, 0, 4429, 4428, 1, 0, 0, 0, 4429, 4430, 1, 0, 0, 0, 4430,
		4431, 1, 0, 0, 0, 4431, 4432, 3, 584, 292, 0, 4432, 315, 1, 0, 0, 0, 4433,
		4434, 5, 139, 0, 0, 4434, 4435, 5, 606, 0, 0, 4435, 4436, 3, 584, 292,
		0, 4436, 317, 1, 0, 0, 0, 4437, 4438, 5, 103, 0, 0, 4438, 4439, 7, 58,
		0, 0, 4439, 4444, 3, 328, 164, 0, 4440, 4441, 5, 1156, 0, 0, 4441, 4443,
		3, 328, 164, 0, 4442, 4440, 1, 0, 0, 0, 4443, 4446, 1, 0, 0, 0, 4444, 4442,
		1, 0, 0, 0, 4444, 4445, 1, 0, 0, 0, 4445, 4448, 1, 0, 0, 0, 4446, 4444,
		1, 0, 0, 0, 4447, 4449, 3, 644, 322, 0, 4448, 4447, 1, 0, 0, 0, 4448, 4449,
		1, 0, 0, 0, 4449, 319, 1, 0, 0, 0, 4450, 4451, 5, 182, 0, 0, 4451, 4452,
		5, 749, 0, 0, 4452, 321, 1, 0, 0, 0, 4453, 4454, 5, 154, 0, 0, 4454, 4455,
		5, 340, 0, 0, 4455, 4456, 5, 1145, 0, 0, 4456, 4457, 7, 27, 0, 0, 4457,
		323, 1, 0, 0, 0, 4458, 4460, 5, 154, 0, 0, 4459, 4461, 7, 59, 0, 0, 4460,
		4459, 1, 0, 0, 0, 4460, 4461, 1, 0, 0, 0, 4461, 4462, 1, 0, 0, 0, 4462,
		4463, 5, 656, 0, 0, 4463, 4468, 3, 332, 166, 0, 4464, 4465, 5, 1156, 0,
		0, 4465, 4467, 3, 332, 166, 0, 4466, 4464, 1, 0, 0, 0, 4467, 4470, 1, 0,
		0, 0, 4468, 4466, 1, 0, 0, 0, 4468, 4469, 1, 0, 0, 0, 4469, 325, 1, 0,
		0, 0, 4470, 4468, 1, 0, 0, 0, 4471, 4472, 5, 192, 0, 0, 4472, 4473, 5,
		377, 0, 0, 4473, 4479, 5, 619, 0, 0, 4474, 4475, 5, 135, 0, 0, 4475, 4479,
		5, 193, 0, 0, 4476, 4477, 5, 135, 0, 0, 4477, 4479, 5, 539, 0, 0, 4478,
		4471, 1, 0, 0, 0, 4478, 4474, 1, 0, 0, 0, 4478, 4476, 1, 0, 0, 0, 4479,
		327, 1, 0, 0, 0, 4480, 4485, 3, 556, 278, 0, 4481, 4483, 5, 12, 0, 0, 4482,
		4481, 1, 0, 0, 0, 4482, 4483, 1, 0, 0, 0, 4483, 4484, 1, 0, 0, 0, 4484,
		4486, 3, 584, 292, 0, 4485, 4482, 1, 0, 0, 0, 4485, 4486, 1, 0, 0, 0, 4486,
		4487, 1, 0, 0, 0, 4487, 4488, 3, 330, 165, 0, 4488, 329, 1, 0, 0, 0, 4489,
		4491, 5, 135, 0, 0, 4490, 4492, 5, 474, 0, 0, 4491, 4490, 1, 0, 0, 0, 4491,
		4492, 1, 0, 0, 0, 4492, 4498, 1, 0, 0, 0, 4493, 4495, 5, 106, 0, 0, 4494,
		4493, 1, 0, 0, 0, 4494, 4495, 1, 0, 0, 0, 4495, 4496, 1, 0, 0, 0, 4496,
		4498, 5, 193, 0, 0, 4497, 4489, 1, 0, 0, 0, 4497, 4494, 1, 0, 0, 0, 4498,
		331, 1, 0, 0, 0, 4499, 4500, 5, 464, 0, 0, 4500, 4501, 5, 472, 0, 0, 4501,
		4507, 3, 334, 167, 0, 4502, 4503, 5, 135, 0, 0, 4503, 4507, 5, 193, 0,
		0, 4504, 4505, 5, 135, 0, 0, 4505, 4507, 5, 539, 0, 0, 4506, 4499, 1, 0,
		0, 0, 4506, 4502, 1, 0, 0, 0, 4506, 4504, 1, 0, 0, 0, 4507, 333, 1, 0,
		0, 0, 4508, 4509, 5, 806, 0, 0, 4509, 4516, 5, 135, 0, 0, 4510, 4511, 5,
		135, 0, 0, 4511, 4516, 5, 807, 0, 0, 4512, 4513, 5, 135, 0, 0, 4513, 4516,
		5, 808, 0, 0, 4514, 4516, 5, 809, 0, 0, 4515, 4508, 1, 0, 0, 0, 4515, 4510,
		1, 0, 0, 0, 4515, 4512, 1, 0, 0, 0, 4515, 4514, 1, 0, 0, 0, 4516, 335,
		1, 0, 0, 0, 4517, 4518, 5, 25, 0, 0, 4518, 4519, 5, 478, 0, 0, 4519, 4520,
		5, 175, 0, 0, 4520, 4525, 3, 354, 177, 0, 4521, 4522, 5, 1156, 0, 0, 4522,
		4524, 3, 354, 177, 0, 4523, 4521, 1, 0, 0, 0, 4524, 4527, 1, 0, 0, 0, 4525,
		4523, 1, 0, 0, 0, 4525, 4526, 1, 0, 0, 0, 4526, 4529, 1, 0, 0, 0, 4527,
		4525, 1, 0, 0, 0, 4528, 4530, 3, 362, 181, 0, 4529, 4528, 1, 0, 0, 0, 4529,
		4530, 1, 0, 0, 0, 4530, 337, 1, 0, 0, 0, 4531, 4532, 5, 25, 0, 0, 4532,
		4533, 5, 590, 0, 0, 4533, 4534, 5, 429, 0, 0, 4534, 4539, 3, 364, 182,
		0, 4535, 4536, 5, 1156, 0, 0, 4536, 4538, 3, 364, 182, 0, 4537, 4535, 1,
		0, 0, 0, 4538, 4541, 1, 0, 0, 0, 4539, 4537, 1, 0, 0, 0, 4539, 4540, 1,
		0, 0, 0, 4540, 339, 1, 0, 0, 0, 4541, 4539, 1, 0, 0, 0, 4542, 4543, 5,
		133, 0, 0, 4543, 4544, 7, 60, 0, 0, 4544, 4549, 5, 477, 0, 0, 4545, 4546,
		5, 175, 0, 0, 4546, 4550, 5, 1169, 0, 0, 4547, 4548, 5, 15, 0, 0, 4548,
		4550, 5, 1169, 0, 0, 4549, 4545, 1, 0, 0, 0, 4549, 4547, 1, 0, 0, 0, 4550,
		341, 1, 0, 0, 0, 4551, 4552, 5, 591, 0, 0, 4552, 4553, 5, 478, 0, 0, 4553,
		343, 1, 0, 0, 0, 4554, 4555, 5, 591, 0, 0, 4555, 4557, 5, 616, 0, 0, 4556,
		4558, 5, 6, 0, 0, 4557, 4556, 1, 0, 0, 0, 4557, 4558, 1, 0, 0, 0, 4558,
		4560, 1, 0, 0, 0, 4559, 4561, 3, 362, 181, 0, 4560, 4559, 1, 0, 0, 0, 4560,
		4561, 1, 0, 0, 0, 4561, 345, 1, 0, 0, 0, 4562, 4563, 5, 632, 0, 0, 4563,
		4572, 5, 616, 0, 0, 4564, 4569, 3, 368, 184, 0, 4565, 4566, 5, 1156, 0,
		0, 4566, 4568, 3, 368, 184, 0, 4567, 4565, 1, 0, 0, 0, 4568, 4571, 1, 0,
		0, 0, 4569, 4567, 1, 0, 0, 0, 4569, 4570, 1, 0, 0, 0, 4570, 4573, 1, 0,
		0, 0, 4571, 4569, 1, 0, 0, 0, 4572, 4564, 1, 0, 0, 0, 4572, 4573, 1, 0,
		0, 0, 4573, 4576, 1, 0, 0, 0, 4574, 4575, 5, 667, 0, 0, 4575, 4577, 3,
		370, 185, 0, 4576, 4574, 1, 0, 0, 0, 4576, 4577, 1, 0, 0, 0, 4577, 4581,
		1, 0, 0, 0, 4578, 4580, 3, 372, 186, 0, 4579, 4578, 1, 0, 0, 0, 4580, 4583,
		1, 0, 0, 0, 4581, 4579, 1, 0, 0, 0, 4581, 4582, 1, 0, 0, 0, 4582, 4585,
		1, 0, 0, 0, 4583, 4581, 1, 0, 0, 0, 4584, 4586, 3, 362, 181, 0, 4585, 4584,
		1, 0, 0, 0, 4585, 4586, 1, 0, 0, 0, 4586, 347, 1, 0, 0, 0, 4587, 4588,
		5, 638, 0, 0, 4588, 4597, 5, 616, 0, 0, 4589, 4594, 3, 368, 184, 0, 4590,
		4591, 5, 1156, 0, 0, 4591, 4593, 3, 368, 184, 0, 4592, 4590, 1, 0, 0, 0,
		4593, 4596, 1, 0, 0, 0, 4594, 4592, 1, 0, 0, 0, 4594, 4595, 1, 0, 0, 0,
		4595, 4598, 1, 0, 0, 0, 4596, 4594, 1, 0, 0, 0, 4597, 4589, 1, 0, 0, 0,
		4597, 4598, 1, 0, 0, 0, 4598, 349, 1, 0, 0, 0, 4599, 4600, 5, 632, 0, 0,
		4600, 4601, 5, 441, 0, 0, 4601, 351, 1, 0, 0, 0, 4602, 4603, 5, 638, 0,
		0, 4603, 4604, 5, 441, 0, 0, 4604, 353, 1, 0, 0, 0, 4605, 4606, 3, 356,
		178, 0, 4606, 4607, 5, 1145, 0, 0, 4607, 4608, 5, 1169, 0, 0, 4608, 4635,
		1, 0, 0, 0, 4609, 4610, 3, 358, 179, 0, 4610, 4611, 5, 1145, 0, 0, 4611,
		4612, 3, 590, 295, 0, 4612, 4635, 1, 0, 0, 0, 4613, 4614, 3, 360, 180,
		0, 4614, 4615, 5, 1145, 0, 0, 4615, 4616, 7, 27, 0, 0, 4616, 4635, 1, 0,
		0, 0, 4617, 4618, 5, 482, 0, 0, 4618, 4619, 5, 1145, 0, 0, 4619, 4635,
		5, 1172, 0, 0, 4620, 4621, 5, 449, 0, 0, 4621, 4622, 5, 1145, 0, 0, 4622,
		4631, 5, 1154, 0, 0, 4623, 4628, 3, 584, 292, 0, 4624, 4625, 5, 1156, 0,
		0, 4625, 4627, 3, 584, 292, 0, 4626, 4624, 1, 0, 0, 0, 4627, 4630, 1, 0,
		0, 0, 4628, 4626, 1, 0, 0, 0, 4628, 4629, 1, 0, 0, 0, 4629, 4632, 1, 0,
		0, 0, 4630, 4628, 1, 0, 0, 0, 4631, 4623, 1, 0, 0, 0, 4631, 4632, 1, 0,
		0, 0, 4632, 4633, 1, 0, 0, 0, 4633, 4635, 5, 1155, 0, 0, 4634, 4605, 1,
		0, 0, 0, 4634, 4609, 1, 0, 0, 0, 4634, 4613, 1, 0, 0, 0, 4634, 4617, 1,
		0, 0, 0, 4634, 4620, 1, 0, 0, 0, 4635, 355, 1, 0, 0, 0, 4636, 4637, 7,
		61, 0, 0, 4637, 357, 1, 0, 0, 0, 4638, 4639, 7, 62, 0, 0, 4639, 359, 1,
		0, 0, 0, 4640, 4641, 7, 63, 0, 0, 4641, 361, 1, 0, 0, 0, 4642, 4643, 5,
		65, 0, 0, 4643, 4644, 5, 355, 0, 0, 4644, 4645, 5, 1169, 0, 0, 4645, 363,
		1, 0, 0, 0, 4646, 4647, 5, 583, 0, 0, 4647, 4648, 5, 1145, 0, 0, 4648,
		4649, 5, 1154, 0, 0, 4649, 4650, 3, 616, 308, 0, 4650, 4651, 5, 1155, 0,
		0, 4651, 4696, 1, 0, 0, 0, 4652, 4653, 5, 585, 0, 0, 4653, 4654, 5, 1145,
		0, 0, 4654, 4655, 5, 1154, 0, 0, 4655, 4656, 3, 616, 308, 0, 4656, 4657,
		5, 1155, 0, 0, 4657, 4696, 1, 0, 0, 0, 4658, 4659, 5, 584, 0, 0, 4659,
		4660, 5, 1145, 0, 0, 4660, 4661, 5, 1154, 0, 0, 4661, 4662, 3, 618, 309,
		0, 4662, 4663, 5, 1155, 0, 0, 4663, 4696, 1, 0, 0, 0, 4664, 4665, 5, 586,
		0, 0, 4665, 4666, 5, 1145, 0, 0, 4666, 4667, 5, 1154, 0, 0, 4667, 4668,
		3, 618, 309, 0, 4668, 4669, 5, 1155, 0, 0, 4669, 4696, 1, 0, 0, 0, 4670,
		4671, 5, 588, 0, 0, 4671, 4672, 5, 1145, 0, 0, 4672, 4673, 5, 1154, 0,
		0, 4673, 4674, 3, 628, 314, 0, 4674, 4675, 5, 1155, 0, 0, 4675, 4696, 1,
		0, 0, 0, 4676, 4677, 5, 589, 0, 0, 4677, 4678, 5, 1145, 0, 0, 4678, 4679,
		5, 1154, 0, 0, 4679, 4680, 3, 628, 314, 0, 4680, 4681, 5, 1155, 0, 0, 4681,
		4696, 1, 0, 0, 0, 4682, 4683, 5, 587, 0, 0, 4683, 4684, 5, 1145, 0, 0,
		4684, 4685, 5, 1154, 0, 0, 4685, 4690, 3, 366, 183, 0, 4686, 4687, 5, 1156,
		0, 0, 4687, 4689, 3, 366, 183, 0, 4688, 4686, 1, 0, 0, 0, 4689, 4692, 1,
		0, 0, 0, 4690, 4688, 1, 0, 0, 0, 4690, 4691, 1, 0, 0, 0, 4691, 4693, 1,
		0, 0, 0, 4692, 4690, 1, 0, 0, 0, 4693, 4694, 5, 1155, 0, 0, 4694, 4696,
		1, 0, 0, 0, 4695, 4646, 1, 0, 0, 0, 4695, 4652, 1, 0, 0, 0, 4695, 4658,
		1, 0, 0, 0, 4695, 4664, 1, 0, 0, 0, 4695, 4670, 1, 0, 0, 0, 4695, 4676,
		1, 0, 0, 0, 4695, 4682, 1, 0, 0, 0, 4696, 365, 1, 0, 0, 0, 4697, 4698,
		5, 1154, 0, 0, 4698, 4699, 3, 556, 278, 0, 4699, 4700, 5, 1156, 0, 0, 4700,
		4701, 3, 556, 278, 0, 4701, 4702, 5, 1155, 0, 0, 4702, 367, 1, 0, 0, 0,
		4703, 4704, 7, 64, 0, 0, 4704, 369, 1, 0, 0, 0, 4705, 4706, 7, 65, 0, 0,
		4706, 4707, 5, 1145, 0, 0, 4707, 4724, 3, 374, 187, 0, 4708, 4709, 5, 484,
		0, 0, 4709, 4710, 5, 1145, 0, 0, 4710, 4711, 5, 1169, 0, 0, 4711, 4712,
		5, 1156, 0, 0, 4712, 4713, 5, 485, 0, 0, 4713, 4714, 5, 1145, 0, 0, 4714,
		4724, 3, 590, 295, 0, 4715, 4716, 5, 577, 0, 0, 4716, 4717, 5, 1145, 0,
		0, 4717, 4718, 5, 1169, 0, 0, 4718, 4719, 5, 1156, 0, 0, 4719, 4720, 5,
		578, 0, 0, 4720, 4721, 5, 1145, 0, 0, 4721, 4724, 3, 590, 295, 0, 4722,
		4724, 5, 626, 0, 0, 4723, 4705, 1, 0, 0, 0, 4723, 4708, 1, 0, 0, 0, 4723,
		4715, 1, 0, 0, 0, 4723, 4722, 1, 0, 0, 0, 4724, 371, 1, 0, 0, 0, 4725,
		4726, 5, 669, 0, 0, 4726, 4727, 5, 1145, 0, 0, 4727, 4738, 5, 1169, 0,
		0, 4728, 4729, 5, 552, 0, 0, 4729, 4730, 5, 1145, 0, 0, 4730, 4738, 5,
		1169, 0, 0, 4731, 4732, 5, 391, 0, 0, 4732, 4733, 5, 1145, 0, 0, 4733,
		4738, 5, 1169, 0, 0, 4734, 4735, 5, 556, 0, 0, 4735, 4736, 5, 1145, 0,
		0, 4736, 4738, 5, 1169, 0, 0, 4737, 4725, 1, 0, 0, 0, 4737, 4728, 1, 0,
		0, 0, 4737, 4731, 1, 0, 0, 0, 4737, 4734, 1, 0, 0, 0, 4738, 373, 1, 0,
		0, 0, 4739, 4744, 3, 576, 288, 0, 4740, 4741, 5, 1156, 0, 0, 4741, 4743,
		3, 576, 288, 0, 4742, 4740, 1, 0, 0, 0, 4743, 4746, 1, 0, 0, 0, 4744, 4742,
		1, 0, 0, 0, 4744, 4745, 1, 0, 0, 0, 4745, 4749, 1, 0, 0, 0, 4746, 4744,
		1, 0, 0, 0, 4747, 4749, 5, 1169, 0, 0, 4748, 4739, 1, 0, 0, 0, 4748, 4747,
		1, 0, 0, 0, 4749, 375, 1, 0, 0, 0, 4750, 4751, 5, 687, 0, 0, 4751, 4752,
		7, 66, 0, 0, 4752, 4754, 3, 578, 289, 0, 4753, 4755, 7, 67, 0, 0, 4754,
		4753, 1, 0, 0, 0, 4754, 4755, 1, 0, 0, 0, 4755, 377, 1, 0, 0, 0, 4756,
		4757, 5, 687, 0, 0, 4757, 4758, 5, 407, 0, 0, 4758, 4764, 3, 578, 289,
		0, 4759, 4762, 5, 646, 0, 0, 4760, 4761, 5, 65, 0, 0, 4761, 4763, 5, 510,
		0, 0, 4762, 4760, 1, 0, 0, 0, 4762, 4763, 1, 0, 0, 0, 4763, 4765, 1, 0,
		0, 0, 4764, 4759, 1, 0, 0, 0, 4764, 4765, 1, 0, 0, 0, 4765, 379, 1, 0,
		0, 0, 4766, 4767, 5, 687, 0, 0, 4767, 4768, 5, 561, 0, 0, 4768, 4769, 3,
		578, 289, 0, 4769, 381, 1, 0, 0, 0, 4770, 4771, 5, 687, 0, 0, 4771, 4772,
		5, 369, 0, 0, 4772, 4775, 3, 578, 289, 0, 4773, 4774, 5, 537, 0, 0, 4774,
		4776, 5, 554, 0, 0, 4775, 4773, 1, 0, 0, 0, 4775, 4776, 1, 0, 0, 0, 4776,
		383, 1, 0, 0, 0, 4777, 4778, 5, 687, 0, 0, 4778, 4779, 5, 599, 0, 0, 4779,
		4780, 3, 578, 289, 0, 4780, 385, 1, 0, 0, 0, 4781, 4782, 5, 687, 0, 0,
		4782, 4785, 5, 572, 0, 0, 4783, 4784, 5, 33, 0, 0, 4784, 4786, 3, 578,
		289, 0, 4785, 4783, 1, 0, 0, 0, 4785, 4786, 1, 0, 0, 0, 4786, 387, 1, 0,
		0, 0, 4787, 4788, 5, 561, 0, 0, 4788, 4789, 3, 584, 292, 0, 4789, 4792,
		5, 68, 0, 0, 4790, 4793, 5, 1169, 0, 0, 4791, 4793, 5, 1182, 0, 0, 4792,
		4790, 1, 0, 0, 0, 4792, 4791, 1, 0, 0, 0, 4793, 389, 1, 0, 0, 0, 4794,
		4795, 5, 716, 0, 0, 4795, 4798, 3, 584, 292, 0, 4796, 4797, 5, 187, 0,
		0, 4797, 4799, 3, 630, 315, 0, 4798, 4796, 1, 0, 0, 0, 4798, 4799, 1, 0,
		0, 0, 4799, 391, 1, 0, 0, 0, 4800, 4801, 7, 68, 0, 0, 4801, 4802, 5, 561,
		0, 0, 4802, 4803, 3, 584, 292, 0, 4803, 393, 1, 0, 0, 0, 4804, 4807, 3,
		396, 198, 0, 4805, 4807, 3, 4, 2, 0, 4806, 4804, 1, 0, 0, 0, 4806, 4805,
		1, 0, 0, 0, 4807, 395, 1, 0, 0, 0, 4808, 4809, 3, 584, 292, 0, 4809, 4810,
		5, 1165, 0, 0, 4810, 4812, 1, 0, 0, 0, 4811, 4808, 1, 0, 0, 0, 4811, 4812,
		1, 0, 0, 0, 4812, 4813, 1, 0, 0, 0, 4813, 4852, 5, 344, 0, 0, 4814, 4815,
		3, 416, 208, 0, 4815, 4816, 5, 1157, 0, 0, 4816, 4818, 1, 0, 0, 0, 4817,
		4814, 1, 0, 0, 0, 4818, 4821, 1, 0, 0, 0, 4819, 4817, 1, 0, 0, 0, 4819,
		4820, 1, 0, 0, 0, 4820, 4827, 1, 0, 0, 0, 4821, 4819, 1, 0, 0, 0, 4822,
		4823, 3, 418, 209, 0, 4823, 4824, 5, 1157, 0, 0, 4824, 4826, 1, 0, 0, 0,
		4825, 4822, 1, 0, 0, 0, 4826, 4829, 1, 0, 0, 0, 4827, 4825, 1, 0, 0, 0,
		4827, 4828, 1, 0, 0, 0, 4828, 4835, 1, 0, 0, 0, 4829, 4827, 1, 0, 0, 0,
		4830, 4831, 3, 420, 210, 0, 4831, 4832, 5, 1157, 0, 0, 4832, 4834, 1, 0,
		0, 0, 4833, 4830, 1, 0, 0, 0, 4834, 4837, 1, 0, 0, 0, 4835, 4833, 1, 0,
		0, 0, 4835, 4836, 1, 0, 0, 0, 4836, 4843, 1, 0, 0, 0, 4837, 4835, 1, 0,
		0, 0, 4838, 4839, 3, 422, 211, 0, 4839, 4840, 5, 1157, 0, 0, 4840, 4842,
		1, 0, 0, 0, 4841, 4838, 1, 0, 0, 0, 4842, 4845, 1, 0, 0, 0, 4843, 4841,
		1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4849, 1, 0, 0, 0, 4845, 4843,
		1, 0, 0, 0, 4846, 4848, 3, 426, 213, 0, 4847, 4846, 1, 0, 0, 0, 4848, 4851,
		1, 0, 0, 0, 4849, 4847, 1, 0, 0, 0, 4849, 4850, 1, 0, 0, 0, 4850, 4853,
		1, 0, 0, 0, 4851, 4849, 1, 0, 0, 0, 4852, 4819, 1, 0, 0, 0, 4852, 4853,
		1, 0, 0, 0, 4853, 4854, 1, 0, 0, 0, 4854, 4856, 5, 407, 0, 0, 4855, 4857,
		3, 584, 292, 0, 4856, 4855, 1, 0, 0, 0, 4856, 4857, 1, 0, 0, 0, 4857, 397,
		1, 0, 0, 0, 4858, 4861, 5, 23, 0, 0, 4859, 4862, 3, 584, 292, 0, 4860,
		4862, 3, 688, 344, 0, 4861, 4859, 1, 0, 0, 0, 4861, 4860, 1, 0, 0, 0, 4861,
		4862, 1, 0, 0, 0, 4862, 4864, 1, 0, 0, 0, 4863, 4865, 3, 428, 214, 0, 4864,
		4863, 1, 0, 0, 0, 4865, 4866, 1, 0, 0, 0, 4866, 4864, 1, 0, 0, 0, 4866,
		4867, 1, 0, 0, 0, 4867, 4874, 1, 0, 0, 0, 4868, 4870, 5, 54, 0, 0, 4869,
		4871, 3, 426, 213, 0, 4870, 4869, 1, 0, 0, 0, 4871, 4872, 1, 0, 0, 0, 4872,
		4870, 1, 0, 0, 0, 4872, 4873, 1, 0, 0, 0, 4873, 4875, 1, 0, 0, 0, 4874,
		4868, 1, 0, 0, 0, 4874, 4875, 1, 0, 0, 0, 4875, 4876, 1, 0, 0, 0, 4876,
		4877, 5, 407, 0, 0, 4877, 4878, 5, 23, 0, 0, 4878, 399, 1, 0, 0, 0, 4879,
		4880, 5, 77, 0, 0, 4880, 4881, 3, 688, 344, 0, 4881, 4883, 5, 174, 0, 0,
		4882, 4884, 3, 426, 213, 0, 4883, 4882, 1, 0, 0, 0, 4884, 4885, 1, 0, 0,
		0, 4885, 4883, 1, 0, 0, 0, 4885, 4886, 1, 0, 0, 0, 4886, 4890, 1, 0, 0,
		0, 4887, 4889, 3, 430, 215, 0, 4888, 4887, 1, 0, 0, 0, 4889, 4892, 1, 0,
		0, 0, 4890, 4888, 1, 0, 0, 0, 4890, 4891, 1, 0, 0, 0, 4891, 4899, 1, 0,
		0, 0, 4892, 4890, 1, 0, 0, 0, 4893, 4895, 5, 54, 0, 0, 4894, 4896, 3, 426,
		213, 0, 4895, 4894, 1, 0, 0, 0, 4896, 4897, 1, 0, 0, 0, 4897, 4895, 1,
		0, 0, 0, 4897, 4898, 1, 0, 0, 0, 4898, 4900, 1, 0, 0, 0, 4899, 4893, 1,
		0, 0, 0, 4899, 4900, 1, 0, 0, 0, 4900, 4901, 1, 0, 0, 0, 4901, 4902, 5,
		407, 0, 0, 4902, 4903, 5, 77, 0, 0, 4903, 401, 1, 0, 0, 0, 4904, 4905,
		5, 89, 0, 0, 4905, 4906, 3, 584, 292, 0, 4906, 403, 1, 0, 0, 0, 4907, 4908,
		5, 96, 0, 0, 4908, 4909, 3, 584, 292, 0, 4909, 405, 1, 0, 0, 0, 4910, 4911,
		3, 584, 292, 0, 4911, 4912, 5, 1165, 0, 0, 4912, 4914, 1, 0, 0, 0, 4913,
		4910, 1, 0, 0, 0, 4913, 4914, 1, 0, 0, 0, 4914, 4915, 1, 0, 0, 0, 4915,
		4917, 5, 105, 0, 0, 4916, 4918, 3, 426, 213, 0, 4917, 4916, 1, 0, 0, 0,
		4918, 4919, 1, 0, 0, 0, 4919, 4917, 1, 0, 0, 0, 4919, 4920, 1, 0, 0, 0,
		4920, 4921, 1, 0, 0, 0, 4921, 4922, 5, 407, 0, 0, 4922, 4924, 5, 105, 0,
		0, 4923, 4925, 3, 584, 292, 0, 4924, 4923, 1, 0, 0, 0, 4924, 4925, 1, 0,
		0, 0, 4925, 407, 1, 0, 0, 0, 4926, 4927, 3, 584, 292, 0, 4927, 4928, 5,
		1165, 0, 0, 4928, 4930, 1, 0, 0, 0, 4929, 4926, 1, 0, 0, 0, 4929, 4930,
		1, 0, 0, 0, 4930, 4931, 1, 0, 0, 0, 4931, 4933, 5, 141, 0, 0, 4932, 4934,
		3, 426, 213, 0, 4933, 4932, 1, 0, 0, 0, 4934, 4935, 1, 0, 0, 0, 4935, 4933,
		1, 0, 0, 0, 4935, 4936, 1, 0, 0, 0, 4936, 4937, 1, 0, 0, 0, 4937, 4938,
		5, 667, 0, 0, 4938, 4939, 3, 688, 344, 0, 4939, 4940, 5, 407, 0, 0, 4940,
		4942, 5, 141, 0, 0, 4941, 4943, 3, 584, 292, 0, 4942, 4941, 1, 0, 0, 0,
		4942, 4943, 1, 0, 0, 0, 4943, 409, 1, 0, 0, 0, 4944, 4945, 5, 147, 0, 0,
		4945, 4946, 3, 688, 344, 0, 4946, 411, 1, 0, 0, 0, 4947, 4948, 3, 584,
		292, 0, 4948, 4949, 5, 1165, 0, 0, 4949, 4951, 1, 0, 0, 0, 4950, 4947,
		1, 0, 0, 0, 4950, 4951, 1, 0, 0, 0, 4951, 4952, 1, 0, 0, 0, 4952, 4953,
		5, 191, 0, 0, 4953, 4954, 3, 688, 344, 0, 4954, 4956, 5, 399, 0, 0, 4955,
		4957, 3, 426, 213, 0, 4956, 4955, 1, 0, 0, 0, 4957, 4958, 1, 0, 0, 0, 4958,
		4956, 1, 0, 0, 0, 4958, 4959, 1, 0, 0, 0, 4959, 4960, 1, 0, 0, 0, 4960,
		4961, 5, 407, 0, 0, 4961, 4963, 5, 191, 0, 0, 4962, 4964, 3, 584, 292,
		0, 4963, 4962, 1, 0, 0, 0, 4963, 4964, 1, 0, 0, 0, 4964, 413, 1, 0, 0,
		0, 4965, 4966, 5, 361, 0, 0, 4966, 4981, 3, 584, 292, 0, 4967, 4972, 5,
		64, 0, 0, 4968, 4970, 5, 521, 0, 0, 4969, 4968, 1, 0, 0, 0, 4969, 4970,
		1, 0, 0, 0, 4970, 4971, 1, 0, 0, 0, 4971, 4973, 5, 68, 0, 0, 4972, 4969,
		1, 0, 0, 0, 4972, 4973, 1, 0, 0, 0, 4973, 4974, 1, 0, 0, 0, 4974, 4975,
		3, 584, 292, 0, 4975, 4976, 5, 87, 0, 0, 4976, 4977, 3, 616, 308, 0, 4977,
		4981, 1, 0, 0, 0, 4978, 4979, 5, 540, 0, 0, 4979, 4981, 3, 584, 292, 0,
		4980, 4965, 1, 0, 0, 0, 4980, 4967, 1, 0, 0, 0, 4980, 4978, 1, 0, 0, 0,
		4981, 415, 1, 0, 0, 0, 4982, 4983, 5, 42, 0, 0, 4983, 4984, 3, 616, 308,
		0, 4984, 4987, 3, 604, 302, 0, 4985, 4986, 5, 43, 0, 0, 4986, 4988, 3,
		688, 344, 0, 4987, 4985, 1, 0, 0, 0, 4987, 4988, 1, 0, 0, 0, 4988, 417,
		1, 0, 0, 0, 4989, 4990, 5, 42, 0, 0, 4990, 4991, 3, 584, 292, 0, 4991,
		4992, 5, 30, 0, 0, 4992, 4999, 5, 65, 0, 0, 4993, 5000, 3, 590, 295, 0,
		4994, 4996, 5, 162, 0, 0, 4995, 4997, 5, 673, 0, 0, 4996, 4995, 1, 0, 0,
		0, 4996, 4997, 1, 0, 0, 0, 4997, 4998, 1, 0, 0, 0, 4998, 5000, 5, 1169,
		0, 0, 4999, 4993, 1, 0, 0, 0, 4999, 4994, 1, 0, 0, 0, 5000, 419, 1, 0,
		0, 0, 5001, 5002, 5, 42, 0, 0, 5002, 5003, 3, 584, 292, 0, 5003, 5004,
		5, 39, 0, 0, 5004, 5005, 5, 65, 0, 0, 5005, 5006, 3, 208, 104, 0, 5006,
		421, 1, 0, 0, 0, 5007, 5008, 5, 42, 0, 0, 5008, 5009, 7, 69, 0, 0, 5009,
		5010, 5, 442, 0, 0, 5010, 5011, 5, 65, 0, 0, 5011, 5016, 3, 424, 212, 0,
		5012, 5013, 5, 1156, 0, 0, 5013, 5015, 3, 424, 212, 0, 5014, 5012, 1, 0,
		0, 0, 5015, 5018, 1, 0, 0, 0, 5016, 5014, 1, 0, 0, 0, 5016, 5017, 1, 0,
		0, 0, 5017, 5019, 1, 0, 0, 0, 5018, 5016, 1, 0, 0, 0, 5019, 5020, 3, 394,
		197, 0, 5020, 423, 1, 0, 0, 0, 5021, 5033, 3, 590, 295, 0, 5022, 5024,
		5, 162, 0, 0, 5023, 5025, 5, 673, 0, 0, 5024, 5023, 1, 0, 0, 0, 5024, 5025,
		1, 0, 0, 0, 5025, 5026, 1, 0, 0, 0, 5026, 5033, 5, 1169, 0, 0, 5027, 5033,
		3, 584, 292, 0, 5028, 5033, 5, 163, 0, 0, 5029, 5030, 5, 114, 0, 0, 5030,
		5033, 5, 435, 0, 0, 5031, 5033, 5, 161, 0, 0, 5032, 5021, 1, 0, 0, 0, 5032,
		5022, 1, 0, 0, 0, 5032, 5027, 1, 0, 0, 0, 5032, 5028, 1, 0, 0, 0, 5032,
		5029, 1, 0, 0, 0, 5032, 5031, 1, 0, 0, 0, 5033, 425, 1, 0, 0, 0, 5034,
		5037, 3, 20, 10, 0, 5035, 5037, 3, 4, 2, 0, 5036, 5034, 1, 0, 0, 0, 5036,
		5035, 1, 0, 0, 0, 5037, 5038, 1, 0, 0, 0, 5038, 5039, 5, 1157, 0, 0, 5039,
		427, 1, 0, 0, 0, 5040, 5043, 5, 189, 0, 0, 5041, 5044, 3, 602, 301, 0,
		5042, 5044, 3, 688, 344, 0, 5043, 5041, 1, 0, 0, 0, 5043, 5042, 1, 0, 0,
		0, 5044, 5045, 1, 0, 0, 0, 5045, 5047, 5, 174, 0, 0, 5046, 5048, 3, 426,
		213, 0, 5047, 5046, 1, 0, 0, 0, 5048, 5049, 1, 0, 0, 0, 5049, 5047, 1,
		0, 0, 0, 5049, 5050, 1, 0, 0, 0, 5050, 429, 1, 0, 0, 0, 5051, 5052, 5,
		55, 0, 0, 5052, 5053, 3, 688, 344, 0, 5053, 5055, 5, 174, 0, 0, 5054, 5056,
		3, 426, 213, 0, 5055, 5054, 1, 0, 0, 0, 5056, 5057, 1, 0, 0, 0, 5057, 5055,
		1, 0, 0, 0, 5057, 5058, 1, 0, 0, 0, 5058, 431, 1, 0, 0, 0, 5059, 5060,
		5, 7, 0, 0, 5060, 5061, 5, 669, 0, 0, 5061, 5066, 3, 452, 226, 0, 5062,
		5063, 5, 1156, 0, 0, 5063, 5065, 3, 452, 226, 0, 5064, 5062, 1, 0, 0, 0,
		5065, 5068, 1, 0, 0, 0, 5066, 5064, 1, 0, 0, 0, 5066, 5067, 1, 0, 0, 0,
		5067, 5120, 1, 0, 0, 0, 5068, 5066, 1, 0, 0, 0, 5069, 5070, 5, 7, 0, 0,
		5070, 5072, 5, 669, 0, 0, 5071, 5073, 3, 638, 319, 0, 5072, 5071, 1, 0,
		0, 0, 5072, 5073, 1, 0, 0, 0, 5073, 5074, 1, 0, 0, 0, 5074, 5079, 3, 454,
		227, 0, 5075, 5076, 5, 1156, 0, 0, 5076, 5078, 3, 454, 227, 0, 5077, 5075,
		1, 0, 0, 0, 5078, 5081, 1, 0, 0, 0, 5079, 5077, 1, 0, 0, 0, 5079, 5080,
		1, 0, 0, 0, 5080, 5096, 1, 0, 0, 0, 5081, 5079, 1, 0, 0, 0, 5082, 5094,
		5, 143, 0, 0, 5083, 5095, 5, 530, 0, 0, 5084, 5091, 3, 458, 229, 0, 5085,
		5087, 5, 10, 0, 0, 5086, 5085, 1, 0, 0, 0, 5086, 5087, 1, 0, 0, 0, 5087,
		5088, 1, 0, 0, 0, 5088, 5090, 3, 458, 229, 0, 5089, 5086, 1, 0, 0, 0, 5090,
		5093, 1, 0, 0, 0, 5091, 5089, 1, 0, 0, 0, 5091, 5092, 1, 0, 0, 0, 5092,
		5095, 1, 0, 0, 0, 5093, 5091, 1, 0, 0, 0, 5094, 5083, 1, 0, 0, 0, 5094,
		5084, 1, 0, 0, 0, 5095, 5097, 1, 0, 0, 0, 5096, 5082, 1, 0, 0, 0, 5096,
		5097, 1, 0, 0, 0, 5097, 5104, 1, 0, 0, 0, 5098, 5100, 5, 192, 0, 0, 5099,
		5101, 3, 460, 230, 0, 5100, 5099, 1, 0, 0, 0, 5101, 5102, 1, 0, 0, 0, 5102,
		5100, 1, 0, 0, 0, 5102, 5103, 1, 0, 0, 0, 5103, 5105, 1, 0, 0, 0, 5104,
		5098, 1, 0, 0, 0, 5104, 5105, 1, 0, 0, 0, 5105, 5110, 1, 0, 0, 0, 5106,
		5109, 3, 462, 231, 0, 5107, 5109, 3, 464, 232, 0, 5108, 5106, 1, 0, 0,
		0, 5108, 5107, 1, 0, 0, 0, 5109, 5112, 1, 0, 0, 0, 5110, 5108, 1, 0, 0,
		0, 5110, 5111, 1, 0, 0, 0, 5111, 5117, 1, 0, 0, 0, 5112, 5110, 1, 0, 0,
		0, 5113, 5114, 5, 368, 0, 0, 5114, 5118, 5, 1169, 0, 0, 5115, 5116, 5,
		14, 0, 0, 5116, 5118, 5, 1169, 0, 0, 5117, 5113, 1, 0, 0, 0, 5117, 5115,
		1, 0, 0, 0, 5117, 5118, 1, 0, 0, 0, 5118, 5120, 1, 0, 0, 0, 5119, 5059,
		1, 0, 0, 0, 5119, 5069, 1, 0, 0, 0, 5120, 433, 1, 0, 0, 0, 5121, 5122,
		5, 34, 0, 0, 5122, 5123, 5, 669, 0, 0, 5123, 5128, 3, 454, 227, 0, 5124,
		5125, 5, 1156, 0, 0, 5125, 5127, 3, 454, 227, 0, 5126, 5124, 1, 0, 0, 0,
		5127, 5130, 1, 0, 0, 0, 5128, 5126, 1, 0, 0, 0, 5128, 5129, 1, 0, 0, 0,
		5129, 5182, 1, 0, 0, 0, 5130, 5128, 1, 0, 0, 0, 5131, 5132, 5, 34, 0, 0,
		5132, 5134, 5, 669, 0, 0, 5133, 5135, 3, 640, 320, 0, 5134, 5133, 1, 0,
		0, 0, 5134, 5135, 1, 0, 0, 0, 5135, 5136, 1, 0, 0, 0, 5136, 5141, 3, 454,
		227, 0, 5137, 5138, 5, 1156, 0, 0, 5138, 5140, 3, 454, 227, 0, 5139, 5137,
		1, 0, 0, 0, 5140, 5143, 1, 0, 0, 0, 5141, 5139, 1, 0, 0, 0, 5141, 5142,
		1, 0, 0, 0, 5142, 5158, 1, 0, 0, 0, 5143, 5141, 1, 0, 0, 0, 5144, 5156,
		5, 143, 0, 0, 5145, 5157, 5, 530, 0, 0, 5146, 5153, 3, 458, 229, 0, 5147,
		5149, 5, 10, 0, 0, 5148, 5147, 1, 0, 0, 0, 5148, 5149, 1, 0, 0, 0, 5149,
		5150, 1, 0, 0, 0, 5150, 5152, 3, 458, 229, 0, 5151, 5148, 1, 0, 0, 0, 5152,
		5155, 1, 0, 0, 0, 5153, 5151, 1, 0, 0, 0, 5153, 5154, 1, 0, 0, 0, 5154,
		5157, 1, 0, 0, 0, 5155, 5153, 1, 0, 0, 0, 5156, 5145, 1, 0, 0, 0, 5156,
		5146, 1, 0, 0, 0, 5157, 5159, 1, 0, 0, 0, 5158, 5144, 1, 0, 0, 0, 5158,
		5159, 1, 0, 0, 0, 5159, 5166, 1, 0, 0, 0, 5160, 5162, 5, 192, 0, 0, 5161,
		5163, 3, 460, 230, 0, 5162, 5161, 1, 0, 0, 0, 5163, 5164, 1, 0, 0, 0, 5164,
		5162, 1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165, 5167, 1, 0, 0, 0, 5166,
		5160, 1, 0, 0, 0, 5166, 5167, 1, 0, 0, 0, 5167, 5172, 1, 0, 0, 0, 5168,
		5171, 3, 462, 231, 0, 5169, 5171, 3, 464, 232, 0, 5170, 5168, 1, 0, 0,
		0, 5170, 5169, 1, 0, 0, 0, 5171, 5174, 1, 0, 0, 0, 5172, 5170, 1, 0, 0,
		0, 5172, 5173, 1, 0, 0, 0, 5173, 5179, 1, 0, 0, 0, 5174, 5172, 1, 0, 0,
		0, 5175, 5176, 5, 368, 0, 0, 5176, 5180, 5, 1169, 0, 0, 5177, 5178, 5,
		14, 0, 0, 5178, 5180, 5, 1169, 0, 0, 5179, 5175, 1, 0, 0, 0, 5179, 5177,
		1, 0, 0, 0, 5179, 5180, 1, 0, 0, 0, 5180, 5182, 1, 0, 0, 0, 5181, 5121,
		1, 0, 0, 0, 5181, 5131, 1, 0, 0, 0, 5182, 435, 1, 0, 0, 0, 5183, 5184,
		5, 52, 0, 0, 5184, 5186, 5, 669, 0, 0, 5185, 5187, 3, 638, 319, 0, 5186,
		5185, 1, 0, 0, 0, 5186, 5187, 1, 0, 0, 0, 5187, 5188, 1, 0, 0, 0, 5188,
		5193, 3, 564, 282, 0, 5189, 5190, 5, 1156, 0, 0, 5190, 5192, 3, 564, 282,
		0, 5191, 5189, 1, 0, 0, 0, 5192, 5195, 1, 0, 0, 0, 5193, 5191, 1, 0, 0,
		0, 5193, 5194, 1, 0, 0, 0, 5194, 437, 1, 0, 0, 0, 5195, 5193, 1, 0, 0,
		0, 5196, 5197, 5, 72, 0, 0, 5197, 5202, 3, 466, 233, 0, 5198, 5199, 5,
		1156, 0, 0, 5199, 5201, 3, 466, 233, 0, 5200, 5198, 1, 0, 0, 0, 5201, 5204,
		1, 0, 0, 0, 5202, 5200, 1, 0, 0, 0, 5202, 5203, 1, 0, 0, 0, 5203, 5205,
		1, 0, 0, 0, 5204, 5202, 1, 0, 0, 0, 5205, 5207, 5, 118, 0, 0, 5206, 5208,
		7, 70, 0, 0, 5207, 5206, 1, 0, 0, 0, 5207, 5208, 1, 0, 0, 0, 5208, 5209,
		1, 0, 0, 0, 5209, 5210, 3, 470, 235, 0, 5210, 5211, 5, 175, 0, 0, 5211,
		5216, 3, 454, 227, 0, 5212, 5213, 5, 1156, 0, 0, 5213, 5215, 3, 454, 227,
		0, 5214, 5212, 1, 0, 0, 0, 5215, 5218, 1, 0, 0, 0, 5216, 5214, 1, 0, 0,
		0, 5216, 5217, 1, 0, 0, 0, 5217, 5233, 1, 0, 0, 0, 5218, 5216, 1, 0, 0,
		0, 5219, 5231, 5, 143, 0, 0, 5220, 5232, 5, 530, 0, 0, 5221, 5228, 3, 458,
		229, 0, 5222, 5224, 5, 10, 0, 0, 5223, 5222, 1, 0, 0, 0, 5223, 5224, 1,
		0, 0, 0, 5224, 5225, 1, 0, 0, 0, 5225, 5227, 3, 458, 229, 0, 5226, 5223,
		1, 0, 0, 0, 5227, 5230, 1, 0, 0, 0, 5228, 5226, 1, 0, 0, 0, 5228, 5229,
		1, 0, 0, 0, 5229, 5232, 1, 0, 0, 0, 5230, 5228, 1, 0, 0, 0, 5231, 5220,
		1, 0, 0, 0, 5231, 5221, 1, 0, 0, 0, 5232, 5234, 1, 0, 0, 0, 5233, 5219,
		1, 0, 0, 0, 5233, 5234, 1, 0, 0, 0, 5234, 5244, 1, 0, 0, 0, 5235, 5241,
		5, 192, 0, 0, 5236, 5237, 5, 72, 0, 0, 5237, 5240, 5, 120, 0, 0, 5238,
		5240, 3, 460, 230, 0, 5239, 5236, 1, 0, 0, 0, 5239, 5238, 1, 0, 0, 0, 5240,
		5243, 1, 0, 0, 0, 5241, 5239, 1, 0, 0, 0, 5241, 5242, 1, 0, 0, 0, 5242,
		5245, 1, 0, 0, 0, 5243, 5241, 1, 0, 0, 0, 5244, 5235, 1, 0, 0, 0, 5244,
		5245, 1, 0, 0, 0, 5245, 5252, 1, 0, 0, 0, 5246, 5247, 5, 12, 0, 0, 5247,
		5248, 3, 564, 282, 0, 5248, 5249, 5, 192, 0, 0, 5249, 5250, 5, 598, 0,
		0, 5250, 5251, 3, 440, 220, 0, 5251, 5253, 1, 0, 0, 0, 5252, 5246, 1, 0,
		0, 0, 5252, 5253, 1, 0, 0, 0, 5253, 5290, 1, 0, 0, 0, 5254, 5257, 5, 72,
		0, 0, 5255, 5258, 3, 564, 282, 0, 5256, 5258, 3, 584, 292, 0, 5257, 5255,
		1, 0, 0, 0, 5257, 5256, 1, 0, 0, 0, 5258, 5266, 1, 0, 0, 0, 5259, 5262,
		5, 1156, 0, 0, 5260, 5263, 3, 564, 282, 0, 5261, 5263, 3, 584, 292, 0,
		5262, 5260, 1, 0, 0, 0, 5262, 5261, 1, 0, 0, 0, 5263, 5265, 1, 0, 0, 0,
		5264, 5259, 1, 0, 0, 0, 5265, 5268, 1, 0, 0, 0, 5266, 5264, 1, 0, 0, 0,
		5266, 5267, 1, 0, 0, 0, 5267, 5269, 1, 0, 0, 0, 5268, 5266, 1, 0, 0, 0,
		5269, 5272, 5, 175, 0, 0, 5270, 5273, 3, 564, 282, 0, 5271, 5273, 3, 584,
		292, 0, 5272, 5270, 1, 0, 0, 0, 5272, 5271, 1, 0, 0, 0, 5273, 5281, 1,
		0, 0, 0, 5274, 5277, 5, 1156, 0, 0, 5275, 5278, 3, 564, 282, 0, 5276, 5278,
		3, 584, 292, 0, 5277, 5275, 1, 0, 0, 0, 5277, 5276, 1, 0, 0, 0, 5278, 5280,
		1, 0, 0, 0, 5279, 5274, 1, 0, 0, 0, 5280, 5283, 1, 0, 0, 0, 5281, 5279,
		1, 0, 0, 0, 5281, 5282, 1, 0, 0, 0, 5282, 5287, 1, 0, 0, 0, 5283, 5281,
		1, 0, 0, 0, 5284, 5285, 5, 192, 0, 0, 5285, 5286, 5, 707, 0, 0, 5286, 5288,
		5, 120, 0, 0, 5287, 5284, 1, 0, 0, 0, 5287, 5288, 1, 0, 0, 0, 5288, 5290,
		1, 0, 0, 0, 5289, 5196, 1, 0, 0, 0, 5289, 5254, 1, 0, 0, 0, 5290, 439,
		1, 0, 0, 0, 5291, 5314, 5, 43, 0, 0, 5292, 5314, 5, 530, 0, 0, 5293, 5303,
		5, 6, 0, 0, 5294, 5295, 5, 59, 0, 0, 5295, 5300, 3, 564, 282, 0, 5296,
		5297, 5, 1156, 0, 0, 5297, 5299, 3, 564, 282, 0, 5298, 5296, 1, 0, 0, 0,
		5299, 5302, 1, 0, 0, 0, 5300, 5298, 1, 0, 0, 0, 5300, 5301, 1, 0, 0, 0,
		5301, 5304, 1, 0, 0, 0, 5302, 5300, 1, 0, 0, 0, 5303, 5294, 1, 0, 0, 0,
		5303, 5304, 1, 0, 0, 0, 5304, 5314, 1, 0, 0, 0, 5305, 5310, 3, 564, 282,
		0, 5306, 5307, 5, 1156, 0, 0, 5307, 5309, 3, 564, 282, 0, 5308, 5306, 1,
		0, 0, 0, 5309, 5312, 1, 0, 0, 0, 5310, 5308, 1, 0, 0, 0, 5310, 5311, 1,
		0, 0, 0, 5311, 5314, 1, 0, 0, 0, 5312, 5310, 1, 0, 0, 0, 5313, 5291, 1,
		0, 0, 0, 5313, 5292, 1, 0, 0, 0, 5313, 5293, 1, 0, 0, 0, 5313, 5305, 1,
		0, 0, 0, 5314, 441, 1, 0, 0, 0, 5315, 5316, 5, 72, 0, 0, 5316, 5317, 5,
		567, 0, 0, 5317, 5318, 5, 118, 0, 0, 5318, 5319, 3, 564, 282, 0, 5319,
		5320, 5, 175, 0, 0, 5320, 5325, 3, 564, 282, 0, 5321, 5322, 5, 1156, 0,
		0, 5322, 5324, 3, 564, 282, 0, 5323, 5321, 1, 0, 0, 0, 5324, 5327, 1, 0,
		0, 0, 5325, 5323, 1, 0, 0, 0, 5325, 5326, 1, 0, 0, 0, 5326, 5331, 1, 0,
		0, 0, 5327, 5325, 1, 0, 0, 0, 5328, 5329, 5, 192, 0, 0, 5329, 5330, 5,
		72, 0, 0, 5330, 5332, 5, 120, 0, 0, 5331, 5328, 1, 0, 0, 0, 5331, 5332,
		1, 0, 0, 0, 5332, 443, 1, 0, 0, 0, 5333, 5334, 5, 140, 0, 0, 5334, 5335,
		5, 669, 0, 0, 5335, 5340, 3, 472, 236, 0, 5336, 5337, 5, 1156, 0, 0, 5337,
		5339, 3, 472, 236, 0, 5338, 5336, 1, 0, 0, 0, 5339, 5342, 1, 0, 0, 0, 5340,
		5338, 1, 0, 0, 0, 5340, 5341, 1, 0, 0, 0, 5341, 445, 1, 0, 0, 0, 5342,
		5340, 1, 0, 0, 0, 5343, 5344, 5, 148, 0, 0, 5344, 5349, 3, 466, 233, 0,
		5345, 5346, 5, 1156, 0, 0, 5346, 5348, 3, 466, 233, 0, 5347, 5345, 1, 0,
		0, 0, 5348, 5351, 1, 0, 0, 0, 5349, 5347, 1, 0, 0, 0, 5349, 5350, 1, 0,
		0, 0, 5350, 5352, 1, 0, 0, 0, 5351, 5349, 1, 0, 0, 0, 5352, 5354, 5, 118,
		0, 0, 5353, 5355, 7, 70, 0, 0, 5354, 5353, 1, 0, 0, 0, 5354, 5355, 1, 0,
		0, 0, 5355, 5356, 1, 0, 0, 0, 5356, 5357, 3, 470, 235, 0, 5357, 5358, 5,
		68, 0, 0, 5358, 5363, 3, 564, 282, 0, 5359, 5360, 5, 1156, 0, 0, 5360,
		5362, 3, 564, 282, 0, 5361, 5359, 1, 0, 0, 0, 5362, 5365, 1, 0, 0, 0, 5363,
		5361, 1, 0, 0, 0, 5363, 5364, 1, 0, 0, 0, 5364, 5408, 1, 0, 0, 0, 5365,
		5363, 1, 0, 0, 0, 5366, 5367, 5, 148, 0, 0, 5367, 5369, 5, 6, 0, 0, 5368,
		5370, 5, 732, 0, 0, 5369, 5368, 1, 0, 0, 0, 5369, 5370, 1, 0, 0, 0, 5370,
		5371, 1, 0, 0, 0, 5371, 5372, 5, 1156, 0, 0, 5372, 5373, 5, 72, 0, 0, 5373,
		5374, 5, 120, 0, 0, 5374, 5375, 5, 68, 0, 0, 5375, 5380, 3, 564, 282, 0,
		5376, 5377, 5, 1156, 0, 0, 5377, 5379, 3, 564, 282, 0, 5378, 5376, 1, 0,
		0, 0, 5379, 5382, 1, 0, 0, 0, 5380, 5378, 1, 0, 0, 0, 5380, 5381, 1, 0,
		0, 0, 5381, 5408, 1, 0, 0, 0, 5382, 5380, 1, 0, 0, 0, 5383, 5384, 5, 148,
		0, 0, 5384, 5389, 3, 584, 292, 0, 5385, 5386, 5, 1156, 0, 0, 5386, 5388,
		3, 584, 292, 0, 5387, 5385, 1, 0, 0, 0, 5388, 5391, 1, 0, 0, 0, 5389, 5387,
		1, 0, 0, 0, 5389, 5390, 1, 0, 0, 0, 5390, 5392, 1, 0, 0, 0, 5391, 5389,
		1, 0, 0, 0, 5392, 5395, 5, 68, 0, 0, 5393, 5396, 3, 564, 282, 0, 5394,
		5396, 3, 584, 292, 0, 5395, 5393, 1, 0, 0, 0, 5395, 5394, 1, 0, 0, 0, 5396,
		5404, 1, 0, 0, 0, 5397, 5400, 5, 1156, 0, 0, 5398, 5401, 3, 564, 282, 0,
		5399, 5401, 3, 584, 292, 0, 5400, 5398, 1, 0, 0, 0, 5400, 5399, 1, 0, 0,
		0, 5401, 5403, 1, 0, 0, 0, 5402, 5397, 1, 0, 0, 0, 5403, 5406, 1, 0, 0,
		0, 5404, 5402, 1, 0, 0, 0, 5404, 5405, 1, 0, 0, 0, 5405, 5408, 1, 0, 0,
		0, 5406, 5404, 1, 0, 0, 0, 5407, 5343, 1, 0, 0, 0, 5407, 5366, 1, 0, 0,
		0, 5407, 5383, 1, 0, 0, 0, 5408, 447, 1, 0, 0, 0, 5409, 5410, 5, 148, 0,
		0, 5410, 5411, 5, 567, 0, 0, 5411, 5412, 5, 118, 0, 0, 5412, 5413, 3, 564,
		282, 0, 5413, 5414, 5, 68, 0, 0, 5414, 5419, 3, 564, 282, 0, 5415, 5416,
		5, 1156, 0, 0, 5416, 5418, 3, 564, 282, 0, 5417, 5415, 1, 0, 0, 0, 5418,
		5421, 1, 0, 0, 0, 5419, 5417, 1, 0, 0, 0, 5419, 5420, 1, 0, 0, 0, 5420,
		449, 1, 0, 0, 0, 5421, 5419, 1, 0, 0, 0, 5422, 5423, 5, 154, 0, 0, 5423,
		5426, 5, 552, 0, 0, 5424, 5425, 5, 65, 0, 0, 5425, 5427, 3, 564, 282, 0,
		5426, 5424, 1, 0, 0, 0, 5426, 5427, 1, 0, 0, 0, 5427, 5428, 1, 0, 0, 0,
		5428, 5431, 5, 1145, 0, 0, 5429, 5432, 3, 682, 341, 0, 5430, 5432, 5, 1169,
		0, 0, 5431, 5429, 1, 0, 0, 0, 5431, 5430, 1, 0, 0, 0, 5432, 451, 1, 0,
		0, 0, 5433, 5434, 3, 564, 282, 0, 5434, 5435, 3, 462, 231, 0, 5435, 453,
		1, 0, 0, 0, 5436, 5437, 3, 564, 282, 0, 5437, 5438, 5, 448, 0, 0, 5438,
		5439, 5, 20, 0, 0, 5439, 5440, 5, 552, 0, 0, 5440, 5441, 5, 1169, 0, 0,
		5441, 5464, 1, 0, 0, 0, 5442, 5443, 3, 564, 282, 0, 5443, 5444, 5, 448,
		0, 0, 5444, 5445, 5, 20, 0, 0, 5445, 5449, 5, 1169, 0, 0, 5446, 5447, 5,
		146, 0, 0, 5447, 5448, 5, 36, 0, 0, 5448, 5450, 5, 552, 0, 0, 5449, 5446,
		1, 0, 0, 0, 5449, 5450, 1, 0, 0, 0, 5450, 5464, 1, 0, 0, 0, 5451, 5452,
		3, 564, 282, 0, 5452, 5453, 5, 448, 0, 0, 5453, 5454, 7, 71, 0, 0, 5454,
		5459, 3, 456, 228, 0, 5455, 5456, 5, 123, 0, 0, 5456, 5458, 3, 456, 228,
		0, 5457, 5455, 1, 0, 0, 0, 5458, 5461, 1, 0, 0, 0, 5459, 5457, 1, 0, 0,
		0, 5459, 5460, 1, 0, 0, 0, 5460, 5464, 1, 0, 0, 0, 5461, 5459, 1, 0, 0,
		0, 5462, 5464, 3, 564, 282, 0, 5463, 5436, 1, 0, 0, 0, 5463, 5442, 1, 0,
		0, 0, 5463, 5451, 1, 0, 0, 0, 5463, 5462, 1, 0, 0, 0, 5464, 455, 1, 0,
		0, 0, 5465, 5468, 3, 582, 291, 0, 5466, 5467, 7, 72, 0, 0, 5467, 5469,
		5, 1169, 0, 0, 5468, 5466, 1, 0, 0, 0, 5468, 5469, 1, 0, 0, 0, 5469, 5475,
		1, 0, 0, 0, 5470, 5471, 3, 582, 291, 0, 5471, 5472, 7, 73, 0, 0, 5472,
		5473, 3, 682, 341, 0, 5473, 5475, 1, 0, 0, 0, 5474, 5465, 1, 0, 0, 0, 5474,
		5470, 1, 0, 0, 0, 5475, 457, 1, 0, 0, 0, 5476, 5485, 5, 167, 0, 0, 5477,
		5485, 5, 686, 0, 0, 5478, 5479, 5, 358, 0, 0, 5479, 5485, 5, 1169, 0, 0,
		5480, 5481, 5, 465, 0, 0, 5481, 5485, 5, 1169, 0, 0, 5482, 5483, 5, 643,
		0, 0, 5483, 5485, 5, 1169, 0, 0, 5484, 5476, 1, 0, 0, 0, 5484, 5477, 1,
		0, 0, 0, 5484, 5478, 1, 0, 0, 0, 5484, 5480, 1, 0, 0, 0, 5484, 5482, 1,
		0, 0, 0, 5485, 459, 1, 0, 0, 0, 5486, 5487, 5, 500, 0, 0, 5487, 5495, 3,
		590, 295, 0, 5488, 5489, 5, 503, 0, 0, 5489, 5495, 3, 590, 295, 0, 5490,
		5491, 5, 499, 0, 0, 5491, 5495, 3, 590, 295, 0, 5492, 5493, 5, 504, 0,
		0, 5493, 5495, 3, 590, 295, 0, 5494, 5486, 1, 0, 0, 0, 5494, 5488, 1, 0,
		0, 0, 5494, 5490, 1, 0, 0, 0, 5494, 5492, 1, 0, 0, 0, 5495, 461, 1, 0,
		0, 0, 5496, 5497, 5, 552, 0, 0, 5497, 5504, 5, 420, 0, 0, 5498, 5505, 5,
		43, 0, 0, 5499, 5505, 5, 520, 0, 0, 5500, 5501, 5, 86, 0, 0, 5501, 5502,
		3, 590, 295, 0, 5502, 5503, 5, 697, 0, 0, 5503, 5505, 1, 0, 0, 0, 5504,
		5498, 1, 0, 0, 0, 5504, 5499, 1, 0, 0, 0, 5504, 5500, 1, 0, 0, 0, 5504,
		5505, 1, 0, 0, 0, 5505, 5535, 1, 0, 0, 0, 5506, 5507, 5, 552, 0, 0, 5507,
		5510, 5, 445, 0, 0, 5508, 5511, 5, 43, 0, 0, 5509, 5511, 3, 590, 295, 0,
		5510, 5508, 1, 0, 0, 0, 5510, 5509, 1, 0, 0, 0, 5511, 5535, 1, 0, 0, 0,
		5512, 5513, 5, 552, 0, 0, 5513, 5514, 5, 597, 0, 0, 5514, 5519, 5, 86,
		0, 0, 5515, 5520, 5, 43, 0, 0, 5516, 5517, 3, 590, 295, 0, 5517, 5518,
		5, 697, 0, 0, 5518, 5520, 1, 0, 0, 0, 5519, 5515, 1, 0, 0, 0, 5519, 5516,
		1, 0, 0, 0, 5520, 5535, 1, 0, 0, 0, 5521, 5522, 5, 552, 0, 0, 5522, 5523,
		5, 143, 0, 0, 5523, 5525, 5, 36, 0, 0, 5524, 5526, 7, 74, 0, 0, 5525, 5524,
		1, 0, 0, 0, 5525, 5526, 1, 0, 0, 0, 5526, 5535, 1, 0, 0, 0, 5527, 5528,
		5, 424, 0, 0, 5528, 5535, 3, 590, 295, 0, 5529, 5532, 5, 553, 0, 0, 5530,
		5533, 3, 590, 295, 0, 5531, 5533, 5, 661, 0, 0, 5532, 5530, 1, 0, 0, 0,
		5532, 5531, 1, 0, 0, 0, 5533, 5535, 1, 0, 0, 0, 5534, 5496, 1, 0, 0, 0,
		5534, 5506, 1, 0, 0, 0, 5534, 5512, 1, 0, 0, 0, 5534, 5521, 1, 0, 0, 0,
		5534, 5527, 1, 0, 0, 0, 5534, 5529, 1, 0, 0, 0, 5535, 463, 1, 0, 0, 0,
		5536, 5537, 5, 332, 0, 0, 5537, 5538, 7, 75, 0, 0, 5538, 465, 1, 0, 0,
		0, 5539, 5544, 3, 468, 234, 0, 5540, 5541, 5, 1154, 0, 0, 5541, 5542, 3,
		616, 308, 0, 5542, 5543, 5, 1155, 0, 0, 5543, 5545, 1, 0, 0, 0, 5544, 5540,
		1, 0, 0, 0, 5544, 5545, 1, 0, 0, 0, 5545, 467, 1, 0, 0, 0, 5546, 5548,
		5, 6, 0, 0, 5547, 5549, 5, 732, 0, 0, 5548, 5547, 1, 0, 0, 0, 5548, 5549,
		1, 0, 0, 0, 5549, 5667, 1, 0, 0, 0, 5550, 5552, 5, 7, 0, 0, 5551, 5553,
		5, 740, 0, 0, 5552, 5551, 1, 0, 0, 0, 5552, 5553, 1, 0, 0, 0, 5553, 5667,
		1, 0, 0, 0, 5554, 5562, 5, 34, 0, 0, 5555, 5556, 5, 652, 0, 0, 5556, 5563,
		5, 749, 0, 0, 5557, 5563, 5, 740, 0, 0, 5558, 5563, 5, 675, 0, 0, 5559,
		5563, 5, 669, 0, 0, 5560, 5563, 5, 650, 0, 0, 5561, 5563, 5, 598, 0, 0,
		5562, 5555, 1, 0, 0, 0, 5562, 5557, 1, 0, 0, 0, 5562, 5558, 1, 0, 0, 0,
		5562, 5559, 1, 0, 0, 0, 5562, 5560, 1, 0, 0, 0, 5562, 5561, 1, 0, 0, 0,
		5562, 5563, 1, 0, 0, 0, 5563, 5667, 1, 0, 0, 0, 5564, 5667, 5, 45, 0, 0,
		5565, 5567, 5, 52, 0, 0, 5566, 5568, 5, 598, 0, 0, 5567, 5566, 1, 0, 0,
		0, 5567, 5568, 1, 0, 0, 0, 5568, 5667, 1, 0, 0, 0, 5569, 5667, 5, 415,
		0, 0, 5570, 5667, 5, 716, 0, 0, 5571, 5667, 5, 717, 0, 0, 5572, 5573, 5,
		72, 0, 0, 5573, 5667, 5, 120, 0, 0, 5574, 5667, 5, 81, 0, 0, 5575, 5667,
		5, 85, 0, 0, 5576, 5577, 5, 103, 0, 0, 5577, 5667, 5, 749, 0, 0, 5578,
		5667, 5, 733, 0, 0, 5579, 5667, 5, 567, 0, 0, 5580, 5667, 5, 137, 0, 0,
		5581, 5667, 5, 734, 0, 0, 5582, 5583, 5, 590, 0, 0, 5583, 5585, 7, 76,
		0, 0, 5584, 5586, 5, 707, 0, 0, 5585, 5584, 1, 0, 0, 0, 5585, 5586, 1,
		0, 0, 0, 5586, 5667, 1, 0, 0, 0, 5587, 5667, 5, 153, 0, 0, 5588, 5589,
		5, 156, 0, 0, 5589, 5667, 7, 77, 0, 0, 5590, 5667, 5, 746, 0, 0, 5591,
		5667, 5, 747, 0, 0, 5592, 5667, 5, 177, 0, 0, 5593, 5667, 5, 184, 0, 0,
		5594, 5667, 5, 185, 0, 0, 5595, 5667, 5, 708, 0, 0, 5596, 5667, 5, 709,
		0, 0, 5597, 5667, 5, 710, 0, 0, 5598, 5667, 5, 711, 0, 0, 5599, 5667, 5,
		712, 0, 0, 5600, 5667, 5, 713, 0, 0, 5601, 5667, 5, 714, 0, 0, 5602, 5667,
		5, 715, 0, 0, 5603, 5667, 5, 718, 0, 0, 5604, 5667, 5, 719, 0, 0, 5605,
		5667, 5, 720, 0, 0, 5606, 5667, 5, 721, 0, 0, 5607, 5667, 5, 722, 0, 0,
		5608, 5667, 5, 723, 0, 0, 5609, 5667, 5, 724, 0, 0, 5610, 5667, 5, 725,
		0, 0, 5611, 5667, 5, 726, 0, 0, 5612, 5667, 5, 729, 0, 0, 5613, 5667, 5,
		730, 0, 0, 5614, 5667, 5, 731, 0, 0, 5615, 5667, 5, 735, 0, 0, 5616, 5667,
		5, 736, 0, 0, 5617, 5667, 5, 737, 0, 0, 5618, 5667, 5, 738, 0, 0, 5619,
		5667, 5, 739, 0, 0, 5620, 5667, 5, 742, 0, 0, 5621, 5667, 5, 743, 0, 0,
		5622, 5667, 5, 744, 0, 0, 5623, 5667, 5, 745, 0, 0, 5624, 5667, 5, 1083,
		0, 0, 5625, 5667, 5, 748, 0, 0, 5626, 5667, 5, 750, 0, 0, 5627, 5667, 5,
		751, 0, 0, 5628, 5667, 5, 752, 0, 0, 5629, 5667, 5, 1119, 0, 0, 5630, 5667,
		5, 1120, 0, 0, 5631, 5667, 5, 1121, 0, 0, 5632, 5667, 5, 1122, 0, 0, 5633,
		5667, 5, 1125, 0, 0, 5634, 5635, 5, 345, 0, 0, 5635, 5667, 7, 78, 0, 0,
		5636, 5637, 5, 797, 0, 0, 5637, 5667, 5, 707, 0, 0, 5638, 5639, 5, 135,
		0, 0, 5639, 5642, 5, 539, 0, 0, 5640, 5642, 5, 1127, 0, 0, 5641, 5638,
		1, 0, 0, 0, 5641, 5640, 1, 0, 0, 0, 5642, 5643, 1, 0, 0, 0, 5643, 5667,
		5, 707, 0, 0, 5644, 5645, 5, 707, 0, 0, 5645, 5667, 5, 120, 0, 0, 5646,
		5647, 5, 376, 0, 0, 5647, 5667, 5, 707, 0, 0, 5648, 5649, 5, 45, 0, 0,
		5649, 5667, 5, 445, 0, 0, 5650, 5651, 5, 1123, 0, 0, 5651, 5667, 5, 1126,
		0, 0, 5652, 5653, 5, 72, 0, 0, 5653, 5667, 5, 120, 0, 0, 5654, 5655, 5,
		154, 0, 0, 5655, 5667, 5, 669, 0, 0, 5656, 5657, 5, 616, 0, 0, 5657, 5667,
		5, 1126, 0, 0, 5658, 5659, 5, 102, 0, 0, 5659, 5660, 5, 68, 0, 0, 5660,
		5667, 5, 741, 0, 0, 5661, 5662, 5, 153, 0, 0, 5662, 5663, 5, 87, 0, 0,
		5663, 5667, 5, 741, 0, 0, 5664, 5665, 5, 727, 0, 0, 5665, 5667, 5, 728,
		0, 0, 5666, 5546, 1, 0, 0, 0, 5666, 5550, 1, 0, 0, 0, 5666, 5554, 1, 0,
		0, 0, 5666, 5564, 1, 0, 0, 0, 5666, 5565, 1, 0, 0, 0, 5666, 5569, 1, 0,
		0, 0, 5666, 5570, 1, 0, 0, 0, 5666, 5571, 1, 0, 0, 0, 5666, 5572, 1, 0,
		0, 0, 5666, 5574, 1, 0, 0, 0, 5666, 5575, 1, 0, 0, 0, 5666, 5576, 1, 0,
		0, 0, 5666, 5578, 1, 0, 0, 0, 5666, 5579, 1, 0, 0, 0, 5666, 5580, 1, 0,
		0, 0, 5666, 5581, 1, 0, 0, 0, 5666, 5582, 1, 0, 0, 0, 5666, 5587, 1, 0,
		0, 0, 5666, 5588, 1, 0, 0, 0, 5666, 5590, 1, 0, 0, 0, 5666, 5591, 1, 0,
		0, 0, 5666, 5592, 1, 0, 0, 0, 5666, 5593, 1, 0, 0, 0, 5666, 5594, 1, 0,
		0, 0, 5666, 5595, 1, 0, 0, 0, 5666, 5596, 1, 0, 0, 0, 5666, 5597, 1, 0,
		0, 0, 5666, 5598, 1, 0, 0, 0, 5666, 5599, 1, 0, 0, 0, 5666, 5600, 1, 0,
		0, 0, 5666, 5601, 1, 0, 0, 0, 5666, 5602, 1, 0, 0, 0, 5666, 5603, 1, 0,
		0, 0, 5666, 5604, 1, 0, 0, 0, 5666, 5605, 1, 0, 0, 0, 5666, 5606, 1, 0,
		0, 0, 5666, 5607, 1, 0, 0, 0, 5666, 5608, 1, 0, 0, 0, 5666, 5609, 1, 0,
		0, 0, 5666, 5610, 1, 0, 0, 0, 5666, 5611, 1, 0, 0, 0, 5666, 5612, 1, 0,
		0, 0, 5666, 5613, 1, 0, 0, 0, 5666, 5614, 1, 0, 0, 0, 5666, 5615, 1, 0,
		0, 0, 5666, 5616, 1, 0, 0, 0, 5666, 5617, 1, 0, 0, 0, 5666, 5618, 1, 0,
		0, 0, 5666, 5619, 1, 0, 0, 0, 5666, 5620, 1, 0, 0, 0, 5666, 5621, 1, 0,
		0, 0, 5666, 5622, 1, 0, 0, 0, 5666, 5623, 1, 0, 0, 0, 5666, 5624, 1, 0,
		0, 0, 5666, 5625, 1, 0, 0, 0, 5666, 5626, 1, 0, 0, 0, 5666, 5627, 1, 0,
		0, 0, 5666, 5628, 1, 0, 0, 0, 5666, 5629, 1, 0, 0, 0, 5666, 5630, 1, 0,
		0, 0, 5666, 5631, 1, 0, 0, 0, 5666, 5632, 1, 0, 0, 0, 5666, 5633, 1, 0,
		0, 0, 5666, 5634, 1, 0, 0, 0, 5666, 5636, 1, 0, 0, 0, 5666, 5641, 1, 0,
		0, 0, 5666, 5644, 1, 0, 0, 0, 5666, 5646, 1, 0, 0, 0, 5666, 5648, 1, 0,
		0, 0, 5666, 5650, 1, 0, 0, 0, 5666, 5652, 1, 0, 0, 0, 5666, 5654, 1, 0,
		0, 0, 5666, 5656, 1, 0, 0, 0, 5666, 5658, 1, 0, 0, 0, 5666, 5661, 1, 0,
		0, 0, 5666, 5664, 1, 0, 0, 0, 5667, 469, 1, 0, 0, 0, 5668, 5685, 5, 1138,
		0, 0, 5669, 5670, 5, 1138, 0, 0, 5670, 5671, 5, 1153, 0, 0, 5671, 5685,
		5, 1138, 0, 0, 5672, 5673, 3, 584, 292, 0, 5673, 5674, 5, 1153, 0, 0, 5674,
		5675, 5, 1138, 0, 0, 5675, 5685, 1, 0, 0, 0, 5676, 5677, 3, 584, 292, 0,
		5677, 5678, 5, 1153, 0, 0, 5678, 5679, 3, 584, 292, 0, 5679, 5685, 1, 0,
		0, 0, 5680, 5681, 3, 584, 292, 0, 5681, 5682, 3, 588, 294, 0, 5682, 5685,
		1, 0, 0, 0, 5683, 5685, 3, 584, 292, 0, 5684, 5668, 1, 0, 0, 0, 5684, 5669,
		1, 0, 0, 0, 5684, 5672, 1, 0, 0, 0, 5684, 5676, 1, 0, 0, 0, 5684, 5680,
		1, 0, 0, 0, 5684, 5683, 1, 0, 0, 0, 5685, 471, 1, 0, 0, 0, 5686, 5687,
		3, 564, 282, 0, 5687, 5688, 5, 175, 0, 0, 5688, 5689, 3, 564, 282, 0, 5689,
		473, 1, 0, 0, 0, 5690, 5692, 5, 9, 0, 0, 5691, 5693, 7, 79, 0, 0, 5692,
		5691, 1, 0, 0, 0, 5692, 5693, 1, 0, 0, 0, 5693, 5694, 1, 0, 0, 0, 5694,
		5695, 7, 58, 0, 0, 5695, 5713, 3, 618, 309, 0, 5696, 5697, 5, 184, 0, 0,
		5697, 5698, 5, 76, 0, 0, 5698, 5699, 5, 118, 0, 0, 5699, 5704, 3, 560,
		280, 0, 5700, 5701, 5, 1156, 0, 0, 5701, 5703, 3, 560, 280, 0, 5702, 5700,
		1, 0, 0, 0, 5703, 5706, 1, 0, 0, 0, 5704, 5702, 1, 0, 0, 0, 5704, 5705,
		1, 0, 0, 0, 5705, 5711, 1, 0, 0, 0, 5706, 5704, 1, 0, 0, 0, 5707, 5708,
		5, 192, 0, 0, 5708, 5709, 3, 590, 295, 0, 5709, 5710, 5, 19, 0, 0, 5710,
		5712, 1, 0, 0, 0, 5711, 5707, 1, 0, 0, 0, 5711, 5712, 1, 0, 0, 0, 5712,
		5714, 1, 0, 0, 0, 5713, 5696, 1, 0, 0, 0, 5713, 5714, 1, 0, 0, 0, 5714,
		5726, 1, 0, 0, 0, 5715, 5716, 5, 52, 0, 0, 5716, 5717, 5, 76, 0, 0, 5717,
		5718, 5, 118, 0, 0, 5718, 5723, 3, 560, 280, 0, 5719, 5720, 5, 1156, 0,
		0, 5720, 5722, 3, 560, 280, 0, 5721, 5719, 1, 0, 0, 0, 5722, 5725, 1, 0,
		0, 0, 5723, 5721, 1, 0, 0, 0, 5723, 5724, 1, 0, 0, 0, 5724, 5727, 1, 0,
		0, 0, 5725, 5723, 1, 0, 0, 0, 5726, 5715, 1, 0, 0, 0, 5726, 5727, 1, 0,
		0, 0, 5727, 475, 1, 0, 0, 0, 5728, 5729, 5, 27, 0, 0, 5729, 5730, 5, 172,
		0, 0, 5730, 5734, 3, 618, 309, 0, 5731, 5733, 3, 484, 242, 0, 5732, 5731,
		1, 0, 0, 0, 5733, 5736, 1, 0, 0, 0, 5734, 5732, 1, 0, 0, 0, 5734, 5735,
		1, 0, 0, 0, 5735, 477, 1, 0, 0, 0, 5736, 5734, 1, 0, 0, 0, 5737, 5738,
		5, 356, 0, 0, 5738, 5739, 5, 172, 0, 0, 5739, 5741, 3, 618, 309, 0, 5740,
		5742, 7, 80, 0, 0, 5741, 5740, 1, 0, 0, 0, 5741, 5742, 1, 0, 0, 0, 5742,
		479, 1, 0, 0, 0, 5743, 5745, 5, 119, 0, 0, 5744, 5746, 7, 79, 0, 0, 5745,
		5744, 1, 0, 0, 0, 5745, 5746, 1, 0, 0, 0, 5746, 5747, 1, 0, 0, 0, 5747,
		5748, 7, 58, 0, 0, 5748, 5750, 3, 618, 309, 0, 5749, 5751, 3, 644, 322,
		0, 5750, 5749, 1, 0, 0, 0, 5750, 5751, 1, 0, 0, 0, 5751, 481, 1, 0, 0,
		0, 5752, 5754, 5, 582, 0, 0, 5753, 5755, 7, 79, 0, 0, 5754, 5753, 1, 0,
		0, 0, 5754, 5755, 1, 0, 0, 0, 5755, 5756, 1, 0, 0, 0, 5756, 5757, 5, 172,
		0, 0, 5757, 5759, 3, 618, 309, 0, 5758, 5760, 5, 570, 0, 0, 5759, 5758,
		1, 0, 0, 0, 5759, 5760, 1, 0, 0, 0, 5760, 5762, 1, 0, 0, 0, 5761, 5763,
		5, 422, 0, 0, 5762, 5761, 1, 0, 0, 0, 5762, 5763, 1, 0, 0, 0, 5763, 5765,
		1, 0, 0, 0, 5764, 5766, 5, 670, 0, 0, 5765, 5764, 1, 0, 0, 0, 5765, 5766,
		1, 0, 0, 0, 5766, 483, 1, 0, 0, 0, 5767, 5768, 5, 65, 0, 0, 5768, 5775,
		5, 668, 0, 0, 5769, 5775, 5, 570, 0, 0, 5770, 5775, 5, 425, 0, 0, 5771,
		5775, 5, 505, 0, 0, 5772, 5775, 5, 422, 0, 0, 5773, 5775, 5, 354, 0, 0,
		5774, 5767, 1, 0, 0, 0, 5774, 5769, 1, 0, 0, 0, 5774, 5770, 1, 0, 0, 0,
		5774, 5771, 1, 0, 0, 0, 5774, 5772, 1, 0, 0, 0, 5774, 5773, 1, 0, 0, 0,
		5775, 485, 1, 0, 0, 0, 5776, 5778, 5, 34, 0, 0, 5777, 5779, 3, 642, 321,
		0, 5778, 5777, 1, 0, 0, 0, 5778, 5779, 1, 0, 0, 0, 5779, 5781, 1, 0, 0,
		0, 5780, 5782, 5, 335, 0, 0, 5781, 5780, 1, 0, 0, 0, 5781, 5782, 1, 0,
		0, 0, 5782, 5783, 1, 0, 0, 0, 5783, 5785, 5, 437, 0, 0, 5784, 5786, 3,
		640, 320, 0, 5785, 5784, 1, 0, 0, 0, 5785, 5786, 1, 0, 0, 0, 5786, 5787,
		1, 0, 0, 0, 5787, 5788, 3, 584, 292, 0, 5788, 5789, 5, 596, 0, 0, 5789,
		5790, 7, 81, 0, 0, 5790, 5791, 5, 622, 0, 0, 5791, 5792, 5, 1169, 0, 0,
		5792, 487, 1, 0, 0, 0, 5793, 5794, 5, 456, 0, 0, 5794, 5795, 5, 555, 0,
		0, 5795, 5796, 3, 584, 292, 0, 5796, 5797, 5, 622, 0, 0, 5797, 5798, 5,
		1169, 0, 0, 5798, 489, 1, 0, 0, 0, 5799, 5800, 5, 665, 0, 0, 5800, 5801,
		5, 555, 0, 0, 5801, 5802, 3, 584, 292, 0, 5802, 491, 1, 0, 0, 0, 5803,
		5804, 5, 154, 0, 0, 5804, 5805, 3, 498, 249, 0, 5805, 5808, 7, 82, 0, 0,
		5806, 5809, 3, 688, 344, 0, 5807, 5809, 5, 118, 0, 0, 5808, 5806, 1, 0,
		0, 0, 5808, 5807, 1, 0, 0, 0, 5809, 5819, 1, 0, 0, 0, 5810, 5811, 5, 1156,
		0, 0, 5811, 5812, 3, 498, 249, 0, 5812, 5815, 7, 82, 0, 0, 5813, 5816,
		3, 688, 344, 0, 5814, 5816, 5, 118, 0, 0, 5815, 5813, 1, 0, 0, 0, 5815,
		5814, 1, 0, 0, 0, 5816, 5818, 1, 0, 0, 0, 5817, 5810, 1, 0, 0, 0, 5818,
		5821, 1, 0, 0, 0, 5819, 5817, 1, 0, 0, 0, 5819, 5820, 1, 0, 0, 0, 5820,
		5856, 1, 0, 0, 0, 5821, 5819, 1, 0, 0, 0, 5822, 5823, 5, 154, 0, 0, 5823,
		5826, 3, 66, 33, 0, 5824, 5827, 3, 568, 284, 0, 5825, 5827, 5, 43, 0, 0,
		5826, 5824, 1, 0, 0, 0, 5826, 5825, 1, 0, 0, 0, 5827, 5856, 1, 0, 0, 0,
		5828, 5829, 5, 154, 0, 0, 5829, 5836, 5, 518, 0, 0, 5830, 5833, 3, 568,
		284, 0, 5831, 5832, 5, 28, 0, 0, 5832, 5834, 3, 570, 285, 0, 5833, 5831,
		1, 0, 0, 0, 5833, 5834, 1, 0, 0, 0, 5834, 5837, 1, 0, 0, 0, 5835, 5837,
		5, 43, 0, 0, 5836, 5830, 1, 0, 0, 0, 5836, 5835, 1, 0, 0, 0, 5837, 5856,
		1, 0, 0, 0, 5838, 5856, 3, 450, 225, 0, 5839, 5856, 3, 324, 162, 0, 5840,
		5856, 3, 322, 161, 0, 5841, 5842, 5, 154, 0, 0, 5842, 5843, 3, 554, 277,
		0, 5843, 5844, 7, 82, 0, 0, 5844, 5852, 3, 688, 344, 0, 5845, 5846, 5,
		1156, 0, 0, 5846, 5847, 3, 554, 277, 0, 5847, 5848, 7, 82, 0, 0, 5848,
		5849, 3, 688, 344, 0, 5849, 5851, 1, 0, 0, 0, 5850, 5845, 1, 0, 0, 0, 5851,
		5854, 1, 0, 0, 0, 5852, 5850, 1, 0, 0, 0, 5852, 5853, 1, 0, 0, 0, 5853,
		5856, 1, 0, 0, 0, 5854, 5852, 1, 0, 0, 0, 5855, 5803, 1, 0, 0, 0, 5855,
		5822, 1, 0, 0, 0, 5855, 5828, 1, 0, 0, 0, 5855, 5838, 1, 0, 0, 0, 5855,
		5839, 1, 0, 0, 0, 5855, 5840, 1, 0, 0, 0, 5855, 5841, 1, 0, 0, 0, 5856,
		493, 1, 0, 0, 0, 5857, 5858, 5, 156, 0, 0, 5858, 5859, 7, 60, 0, 0, 5859,
		6049, 5, 477, 0, 0, 5860, 5861, 5, 156, 0, 0, 5861, 5862, 5, 345, 0, 0,
		5862, 5865, 5, 416, 0, 0, 5863, 5864, 5, 80, 0, 0, 5864, 5866, 5, 1169,
		0, 0, 5865, 5863, 1, 0, 0, 0, 5865, 5866, 1, 0, 0, 0, 5866, 5869, 1, 0,
		0, 0, 5867, 5868, 5, 68, 0, 0, 5868, 5870, 3, 590, 295, 0, 5869, 5867,
		1, 0, 0, 0, 5869, 5870, 1, 0, 0, 0, 5870, 5872, 1, 0, 0, 0, 5871, 5873,
		3, 300, 150, 0, 5872, 5871, 1, 0, 0, 0, 5872, 5873, 1, 0, 0, 0, 5873, 6049,
		1, 0, 0, 0, 5874, 5875, 5, 156, 0, 0, 5875, 5877, 5, 579, 0, 0, 5876, 5878,
		5, 1169, 0, 0, 5877, 5876, 1, 0, 0, 0, 5877, 5878, 1, 0, 0, 0, 5878, 5879,
		1, 0, 0, 0, 5879, 5882, 5, 416, 0, 0, 5880, 5881, 5, 80, 0, 0, 5881, 5883,
		5, 1169, 0, 0, 5882, 5880, 1, 0, 0, 0, 5882, 5883, 1, 0, 0, 0, 5883, 5886,
		1, 0, 0, 0, 5884, 5885, 5, 68, 0, 0, 5885, 5887, 3, 590, 295, 0, 5886,
		5884, 1, 0, 0, 0, 5886, 5887, 1, 0, 0, 0, 5887, 5889, 1, 0, 0, 0, 5888,
		5890, 3, 300, 150, 0, 5889, 5888, 1, 0, 0, 0, 5889, 5890, 1, 0, 0, 0, 5890,
		5894, 1, 0, 0, 0, 5891, 5892, 5, 65, 0, 0, 5892, 5893, 5, 355, 0, 0, 5893,
		5895, 5, 1169, 0, 0, 5894, 5891, 1, 0, 0, 0, 5894, 5895, 1, 0, 0, 0, 5895,
		6049, 1, 0, 0, 0, 5896, 5897, 5, 156, 0, 0, 5897, 5899, 3, 500, 250, 0,
		5898, 5900, 3, 502, 251, 0, 5899, 5898, 1, 0, 0, 0, 5899, 5900, 1, 0, 0,
		0, 5900, 6049, 1, 0, 0, 0, 5901, 5903, 5, 156, 0, 0, 5902, 5904, 5, 436,
		0, 0, 5903, 5902, 1, 0, 0, 0, 5903, 5904, 1, 0, 0, 0, 5904, 5905, 1, 0,
		0, 0, 5905, 5906, 7, 45, 0, 0, 5906, 5907, 7, 83, 0, 0, 5907, 5910, 3,
		556, 278, 0, 5908, 5909, 7, 83, 0, 0, 5909, 5911, 3, 584, 292, 0, 5910,
		5908, 1, 0, 0, 0, 5910, 5911, 1, 0, 0, 0, 5911, 5913, 1, 0, 0, 0, 5912,
		5914, 3, 502, 251, 0, 5913, 5912, 1, 0, 0, 0, 5913, 5914, 1, 0, 0, 0, 5914,
		6049, 1, 0, 0, 0, 5915, 5916, 5, 156, 0, 0, 5916, 5917, 5, 34, 0, 0, 5917,
		5919, 7, 0, 0, 0, 5918, 5920, 3, 640, 320, 0, 5919, 5918, 1, 0, 0, 0, 5919,
		5920, 1, 0, 0, 0, 5920, 5921, 1, 0, 0, 0, 5921, 6049, 3, 584, 292, 0, 5922,
		5923, 5, 156, 0, 0, 5923, 5924, 5, 34, 0, 0, 5924, 5925, 7, 84, 0, 0, 5925,
		6049, 3, 554, 277, 0, 5926, 5927, 5, 156, 0, 0, 5927, 5928, 5, 34, 0, 0,
		5928, 5930, 5, 131, 0, 0, 5929, 5931, 5, 17, 0, 0, 5930, 5929, 1, 0, 0,
		0, 5930, 5931, 1, 0, 0, 0, 5931, 5932, 1, 0, 0, 0, 5932, 6049, 3, 554,
		277, 0, 5933, 5934, 5, 156, 0, 0, 5934, 5935, 5, 34, 0, 0, 5935, 5936,
		5, 669, 0, 0, 5936, 6049, 3, 564, 282, 0, 5937, 5938, 5, 156, 0, 0, 5938,
		5939, 5, 409, 0, 0, 5939, 5940, 3, 572, 286, 0, 5940, 5941, 7, 85, 0, 0,
		5941, 6049, 1, 0, 0, 0, 5942, 5943, 5, 156, 0, 0, 5943, 5944, 5, 798, 0,
		0, 5944, 6049, 5, 637, 0, 0, 5945, 5946, 5, 156, 0, 0, 5946, 6049, 3, 504,
		252, 0, 5947, 5948, 5, 156, 0, 0, 5948, 5950, 7, 86, 0, 0, 5949, 5951,
		3, 300, 150, 0, 5950, 5949, 1, 0, 0, 0, 5950, 5951, 1, 0, 0, 0, 5951, 6049,
		1, 0, 0, 0, 5952, 5953, 5, 156, 0, 0, 5953, 5954, 5, 290, 0, 0, 5954, 5955,
		5, 1154, 0, 0, 5955, 5956, 5, 1138, 0, 0, 5956, 5957, 5, 1155, 0, 0, 5957,
		6049, 7, 86, 0, 0, 5958, 5959, 5, 156, 0, 0, 5959, 5962, 3, 506, 253, 0,
		5960, 5961, 7, 83, 0, 0, 5961, 5963, 3, 584, 292, 0, 5962, 5960, 1, 0,
		0, 0, 5962, 5963, 1, 0, 0, 0, 5963, 5965, 1, 0, 0, 0, 5964, 5966, 3, 502,
		251, 0, 5965, 5964, 1, 0, 0, 0, 5965, 5966, 1, 0, 0, 0, 5966, 6049, 1,
		0, 0, 0, 5967, 5968, 5, 156, 0, 0, 5968, 5969, 7, 87, 0, 0, 5969, 5970,
		5, 364, 0, 0, 5970, 6049, 3, 554, 277, 0, 5971, 5972, 5, 156, 0, 0, 5972,
		5975, 5, 440, 0, 0, 5973, 5974, 5, 65, 0, 0, 5974, 5976, 3, 564, 282, 0,
		5975, 5973, 1, 0, 0, 0, 5975, 5976, 1, 0, 0, 0, 5976, 6049, 1, 0, 0, 0,
		5977, 5978, 5, 156, 0, 0, 5978, 5979, 7, 88, 0, 0, 5979, 5980, 7, 83, 0,
		0, 5980, 5983, 3, 556, 278, 0, 5981, 5982, 7, 83, 0, 0, 5982, 5984, 3,
		584, 292, 0, 5983, 5981, 1, 0, 0, 0, 5983, 5984, 1, 0, 0, 0, 5984, 5987,
		1, 0, 0, 0, 5985, 5986, 5, 190, 0, 0, 5986, 5988, 3, 688, 344, 0, 5987,
		5985, 1, 0, 0, 0, 5987, 5988, 1, 0, 0, 0, 5988, 6049, 1, 0, 0, 0, 5989,
		5990, 5, 156, 0, 0, 5990, 5991, 5, 540, 0, 0, 5991, 5994, 5, 749, 0, 0,
		5992, 5993, 7, 83, 0, 0, 5993, 5995, 3, 554, 277, 0, 5994, 5992, 1, 0,
		0, 0, 5994, 5995, 1, 0, 0, 0, 5995, 5997, 1, 0, 0, 0, 5996, 5998, 3, 502,
		251, 0, 5997, 5996, 1, 0, 0, 0, 5997, 5998, 1, 0, 0, 0, 5998, 6049, 1,
		0, 0, 0, 5999, 6000, 5, 156, 0, 0, 6000, 6009, 5, 565, 0, 0, 6001, 6006,
		3, 508, 254, 0, 6002, 6003, 5, 1156, 0, 0, 6003, 6005, 3, 508, 254, 0,
		6004, 6002, 1, 0, 0, 0, 6005, 6008, 1, 0, 0, 0, 6006, 6004, 1, 0, 0, 0,
		6006, 6007, 1, 0, 0, 0, 6007, 6010, 1, 0, 0, 0, 6008, 6006, 1, 0, 0, 0,
		6009, 6001, 1, 0, 0, 0, 6009, 6010, 1, 0, 0, 0, 6010, 6014, 1, 0, 0, 0,
		6011, 6012, 5, 65, 0, 0, 6012, 6013, 5, 568, 0, 0, 6013, 6015, 3, 590,
		295, 0, 6014, 6011, 1, 0, 0, 0, 6014, 6015, 1, 0, 0, 0, 6015, 6017, 1,
		0, 0, 0, 6016, 6018, 3, 300, 150, 0, 6017, 6016, 1, 0, 0, 0, 6017, 6018,
		1, 0, 0, 0, 6018, 6049, 1, 0, 0, 0, 6019, 6020, 5, 156, 0, 0, 6020, 6022,
		7, 89, 0, 0, 6021, 6023, 5, 1169, 0, 0, 6022, 6021, 1, 0, 0, 0, 6022, 6023,
		1, 0, 0, 0, 6023, 6024, 1, 0, 0, 0, 6024, 6028, 5, 637, 0, 0, 6025, 6026,
		5, 65, 0, 0, 6026, 6027, 5, 355, 0, 0, 6027, 6029, 5, 1169, 0, 0, 6028,
		6025, 1, 0, 0, 0, 6028, 6029, 1, 0, 0, 0, 6029, 6049, 1, 0, 0, 0, 6030,
		6031, 5, 156, 0, 0, 6031, 6049, 7, 90, 0, 0, 6032, 6033, 5, 156, 0, 0,
		6033, 6035, 5, 62, 0, 0, 6034, 6036, 3, 536, 268, 0, 6035, 6034, 1, 0,
		0, 0, 6035, 6036, 1, 0, 0, 0, 6036, 6037, 1, 0, 0, 0, 6037, 6038, 5, 65,
		0, 0, 6038, 6049, 3, 590, 295, 0, 6039, 6040, 5, 156, 0, 0, 6040, 6042,
		5, 131, 0, 0, 6041, 6043, 5, 17, 0, 0, 6042, 6041, 1, 0, 0, 0, 6042, 6043,
		1, 0, 0, 0, 6043, 6044, 1, 0, 0, 0, 6044, 6046, 5, 637, 0, 0, 6045, 6047,
		3, 502, 251, 0, 6046, 6045, 1, 0, 0, 0, 6046, 6047, 1, 0, 0, 0, 6047, 6049,
		1, 0, 0, 0, 6048, 5857, 1, 0, 0, 0, 6048, 5860, 1, 0, 0, 0, 6048, 5874,
		1, 0, 0, 0, 6048, 5896, 1, 0, 0, 0, 6048, 5901, 1, 0, 0, 0, 6048, 5915,
		1, 0, 0, 0, 6048, 5922, 1, 0, 0, 0, 6048, 5926, 1, 0, 0, 0, 6048, 5933,
		1, 0, 0, 0, 6048, 5937, 1, 0, 0, 0, 6048, 5942, 1, 0, 0, 0, 6048, 5945,
		1, 0, 0, 0, 6048, 5947, 1, 0, 0, 0, 6048, 5952, 1, 0, 0, 0, 6048, 5958,
		1, 0, 0, 0, 6048, 5967, 1, 0, 0, 0, 6048, 5971, 1, 0, 0, 0, 6048, 5977,
		1, 0, 0, 0, 6048, 5989, 1, 0, 0, 0, 6048, 5999, 1, 0, 0, 0, 6048, 6019,
		1, 0, 0, 0, 6048, 6030, 1, 0, 0, 0, 6048, 6032, 1, 0, 0, 0, 6048, 6039,
		1, 0, 0, 0, 6049, 495, 1, 0, 0, 0, 6050, 6052, 5, 62, 0, 0, 6051, 6053,
		3, 536, 268, 0, 6052, 6051, 1, 0, 0, 0, 6052, 6053, 1, 0, 0, 0, 6053, 6054,
		1, 0, 0, 0, 6054, 6055, 5, 65, 0, 0, 6055, 6056, 5, 376, 0, 0, 6056, 6057,
		3, 590, 295, 0, 6057, 497, 1, 0, 0, 0, 6058, 6069, 5, 1182, 0, 0, 6059,
		6069, 5, 1183, 0, 0, 6060, 6061, 5, 1158, 0, 0, 6061, 6063, 5, 1158, 0,
		0, 6062, 6060, 1, 0, 0, 0, 6062, 6063, 1, 0, 0, 0, 6063, 6064, 1, 0, 0,
		0, 6064, 6066, 7, 91, 0, 0, 6065, 6062, 1, 0, 0, 0, 6065, 6066, 1, 0, 0,
		0, 6066, 6067, 1, 0, 0, 0, 6067, 6069, 3, 584, 292, 0, 6068, 6058, 1, 0,
		0, 0, 6068, 6059, 1, 0, 0, 0, 6068, 6065, 1, 0, 0, 0, 6069, 499, 1, 0,
		0, 0, 6070, 6071, 5, 26, 0, 0, 6071, 6084, 5, 154, 0, 0, 6072, 6084, 5,
		851, 0, 0, 6073, 6084, 5, 41, 0, 0, 6074, 6084, 5, 152, 0, 0, 6075, 6076,
		5, 437, 0, 0, 6076, 6084, 5, 637, 0, 0, 6077, 6078, 5, 132, 0, 0, 6078,
		6084, 5, 637, 0, 0, 6079, 6081, 7, 59, 0, 0, 6080, 6079, 1, 0, 0, 0, 6080,
		6081, 1, 0, 0, 0, 6081, 6082, 1, 0, 0, 0, 6082, 6084, 7, 92, 0, 0, 6083,
		6070, 1, 0, 0, 0, 6083, 6072, 1, 0, 0, 0, 6083, 6073, 1, 0, 0, 0, 6083,
		6074, 1, 0, 0, 0, 6083, 6075, 1, 0, 0, 0, 6083, 6077, 1, 0, 0, 0, 6083,
		6080, 1, 0, 0, 0, 6084, 501, 1, 0, 0, 0, 6085, 6086, 5, 98, 0, 0, 6086,
		6090, 5, 1169, 0, 0, 6087, 6088, 5, 190, 0, 0, 6088, 6090, 3, 688, 344,
		0, 6089, 6085, 1, 0, 0, 0, 6089, 6087, 1, 0, 0, 0, 6090, 503, 1, 0, 0,
		0, 6091, 6093, 5, 639, 0, 0, 6092, 6091, 1, 0, 0, 0, 6092, 6093, 1, 0,
		0, 0, 6093, 6094, 1, 0, 0, 0, 6094, 6125, 5, 410, 0, 0, 6095, 6096, 7,
		93, 0, 0, 6096, 6125, 5, 637, 0, 0, 6097, 6103, 5, 557, 0, 0, 6098, 6101,
		5, 622, 0, 0, 6099, 6102, 5, 1169, 0, 0, 6100, 6102, 3, 502, 251, 0, 6101,
		6099, 1, 0, 0, 0, 6101, 6100, 1, 0, 0, 0, 6102, 6104, 1, 0, 0, 0, 6103,
		6098, 1, 0, 0, 0, 6103, 6104, 1, 0, 0, 0, 6104, 6125, 1, 0, 0, 0, 6105,
		6125, 5, 732, 0, 0, 6106, 6108, 5, 436, 0, 0, 6107, 6106, 1, 0, 0, 0, 6107,
		6108, 1, 0, 0, 0, 6108, 6109, 1, 0, 0, 0, 6109, 6125, 5, 564, 0, 0, 6110,
		6125, 5, 566, 0, 0, 6111, 6125, 5, 475, 0, 0, 6112, 6113, 7, 89, 0, 0,
		6113, 6125, 5, 447, 0, 0, 6114, 6125, 5, 339, 0, 0, 6115, 6125, 5, 383,
		0, 0, 6116, 6125, 5, 569, 0, 0, 6117, 6118, 5, 6, 0, 0, 6118, 6119, 7,
		94, 0, 0, 6119, 6125, 5, 637, 0, 0, 6120, 6125, 5, 684, 0, 0, 6121, 6125,
		5, 685, 0, 0, 6122, 6123, 5, 172, 0, 0, 6123, 6125, 5, 660, 0, 0, 6124,
		6092, 1, 0, 0, 0, 6124, 6095, 1, 0, 0, 0, 6124, 6097, 1, 0, 0, 0, 6124,
		6105, 1, 0, 0, 0, 6124, 6107, 1, 0, 0, 0, 6124, 6110, 1, 0, 0, 0, 6124,
		6111, 1, 0, 0, 0, 6124, 6112, 1, 0, 0, 0, 6124, 6114, 1, 0, 0, 0, 6124,
		6115, 1, 0, 0, 0, 6124, 6116, 1, 0, 0, 0, 6124, 6117, 1, 0, 0, 0, 6124,
		6120, 1, 0, 0, 0, 6124, 6121, 1, 0, 0, 0, 6124, 6122, 1, 0, 0, 0, 6125,
		505, 1, 0, 0, 0, 6126, 6135, 5, 416, 0, 0, 6127, 6128, 5, 172, 0, 0, 6128,
		6135, 5, 637, 0, 0, 6129, 6131, 5, 436, 0, 0, 6130, 6129, 1, 0, 0, 0, 6130,
		6131, 1, 0, 0, 0, 6131, 6132, 1, 0, 0, 0, 6132, 6135, 5, 749, 0, 0, 6133,
		6135, 5, 658, 0, 0, 6134, 6126, 1, 0, 0, 0, 6134, 6127, 1, 0, 0, 0, 6134,
		6130, 1, 0, 0, 0, 6134, 6133, 1, 0, 0, 0, 6135, 507, 1, 0, 0, 0, 6136,
		6149, 5, 6, 0, 0, 6137, 6138, 5, 347, 0, 0, 6138, 6149, 5, 461, 0, 0, 6139,
		6140, 5, 382, 0, 0, 6140, 6149, 5, 648, 0, 0, 6141, 6149, 5, 385, 0, 0,
		6142, 6149, 5, 463, 0, 0, 6143, 6149, 5, 799, 0, 0, 6144, 6145, 5, 545,
		0, 0, 6145, 6149, 5, 426, 0, 0, 6146, 6149, 5, 624, 0, 0, 6147, 6149, 5,
		647, 0, 0, 6148, 6136, 1, 0, 0, 0, 6148, 6137, 1, 0, 0, 0, 6148, 6139,
		1, 0, 0, 0, 6148, 6141, 1, 0, 0, 0, 6148, 6142, 1, 0, 0, 0, 6148, 6143,
		1, 0, 0, 0, 6148, 6144, 1, 0, 0, 0, 6148, 6146, 1, 0, 0, 0, 6148, 6147,
		1, 0, 0, 0, 6149, 509, 1, 0, 0, 0, 6150, 6151, 5, 345, 0, 0, 6151, 6152,
		5, 1169, 0, 0, 6152, 511, 1, 0, 0, 0, 6153, 6154, 5, 351, 0, 0, 6154, 6155,
		5, 81, 0, 0, 6155, 6160, 3, 524, 262, 0, 6156, 6157, 5, 1156, 0, 0, 6157,
		6159, 3, 524, 262, 0, 6158, 6156, 1, 0, 0, 0, 6159, 6162, 1, 0, 0, 0, 6160,
		6158, 1, 0, 0, 0, 6160, 6161, 1, 0, 0, 0, 6161, 6170, 1, 0, 0, 0, 6162,
		6160, 1, 0, 0, 0, 6163, 6164, 5, 129, 0, 0, 6164, 6167, 5, 1154, 0, 0,
		6165, 6168, 3, 616, 308, 0, 6166, 6168, 5, 6, 0, 0, 6167, 6165, 1, 0, 0,
		0, 6167, 6166, 1, 0, 0, 0, 6168, 6169, 1, 0, 0, 0, 6169, 6171, 5, 1155,
		0, 0, 6170, 6163, 1, 0, 0, 0, 6170, 6171, 1, 0, 0, 0, 6171, 6172, 1, 0,
		0, 0, 6172, 6173, 5, 80, 0, 0, 6173, 6174, 3, 584, 292, 0, 6174, 513, 1,
		0, 0, 0, 6175, 6177, 5, 432, 0, 0, 6176, 6178, 7, 79, 0, 0, 6177, 6176,
		1, 0, 0, 0, 6177, 6178, 1, 0, 0, 0, 6178, 6179, 1, 0, 0, 0, 6179, 6184,
		3, 526, 263, 0, 6180, 6181, 5, 1156, 0, 0, 6181, 6183, 3, 526, 263, 0,
		6182, 6180, 1, 0, 0, 0, 6183, 6186, 1, 0, 0, 0, 6184, 6182, 1, 0, 0, 0,
		6184, 6185, 1, 0, 0, 0, 6185, 6190, 1, 0, 0, 0, 6186, 6184, 1, 0, 0, 0,
		6187, 6188, 5, 432, 0, 0, 6188, 6190, 7, 90, 0, 0, 6189, 6175, 1, 0, 0,
		0, 6189, 6187, 1, 0, 0, 0, 6190, 515, 1, 0, 0, 0, 6191, 6193, 5, 93, 0,
		0, 6192, 6194, 7, 95, 0, 0, 6193, 6192, 1, 0, 0, 0, 6193, 6194, 1, 0, 0,
		0, 6194, 6195, 1, 0, 0, 0, 6195, 6196, 3, 688, 344, 0, 6196, 517, 1, 0,
		0, 0, 6197, 6198, 5, 102, 0, 0, 6198, 6199, 5, 81, 0, 0, 6199, 6200, 5,
		87, 0, 0, 6200, 6201, 5, 351, 0, 0, 6201, 6206, 3, 530, 265, 0, 6202, 6203,
		5, 1156, 0, 0, 6203, 6205, 3, 530, 265, 0, 6204, 6202, 1, 0, 0, 0, 6205,
		6208, 1, 0, 0, 0, 6206, 6204, 1, 0, 0, 0, 6206, 6207, 1, 0, 0, 0, 6207,
		519, 1, 0, 0, 0, 6208, 6206, 1, 0, 0, 0, 6209, 6210, 5, 591, 0, 0, 6210,
		6211, 5, 568, 0, 0, 6211, 6212, 5, 351, 0, 0, 6212, 521, 1, 0, 0, 0, 6213,
		6214, 5, 746, 0, 0, 6214, 523, 1, 0, 0, 0, 6215, 6223, 3, 556, 278, 0,
		6216, 6218, 7, 23, 0, 0, 6217, 6216, 1, 0, 0, 0, 6217, 6218, 1, 0, 0, 0,
		6218, 6219, 1, 0, 0, 0, 6219, 6220, 5, 1154, 0, 0, 6220, 6221, 3, 616,
		308, 0, 6221, 6222, 5, 1155, 0, 0, 6222, 6224, 1, 0, 0, 0, 6223, 6217,
		1, 0, 0, 0, 6223, 6224, 1, 0, 0, 0, 6224, 525, 1, 0, 0, 0, 6225, 6244,
		5, 394, 0, 0, 6226, 6244, 5, 447, 0, 0, 6227, 6229, 7, 96, 0, 0, 6228,
		6227, 1, 0, 0, 0, 6228, 6229, 1, 0, 0, 0, 6229, 6230, 1, 0, 0, 0, 6230,
		6244, 5, 477, 0, 0, 6231, 6244, 5, 541, 0, 0, 6232, 6244, 5, 732, 0, 0,
		6233, 6234, 5, 568, 0, 0, 6234, 6244, 5, 351, 0, 0, 6235, 6244, 5, 637,
		0, 0, 6236, 6244, 5, 671, 0, 0, 6237, 6241, 5, 749, 0, 0, 6238, 6239, 5,
		192, 0, 0, 6239, 6240, 5, 135, 0, 0, 6240, 6242, 5, 103, 0, 0, 6241, 6238,
		1, 0, 0, 0, 6241, 6242, 1, 0, 0, 0, 6242, 6244, 1, 0, 0, 0, 6243, 6225,
		1, 0, 0, 0, 6243, 6226, 1, 0, 0, 0, 6243, 6228, 1, 0, 0, 0, 6243, 6231,
		1, 0, 0, 0, 6243, 6232, 1, 0, 0, 0, 6243, 6233, 1, 0, 0, 0, 6243, 6235,
		1, 0, 0, 0, 6243, 6236, 1, 0, 0, 0, 6243, 6237, 1, 0, 0, 0, 6244, 6258,
		1, 0, 0, 0, 6245, 6246, 5, 576, 0, 0, 6246, 6248, 5, 477, 0, 0, 6247, 6249,
		3, 362, 181, 0, 6248, 6247, 1, 0, 0, 0, 6248, 6249, 1, 0, 0, 0, 6249, 6258,
		1, 0, 0, 0, 6250, 6252, 7, 58, 0, 0, 6251, 6253, 3, 618, 309, 0, 6252,
		6251, 1, 0, 0, 0, 6252, 6253, 1, 0, 0, 0, 6253, 6255, 1, 0, 0, 0, 6254,
		6256, 3, 528, 264, 0, 6255, 6254, 1, 0, 0, 0, 6255, 6256, 1, 0, 0, 0, 6256,
		6258, 1, 0, 0, 0, 6257, 6243, 1, 0, 0, 0, 6257, 6245, 1, 0, 0, 0, 6257,
		6250, 1, 0, 0, 0, 6258, 527, 1, 0, 0, 0, 6259, 6260, 5, 192, 0, 0, 6260,
		6261, 5, 135, 0, 0, 6261, 6265, 5, 103, 0, 0, 6262, 6263, 5, 65, 0, 0,
		6263, 6265, 5, 421, 0, 0, 6264, 6259, 1, 0, 0, 0, 6264, 6262, 1, 0, 0,
		0, 6265, 529, 1, 0, 0, 0, 6266, 6274, 3, 556, 278, 0, 6267, 6268, 5, 129,
		0, 0, 6268, 6271, 5, 1154, 0, 0, 6269, 6272, 3, 616, 308, 0, 6270, 6272,
		5, 6, 0, 0, 6271, 6269, 1, 0, 0, 0, 6271, 6270, 1, 0, 0, 0, 6272, 6273,
		1, 0, 0, 0, 6273, 6275, 5, 1155, 0, 0, 6274, 6267, 1, 0, 0, 0, 6274, 6275,
		1, 0, 0, 0, 6275, 6283, 1, 0, 0, 0, 6276, 6278, 7, 23, 0, 0, 6277, 6276,
		1, 0, 0, 0, 6277, 6278, 1, 0, 0, 0, 6278, 6279, 1, 0, 0, 0, 6279, 6280,
		5, 1154, 0, 0, 6280, 6281, 3, 616, 308, 0, 6281, 6282, 5, 1155, 0, 0, 6282,
		6284, 1, 0, 0, 0, 6283, 6277, 1, 0, 0, 0, 6283, 6284, 1, 0, 0, 0, 6284,
		6287, 1, 0, 0, 0, 6285, 6286, 5, 78, 0, 0, 6286, 6288, 5, 470, 0, 0, 6287,
		6285, 1, 0, 0, 0, 6287, 6288, 1, 0, 0, 0, 6288, 531, 1, 0, 0, 0, 6289,
		6290, 7, 97, 0, 0, 6290, 6293, 3, 556, 278, 0, 6291, 6294, 3, 584, 292,
		0, 6292, 6294, 5, 1169, 0, 0, 6293, 6291, 1, 0, 0, 0, 6293, 6292, 1, 0,
		0, 0, 6293, 6294, 1, 0, 0, 0, 6294, 533, 1, 0, 0, 0, 6295, 6299, 7, 97,
		0, 0, 6296, 6297, 7, 98, 0, 0, 6297, 6298, 5, 1145, 0, 0, 6298, 6300, 7,
		99, 0, 0, 6299, 6296, 1, 0, 0, 0, 6299, 6300, 1, 0, 0, 0, 6300, 6301, 1,
		0, 0, 0, 6301, 6302, 3, 552, 276, 0, 6302, 535, 1, 0, 0, 0, 6303, 6304,
		5, 892, 0, 0, 6304, 6305, 5, 1145, 0, 0, 6305, 6306, 5, 466, 0, 0, 6306,
		537, 1, 0, 0, 0, 6307, 6308, 5, 444, 0, 0, 6308, 6309, 5, 1169, 0, 0, 6309,
		539, 1, 0, 0, 0, 6310, 6311, 5, 186, 0, 0, 6311, 6312, 3, 584, 292, 0,
		6312, 541, 1, 0, 0, 0, 6313, 6321, 5, 157, 0, 0, 6314, 6316, 5, 162, 0,
		0, 6315, 6317, 5, 673, 0, 0, 6316, 6315, 1, 0, 0, 0, 6316, 6317, 1, 0,
		0, 0, 6317, 6318, 1, 0, 0, 0, 6318, 6322, 3, 594, 297, 0, 6319, 6322, 5,
		1177, 0, 0, 6320, 6322, 5, 1178, 0, 0, 6321, 6314, 1, 0, 0, 0, 6321, 6319,
		1, 0, 0, 0, 6321, 6320, 1, 0, 0, 0, 6322, 6332, 1, 0, 0, 0, 6323, 6324,
		5, 154, 0, 0, 6324, 6329, 3, 546, 273, 0, 6325, 6326, 5, 1156, 0, 0, 6326,
		6328, 3, 546, 273, 0, 6327, 6325, 1, 0, 0, 0, 6328, 6331, 1, 0, 0, 0, 6329,
		6327, 1, 0, 0, 0, 6329, 6330, 1, 0, 0, 0, 6330, 6333, 1, 0, 0, 0, 6331,
		6329, 1, 0, 0, 0, 6332, 6323, 1, 0, 0, 0, 6332, 6333, 1, 0, 0, 0, 6333,
		543, 1, 0, 0, 0, 6334, 6342, 5, 144, 0, 0, 6335, 6337, 5, 162, 0, 0, 6336,
		6338, 5, 673, 0, 0, 6337, 6336, 1, 0, 0, 0, 6337, 6338, 1, 0, 0, 0, 6338,
		6339, 1, 0, 0, 0, 6339, 6343, 3, 594, 297, 0, 6340, 6343, 5, 1177, 0, 0,
		6341, 6343, 5, 1178, 0, 0, 6342, 6335, 1, 0, 0, 0, 6342, 6340, 1, 0, 0,
		0, 6342, 6341, 1, 0, 0, 0, 6342, 6343, 1, 0, 0, 0, 6343, 6353, 1, 0, 0,
		0, 6344, 6345, 5, 154, 0, 0, 6345, 6350, 3, 546, 273, 0, 6346, 6347, 5,
		1156, 0, 0, 6347, 6349, 3, 546, 273, 0, 6348, 6346, 1, 0, 0, 0, 6349, 6352,
		1, 0, 0, 0, 6350, 6348, 1, 0, 0, 0, 6350, 6351, 1, 0, 0, 0, 6351, 6354,
		1, 0, 0, 0, 6352, 6350, 1, 0, 0, 0, 6353, 6344, 1, 0, 0, 0, 6353, 6354,
		1, 0, 0, 0, 6354, 545, 1, 0, 0, 0, 6355, 6356, 7, 100, 0, 0, 6356, 6361,
		5, 1145, 0, 0, 6357, 6362, 3, 594, 297, 0, 6358, 6362, 5, 1170, 0, 0, 6359,
		6362, 3, 566, 283, 0, 6360, 6362, 3, 586, 293, 0, 6361, 6357, 1, 0, 0,
		0, 6361, 6358, 1, 0, 0, 0, 6361, 6359, 1, 0, 0, 0, 6361, 6360, 1, 0, 0,
		0, 6362, 547, 1, 0, 0, 0, 6363, 6365, 5, 71, 0, 0, 6364, 6366, 7, 101,
		0, 0, 6365, 6364, 1, 0, 0, 0, 6365, 6366, 1, 0, 0, 0, 6366, 6367, 1, 0,
		0, 0, 6367, 6399, 5, 49, 0, 0, 6368, 6369, 3, 498, 249, 0, 6369, 6370,
		5, 1145, 0, 0, 6370, 6378, 7, 102, 0, 0, 6371, 6372, 5, 1156, 0, 0, 6372,
		6373, 3, 498, 249, 0, 6373, 6374, 5, 1145, 0, 0, 6374, 6375, 7, 102, 0,
		0, 6375, 6377, 1, 0, 0, 0, 6376, 6371, 1, 0, 0, 0, 6377, 6380, 1, 0, 0,
		0, 6378, 6376, 1, 0, 0, 0, 6378, 6379, 1, 0, 0, 0, 6379, 6400, 1, 0, 0,
		0, 6380, 6378, 1, 0, 0, 0, 6381, 6384, 5, 30, 0, 0, 6382, 6385, 3, 590,
		295, 0, 6383, 6385, 3, 498, 249, 0, 6384, 6382, 1, 0, 0, 0, 6384, 6383,
		1, 0, 0, 0, 6385, 6386, 1, 0, 0, 0, 6386, 6387, 3, 498, 249, 0, 6387, 6388,
		5, 1145, 0, 0, 6388, 6396, 3, 550, 275, 0, 6389, 6390, 5, 1156, 0, 0, 6390,
		6391, 3, 498, 249, 0, 6391, 6392, 5, 1145, 0, 0, 6392, 6393, 3, 550, 275,
		0, 6393, 6395, 1, 0, 0, 0, 6394, 6389, 1, 0, 0, 0, 6395, 6398, 1, 0, 0,
		0, 6396, 6394, 1, 0, 0, 0, 6396, 6397, 1, 0, 0, 0, 6397, 6400, 1, 0, 0,
		0, 6398, 6396, 1, 0, 0, 0, 6399, 6368, 1, 0, 0, 0, 6399, 6381, 1, 0, 0,
		0, 6400, 549, 1, 0, 0, 0, 6401, 6402, 7, 103, 0, 0, 6402, 551, 1, 0, 0,
		0, 6403, 6409, 3, 208, 104, 0, 6404, 6409, 3, 194, 97, 0, 6405, 6409, 3,
		200, 100, 0, 6406, 6409, 3, 206, 103, 0, 6407, 6409, 3, 210, 105, 0, 6408,
		6403, 1, 0, 0, 0, 6408, 6404, 1, 0, 0, 0, 6408, 6405, 1, 0, 0, 0, 6408,
		6406, 1, 0, 0, 0, 6408, 6407, 1, 0, 0, 0, 6409, 6414, 1, 0, 0, 0, 6410,
		6411, 5, 65, 0, 0, 6411, 6412, 5, 376, 0, 0, 6412, 6414, 3, 584, 292, 0,
		6413, 6408, 1, 0, 0, 0, 6413, 6410, 1, 0, 0, 0, 6414, 553, 1, 0, 0, 0,
		6415, 6419, 3, 584, 292, 0, 6416, 6420, 5, 1176, 0, 0, 6417, 6418, 5, 1153,
		0, 0, 6418, 6420, 3, 584, 292, 0, 6419, 6416, 1, 0, 0, 0, 6419, 6417, 1,
		0, 0, 0, 6419, 6420, 1, 0, 0, 0, 6420, 555, 1, 0, 0, 0, 6421, 6422, 3,
		554, 277, 0, 6422, 557, 1, 0, 0, 0, 6423, 6426, 3, 564, 282, 0, 6424, 6426,
		3, 584, 292, 0, 6425, 6423, 1, 0, 0, 0, 6425, 6424, 1, 0, 0, 0, 6426, 559,
		1, 0, 0, 0, 6427, 6432, 3, 584, 292, 0, 6428, 6430, 3, 588, 294, 0, 6429,
		6431, 3, 588, 294, 0, 6430, 6429, 1, 0, 0, 0, 6430, 6431, 1, 0, 0, 0, 6431,
		6433, 1, 0, 0, 0, 6432, 6428, 1, 0, 0, 0, 6432, 6433, 1, 0, 0, 0, 6433,
		6440, 1, 0, 0, 0, 6434, 6435, 9, 0, 0, 0, 6435, 6437, 3, 588, 294, 0, 6436,
		6438, 3, 588, 294, 0, 6437, 6436, 1, 0, 0, 0, 6437, 6438, 1, 0, 0, 0, 6438,
		6440, 1, 0, 0, 0, 6439, 6427, 1, 0, 0, 0, 6439, 6434, 1, 0, 0, 0, 6440,
		561, 1, 0, 0, 0, 6441, 6444, 3, 584, 292, 0, 6442, 6444, 5, 1169, 0, 0,
		6443, 6441, 1, 0, 0, 0, 6443, 6442, 1, 0, 0, 0, 6444, 6449, 1, 0, 0, 0,
		6445, 6446, 5, 1154, 0, 0, 6446, 6447, 3, 590, 295, 0, 6447, 6448, 5, 1155,
		0, 0, 6448, 6450, 1, 0, 0, 0, 6449, 6445, 1, 0, 0, 0, 6449, 6450, 1, 0,
		0, 0, 6450, 6453, 1, 0, 0, 0, 6451, 6453, 3, 688, 344, 0, 6452, 6443, 1,
		0, 0, 0, 6452, 6451, 1, 0, 0, 0, 6453, 6455, 1, 0, 0, 0, 6454, 6456, 7,
		52, 0, 0, 6455, 6454, 1, 0, 0, 0, 6455, 6456, 1, 0, 0, 0, 6456, 563, 1,
		0, 0, 0, 6457, 6465, 5, 1179, 0, 0, 6458, 6465, 5, 1181, 0, 0, 6459, 6465,
		5, 1177, 0, 0, 6460, 6465, 5, 1169, 0, 0, 6461, 6465, 5, 707, 0, 0, 6462,
		6465, 3, 716, 358, 0, 6463, 6465, 3, 68, 34, 0, 6464, 6457, 1, 0, 0, 0,
		6464, 6458, 1, 0, 0, 0, 6464, 6459, 1, 0, 0, 0, 6464, 6460, 1, 0, 0, 0,
		6464, 6461, 1, 0, 0, 0, 6464, 6462, 1, 0, 0, 0, 6464, 6463, 1, 0, 0, 0,
		6465, 565, 1, 0, 0, 0, 6466, 6467, 7, 104, 0, 0, 6467, 567, 1, 0, 0, 0,
		6468, 6473, 5, 226, 0, 0, 6469, 6473, 3, 706, 353, 0, 6470, 6473, 5, 1169,
		0, 0, 6471, 6473, 5, 1166, 0, 0, 6472, 6468, 1, 0, 0, 0, 6472, 6469, 1,
		0, 0, 0, 6472, 6470, 1, 0, 0, 0, 6472, 6471, 1, 0, 0, 0, 6473, 569, 1,
		0, 0, 0, 6474, 6477, 3, 584, 292, 0, 6475, 6477, 5, 1169, 0, 0, 6476, 6474,
		1, 0, 0, 0, 6476, 6475, 1, 0, 0, 0, 6477, 571, 1, 0, 0, 0, 6478, 6479,
		7, 105, 0, 0, 6479, 573, 1, 0, 0, 0, 6480, 6481, 7, 106, 0, 0, 6481, 575,
		1, 0, 0, 0, 6482, 6483, 3, 590, 295, 0, 6483, 6484, 5, 1142, 0, 0, 6484,
		6485, 3, 590, 295, 0, 6485, 6486, 5, 1142, 0, 0, 6486, 6487, 3, 590, 295,
		0, 6487, 6488, 5, 1142, 0, 0, 6488, 6489, 3, 590, 295, 0, 6489, 6490, 5,
		1142, 0, 0, 6490, 6496, 3, 590, 295, 0, 6491, 6492, 5, 1165, 0, 0, 6492,
		6493, 3, 590, 295, 0, 6493, 6494, 5, 1142, 0, 0, 6494, 6495, 3, 590, 295,
		0, 6495, 6497, 1, 0, 0, 0, 6496, 6491, 1, 0, 0, 0, 6497, 6498, 1, 0, 0,
		0, 6498, 6496, 1, 0, 0, 0, 6498, 6499, 1, 0, 0, 0, 6499, 577, 1, 0, 0,
		0, 6500, 6507, 3, 580, 290, 0, 6501, 6502, 5, 1156, 0, 0, 6502, 6505, 3,
		580, 290, 0, 6503, 6504, 5, 1156, 0, 0, 6504, 6506, 3, 590, 295, 0, 6505,
		6503, 1, 0, 0, 0, 6505, 6506, 1, 0, 0, 0, 6506, 6508, 1, 0, 0, 0, 6507,
		6501, 1, 0, 0, 0, 6507, 6508, 1, 0, 0, 0, 6508, 579, 1, 0, 0, 0, 6509,
		6517, 5, 1169, 0, 0, 6510, 6517, 5, 1174, 0, 0, 6511, 6513, 5, 1171, 0,
		0, 6512, 6511, 1, 0, 0, 0, 6513, 6514, 1, 0, 0, 0, 6514, 6512, 1, 0, 0,
		0, 6514, 6515, 1, 0, 0, 0, 6515, 6517, 1, 0, 0, 0, 6516, 6509, 1, 0, 0,
		0, 6516, 6510, 1, 0, 0, 0, 6516, 6512, 1, 0, 0, 0, 6517, 581, 1, 0, 0,
		0, 6518, 6521, 3, 584, 292, 0, 6519, 6521, 5, 1169, 0, 0, 6520, 6518, 1,
		0, 0, 0, 6520, 6519, 1, 0, 0, 0, 6521, 583, 1, 0, 0, 0, 6522, 6526, 3,
		586, 293, 0, 6523, 6526, 5, 1178, 0, 0, 6524, 6526, 5, 1166, 0, 0, 6525,
		6522, 1, 0, 0, 0, 6525, 6523, 1, 0, 0, 0, 6525, 6524, 1, 0, 0, 0, 6526,
		585, 1, 0, 0, 0, 6527, 6537, 5, 1177, 0, 0, 6528, 6537, 3, 706, 353, 0,
		6529, 6537, 3, 708, 354, 0, 6530, 6537, 3, 572, 286, 0, 6531, 6537, 3,
		710, 355, 0, 6532, 6537, 3, 712, 356, 0, 6533, 6537, 3, 714, 357, 0, 6534,
		6537, 3, 716, 358, 0, 6535, 6537, 3, 680, 340, 0, 6536, 6527, 1, 0, 0,
		0, 6536, 6528, 1, 0, 0, 0, 6536, 6529, 1, 0, 0, 0, 6536, 6530, 1, 0, 0,
		0, 6536, 6531, 1, 0, 0, 0, 6536, 6532, 1, 0, 0, 0, 6536, 6533, 1, 0, 0,
		0, 6536, 6534, 1, 0, 0, 0, 6536, 6535, 1, 0, 0, 0, 6537, 587, 1, 0, 0,
		0, 6538, 6542, 5, 1176, 0, 0, 6539, 6540, 5, 1153, 0, 0, 6540, 6542, 3,
		584, 292, 0, 6541, 6538, 1, 0, 0, 0, 6541, 6539, 1, 0, 0, 0, 6542, 589,
		1, 0, 0, 0, 6543, 6544, 7, 107, 0, 0, 6544, 591, 1, 0, 0, 0, 6545, 6548,
		5, 1167, 0, 0, 6546, 6548, 3, 590, 295, 0, 6547, 6545, 1, 0, 0, 0, 6547,
		6546, 1, 0, 0, 0, 6548, 593, 1, 0, 0, 0, 6549, 6551, 5, 1175, 0, 0, 6550,
		6549, 1, 0, 0, 0, 6550, 6551, 1, 0, 0, 0, 6551, 6552, 1, 0, 0, 0, 6552,
		6555, 5, 1169, 0, 0, 6553, 6555, 5, 1168, 0, 0, 6554, 6550, 1, 0, 0, 0,
		6554, 6553, 1, 0, 0, 0, 6555, 6557, 1, 0, 0, 0, 6556, 6558, 5, 1169, 0,
		0, 6557, 6556, 1, 0, 0, 0, 6558, 6559, 1, 0, 0, 0, 6559, 6557, 1, 0, 0,
		0, 6559, 6560, 1, 0, 0, 0, 6560, 6573, 1, 0, 0, 0, 6561, 6563, 5, 1175,
		0, 0, 6562, 6561, 1, 0, 0, 0, 6562, 6563, 1, 0, 0, 0, 6563, 6564, 1, 0,
		0, 0, 6564, 6567, 5, 1169, 0, 0, 6565, 6567, 5, 1168, 0, 0, 6566, 6562,
		1, 0, 0, 0, 6566, 6565, 1, 0, 0, 0, 6567, 6570, 1, 0, 0, 0, 6568, 6569,
		5, 28, 0, 0, 6569, 6571, 3, 570, 285, 0, 6570, 6568, 1, 0, 0, 0, 6570,
		6571, 1, 0, 0, 0, 6571, 6573, 1, 0, 0, 0, 6572, 6554, 1, 0, 0, 0, 6572,
		6566, 1, 0, 0, 0, 6573, 595, 1, 0, 0, 0, 6574, 6575, 7, 108, 0, 0, 6575,
		597, 1, 0, 0, 0, 6576, 6578, 5, 1175, 0, 0, 6577, 6576, 1, 0, 0, 0, 6577,
		6578, 1, 0, 0, 0, 6578, 6579, 1, 0, 0, 0, 6579, 6580, 5, 1171, 0, 0, 6580,
		599, 1, 0, 0, 0, 6581, 6583, 5, 114, 0, 0, 6582, 6581, 1, 0, 0, 0, 6582,
		6583, 1, 0, 0, 0, 6583, 6584, 1, 0, 0, 0, 6584, 6585, 7, 109, 0, 0, 6585,
		601, 1, 0, 0, 0, 6586, 6599, 3, 594, 297, 0, 6587, 6599, 3, 590, 295, 0,
		6588, 6589, 5, 1142, 0, 0, 6589, 6599, 3, 590, 295, 0, 6590, 6599, 3, 598,
		299, 0, 6591, 6599, 3, 596, 298, 0, 6592, 6599, 5, 1172, 0, 0, 6593, 6599,
		5, 1174, 0, 0, 6594, 6596, 5, 114, 0, 0, 6595, 6594, 1, 0, 0, 0, 6595,
		6596, 1, 0, 0, 0, 6596, 6597, 1, 0, 0, 0, 6597, 6599, 7, 109, 0, 0, 6598,
		6586, 1, 0, 0, 0, 6598, 6587, 1, 0, 0, 0, 6598, 6588, 1, 0, 0, 0, 6598,
		6590, 1, 0, 0, 0, 6598, 6591, 1, 0, 0, 0, 6598, 6592, 1, 0, 0, 0, 6598,
		6593, 1, 0, 0, 0, 6598, 6595, 1, 0, 0, 0, 6599, 603, 1, 0, 0, 0, 6600,
		6602, 7, 110, 0, 0, 6601, 6603, 5, 238, 0, 0, 6602, 6601, 1, 0, 0, 0, 6602,
		6603, 1, 0, 0, 0, 6603, 6605, 1, 0, 0, 0, 6604, 6606, 3, 610, 305, 0, 6605,
		6604, 1, 0, 0, 0, 6605, 6606, 1, 0, 0, 0, 6606, 6608, 1, 0, 0, 0, 6607,
		6609, 5, 226, 0, 0, 6608, 6607, 1, 0, 0, 0, 6608, 6609, 1, 0, 0, 0, 6609,
		6613, 1, 0, 0, 0, 6610, 6611, 3, 66, 33, 0, 6611, 6612, 3, 568, 284, 0,
		6612, 6614, 1, 0, 0, 0, 6613, 6610, 1, 0, 0, 0, 6613, 6614, 1, 0, 0, 0,
		6614, 6618, 1, 0, 0, 0, 6615, 6616, 5, 28, 0, 0, 6616, 6619, 3, 570, 285,
		0, 6617, 6619, 5, 226, 0, 0, 6618, 6615, 1, 0, 0, 0, 6618, 6617, 1, 0,
		0, 0, 6618, 6619, 1, 0, 0, 0, 6619, 6723, 1, 0, 0, 0, 6620, 6621, 5, 225,
		0, 0, 6621, 6623, 7, 111, 0, 0, 6622, 6624, 3, 610, 305, 0, 6623, 6622,
		1, 0, 0, 0, 6623, 6624, 1, 0, 0, 0, 6624, 6626, 1, 0, 0, 0, 6625, 6627,
		5, 226, 0, 0, 6626, 6625, 1, 0, 0, 0, 6626, 6627, 1, 0, 0, 0, 6627, 6723,
		1, 0, 0, 0, 6628, 6629, 5, 519, 0, 0, 6629, 6631, 5, 223, 0, 0, 6630, 6632,
		3, 610, 305, 0, 6631, 6630, 1, 0, 0, 0, 6631, 6632, 1, 0, 0, 0, 6632, 6634,
		1, 0, 0, 0, 6633, 6635, 5, 226, 0, 0, 6634, 6633, 1, 0, 0, 0, 6634, 6635,
		1, 0, 0, 0, 6635, 6723, 1, 0, 0, 0, 6636, 6637, 5, 225, 0, 0, 6637, 6638,
		7, 112, 0, 0, 6638, 6640, 5, 238, 0, 0, 6639, 6641, 3, 610, 305, 0, 6640,
		6639, 1, 0, 0, 0, 6640, 6641, 1, 0, 0, 0, 6641, 6643, 1, 0, 0, 0, 6642,
		6644, 5, 226, 0, 0, 6643, 6642, 1, 0, 0, 0, 6643, 6644, 1, 0, 0, 0, 6644,
		6723, 1, 0, 0, 0, 6645, 6647, 7, 113, 0, 0, 6646, 6648, 3, 610, 305, 0,
		6647, 6646, 1, 0, 0, 0, 6647, 6648, 1, 0, 0, 0, 6648, 6652, 1, 0, 0, 0,
		6649, 6651, 7, 114, 0, 0, 6650, 6649, 1, 0, 0, 0, 6651, 6654, 1, 0, 0,
		0, 6652, 6650, 1, 0, 0, 0, 6652, 6653, 1, 0, 0, 0, 6653, 6723, 1, 0, 0,
		0, 6654, 6652, 1, 0, 0, 0, 6655, 6657, 5, 208, 0, 0, 6656, 6658, 3, 612,
		306, 0, 6657, 6656, 1, 0, 0, 0, 6657, 6658, 1, 0, 0, 0, 6658, 6662, 1,
		0, 0, 0, 6659, 6661, 7, 114, 0, 0, 6660, 6659, 1, 0, 0, 0, 6661, 6664,
		1, 0, 0, 0, 6662, 6660, 1, 0, 0, 0, 6662, 6663, 1, 0, 0, 0, 6663, 6723,
		1, 0, 0, 0, 6664, 6662, 1, 0, 0, 0, 6665, 6667, 5, 209, 0, 0, 6666, 6668,
		5, 210, 0, 0, 6667, 6666, 1, 0, 0, 0, 6667, 6668, 1, 0, 0, 0, 6668, 6670,
		1, 0, 0, 0, 6669, 6671, 3, 612, 306, 0, 6670, 6669, 1, 0, 0, 0, 6670, 6671,
		1, 0, 0, 0, 6671, 6675, 1, 0, 0, 0, 6672, 6674, 7, 114, 0, 0, 6673, 6672,
		1, 0, 0, 0, 6674, 6677, 1, 0, 0, 0, 6675, 6673, 1, 0, 0, 0, 6675, 6676,
		1, 0, 0, 0, 6676, 6723, 1, 0, 0, 0, 6677, 6675, 1, 0, 0, 0, 6678, 6680,
		7, 115, 0, 0, 6679, 6681, 3, 614, 307, 0, 6680, 6679, 1, 0, 0, 0, 6680,
		6681, 1, 0, 0, 0, 6681, 6685, 1, 0, 0, 0, 6682, 6684, 7, 114, 0, 0, 6683,
		6682, 1, 0, 0, 0, 6684, 6687, 1, 0, 0, 0, 6685, 6683, 1, 0, 0, 0, 6685,
		6686, 1, 0, 0, 0, 6686, 6723, 1, 0, 0, 0, 6687, 6685, 1, 0, 0, 0, 6688,
		6723, 7, 116, 0, 0, 6689, 6691, 7, 117, 0, 0, 6690, 6692, 3, 610, 305,
		0, 6691, 6690, 1, 0, 0, 0, 6691, 6692, 1, 0, 0, 0, 6692, 6723, 1, 0, 0,
		0, 6693, 6694, 7, 118, 0, 0, 6694, 6696, 3, 606, 303, 0, 6695, 6697, 5,
		226, 0, 0, 6696, 6695, 1, 0, 0, 0, 6696, 6697, 1, 0, 0, 0, 6697, 6701,
		1, 0, 0, 0, 6698, 6699, 3, 66, 33, 0, 6699, 6700, 3, 568, 284, 0, 6700,
		6702, 1, 0, 0, 0, 6701, 6698, 1, 0, 0, 0, 6701, 6702, 1, 0, 0, 0, 6702,
		6723, 1, 0, 0, 0, 6703, 6723, 7, 119, 0, 0, 6704, 6706, 5, 231, 0, 0, 6705,
		6707, 5, 223, 0, 0, 6706, 6705, 1, 0, 0, 0, 6706, 6707, 1, 0, 0, 0, 6707,
		6709, 1, 0, 0, 0, 6708, 6710, 5, 226, 0, 0, 6709, 6708, 1, 0, 0, 0, 6709,
		6710, 1, 0, 0, 0, 6710, 6714, 1, 0, 0, 0, 6711, 6712, 3, 66, 33, 0, 6712,
		6713, 3, 568, 284, 0, 6713, 6715, 1, 0, 0, 0, 6714, 6711, 1, 0, 0, 0, 6714,
		6715, 1, 0, 0, 0, 6715, 6718, 1, 0, 0, 0, 6716, 6717, 5, 28, 0, 0, 6717,
		6719, 3, 570, 285, 0, 6718, 6716, 1, 0, 0, 0, 6718, 6719, 1, 0, 0, 0, 6719,
		6723, 1, 0, 0, 0, 6720, 6721, 5, 231, 0, 0, 6721, 6723, 5, 227, 0, 0, 6722,
		6600, 1, 0, 0, 0, 6722, 6620, 1, 0, 0, 0, 6722, 6628, 1, 0, 0, 0, 6722,
		6636, 1, 0, 0, 0, 6722, 6645, 1, 0, 0, 0, 6722, 6655, 1, 0, 0, 0, 6722,
		6665, 1, 0, 0, 0, 6722, 6678, 1, 0, 0, 0, 6722, 6688, 1, 0, 0, 0, 6722,
		6689, 1, 0, 0, 0, 6722, 6693, 1, 0, 0, 0, 6722, 6703, 1, 0, 0, 0, 6722,
		6704, 1, 0, 0, 0, 6722, 6720, 1, 0, 0, 0, 6723, 605, 1, 0, 0, 0, 6724,
		6725, 5, 1154, 0, 0, 6725, 6730, 5, 1169, 0, 0, 6726, 6727, 5, 1156, 0,
		0, 6727, 6729, 5, 1169, 0, 0, 6728, 6726, 1, 0, 0, 0, 6729, 6732, 1, 0,
		0, 0, 6730, 6728, 1, 0, 0, 0, 6730, 6731, 1, 0, 0, 0, 6731, 6733, 1, 0,
		0, 0, 6732, 6730, 1, 0, 0, 0, 6733, 6734, 5, 1155, 0, 0, 6734, 607, 1,
		0, 0, 0, 6735, 6737, 7, 120, 0, 0, 6736, 6738, 3, 610, 305, 0, 6737, 6736,
		1, 0, 0, 0, 6737, 6738, 1, 0, 0, 0, 6738, 6758, 1, 0, 0, 0, 6739, 6741,
		5, 222, 0, 0, 6740, 6742, 3, 610, 305, 0, 6741, 6740, 1, 0, 0, 0, 6741,
		6742, 1, 0, 0, 0, 6742, 6746, 1, 0, 0, 0, 6743, 6744, 3, 66, 33, 0, 6744,
		6745, 3, 568, 284, 0, 6745, 6747, 1, 0, 0, 0, 6746, 6743, 1, 0, 0, 0, 6746,
		6747, 1, 0, 0, 0, 6747, 6758, 1, 0, 0, 0, 6748, 6758, 7, 121, 0, 0, 6749,
		6751, 5, 214, 0, 0, 6750, 6752, 3, 614, 307, 0, 6751, 6750, 1, 0, 0, 0,
		6751, 6752, 1, 0, 0, 0, 6752, 6758, 1, 0, 0, 0, 6753, 6755, 7, 122, 0,
		0, 6754, 6756, 5, 206, 0, 0, 6755, 6754, 1, 0, 0, 0, 6755, 6756, 1, 0,
		0, 0, 6756, 6758, 1, 0, 0, 0, 6757, 6735, 1, 0, 0, 0, 6757, 6739, 1, 0,
		0, 0, 6757, 6748, 1, 0, 0, 0, 6757, 6749, 1, 0, 0, 0, 6757, 6753, 1, 0,
		0, 0, 6758, 6760, 1, 0, 0, 0, 6759, 6761, 5, 11, 0, 0, 6760, 6759, 1, 0,
		0, 0, 6760, 6761, 1, 0, 0, 0, 6761, 609, 1, 0, 0, 0, 6762, 6763, 5, 1154,
		0, 0, 6763, 6764, 3, 590, 295, 0, 6764, 6765, 5, 1155, 0, 0, 6765, 611,
		1, 0, 0, 0, 6766, 6767, 5, 1154, 0, 0, 6767, 6768, 3, 590, 295, 0, 6768,
		6769, 5, 1156, 0, 0, 6769, 6770, 3, 590, 295, 0, 6770, 6771, 5, 1155, 0,
		0, 6771, 613, 1, 0, 0, 0, 6772, 6773, 5, 1154, 0, 0, 6773, 6776, 3, 590,
		295, 0, 6774, 6775, 5, 1156, 0, 0, 6775, 6777, 3, 590, 295, 0, 6776, 6774,
		1, 0, 0, 0, 6776, 6777, 1, 0, 0, 0, 6777, 6778, 1, 0, 0, 0, 6778, 6779,
		5, 1155, 0, 0, 6779, 615, 1, 0, 0, 0, 6780, 6785, 3, 584, 292, 0, 6781,
		6782, 5, 1156, 0, 0, 6782, 6784, 3, 584, 292, 0, 6783, 6781, 1, 0, 0, 0,
		6784, 6787, 1, 0, 0, 0, 6785, 6783, 1, 0, 0, 0, 6785, 6786, 1, 0, 0, 0,
		6786, 617, 1, 0, 0, 0, 6787, 6785, 1, 0, 0, 0, 6788, 6793, 3, 556, 278,
		0, 6789, 6790, 5, 1156, 0, 0, 6790, 6792, 3, 556, 278, 0, 6791, 6789, 1,
		0, 0, 0, 6792, 6795, 1, 0, 0, 0, 6793, 6791, 1, 0, 0, 0, 6793, 6794, 1,
		0, 0, 0, 6794, 619, 1, 0, 0, 0, 6795, 6793, 1, 0, 0, 0, 6796, 6797, 5,
		1154, 0, 0, 6797, 6802, 3, 562, 281, 0, 6798, 6799, 5, 1156, 0, 0, 6799,
		6801, 3, 562, 281, 0, 6800, 6798, 1, 0, 0, 0, 6801, 6804, 1, 0, 0, 0, 6802,
		6800, 1, 0, 0, 0, 6802, 6803, 1, 0, 0, 0, 6803, 6805, 1, 0, 0, 0, 6804,
		6802, 1, 0, 0, 0, 6805, 6806, 5, 1155, 0, 0, 6806, 621, 1, 0, 0, 0, 6807,
		6812, 3, 688, 344, 0, 6808, 6809, 5, 1156, 0, 0, 6809, 6811, 3, 688, 344,
		0, 6810, 6808, 1, 0, 0, 0, 6811, 6814, 1, 0, 0, 0, 6812, 6810, 1, 0, 0,
		0, 6812, 6813, 1, 0, 0, 0, 6813, 623, 1, 0, 0, 0, 6814, 6812, 1, 0, 0,
		0, 6815, 6820, 3, 636, 318, 0, 6816, 6817, 5, 1156, 0, 0, 6817, 6819, 3,
		636, 318, 0, 6818, 6816, 1, 0, 0, 0, 6819, 6822, 1, 0, 0, 0, 6820, 6818,
		1, 0, 0, 0, 6820, 6821, 1, 0, 0, 0, 6821, 625, 1, 0, 0, 0, 6822, 6820,
		1, 0, 0, 0, 6823, 6828, 3, 602, 301, 0, 6824, 6825, 5, 1156, 0, 0, 6825,
		6827, 3, 602, 301, 0, 6826, 6824, 1, 0, 0, 0, 6827, 6830, 1, 0, 0, 0, 6828,
		6826, 1, 0, 0, 0, 6828, 6829, 1, 0, 0, 0, 6829, 627, 1, 0, 0, 0, 6830,
		6828, 1, 0, 0, 0, 6831, 6836, 5, 1169, 0, 0, 6832, 6833, 5, 1156, 0, 0,
		6833, 6835, 5, 1169, 0, 0, 6834, 6832, 1, 0, 0, 0, 6835, 6838, 1, 0, 0,
		0, 6836, 6834, 1, 0, 0, 0, 6836, 6837, 1, 0, 0, 0, 6837, 629, 1, 0, 0,
		0, 6838, 6836, 1, 0, 0, 0, 6839, 6844, 5, 1182, 0, 0, 6840, 6841, 5, 1156,
		0, 0, 6841, 6843, 5, 1182, 0, 0, 6842, 6840, 1, 0, 0, 0, 6843, 6846, 1,
		0, 0, 0, 6844, 6842, 1, 0, 0, 0, 6844, 6845, 1, 0, 0, 0, 6845, 631, 1,
		0, 0, 0, 6846, 6844, 1, 0, 0, 0, 6847, 6883, 5, 116, 0, 0, 6848, 6849,
		5, 24, 0, 0, 6849, 6850, 5, 1154, 0, 0, 6850, 6851, 3, 688, 344, 0, 6851,
		6852, 5, 12, 0, 0, 6852, 6853, 3, 608, 304, 0, 6853, 6854, 5, 1155, 0,
		0, 6854, 6883, 1, 0, 0, 0, 6855, 6857, 3, 694, 347, 0, 6856, 6855, 1, 0,
		0, 0, 6856, 6857, 1, 0, 0, 0, 6857, 6858, 1, 0, 0, 0, 6858, 6883, 3, 602,
		301, 0, 6859, 6863, 3, 634, 317, 0, 6860, 6861, 5, 118, 0, 0, 6861, 6862,
		5, 184, 0, 0, 6862, 6864, 3, 634, 317, 0, 6863, 6860, 1, 0, 0, 0, 6863,
		6864, 1, 0, 0, 0, 6864, 6883, 1, 0, 0, 0, 6865, 6866, 5, 1154, 0, 0, 6866,
		6867, 3, 688, 344, 0, 6867, 6868, 5, 1155, 0, 0, 6868, 6883, 1, 0, 0, 0,
		6869, 6870, 7, 123, 0, 0, 6870, 6871, 5, 1154, 0, 0, 6871, 6872, 3, 554,
		277, 0, 6872, 6873, 5, 1155, 0, 0, 6873, 6883, 1, 0, 0, 0, 6874, 6875,
		5, 1154, 0, 0, 6875, 6876, 7, 124, 0, 0, 6876, 6877, 5, 673, 0, 0, 6877,
		6878, 5, 65, 0, 0, 6878, 6879, 3, 554, 277, 0, 6879, 6880, 5, 1155, 0,
		0, 6880, 6883, 1, 0, 0, 0, 6881, 6883, 3, 688, 344, 0, 6882, 6847, 1, 0,
		0, 0, 6882, 6848, 1, 0, 0, 0, 6882, 6856, 1, 0, 0, 0, 6882, 6859, 1, 0,
		0, 0, 6882, 6865, 1, 0, 0, 0, 6882, 6869, 1, 0, 0, 0, 6882, 6874, 1, 0,
		0, 0, 6882, 6881, 1, 0, 0, 0, 6883, 633, 1, 0, 0, 0, 6884, 6890, 7, 125,
		0, 0, 6885, 6887, 5, 1154, 0, 0, 6886, 6888, 3, 590, 295, 0, 6887, 6886,
		1, 0, 0, 0, 6887, 6888, 1, 0, 0, 0, 6888, 6889, 1, 0, 0, 0, 6889, 6891,
		5, 1155, 0, 0, 6890, 6885, 1, 0, 0, 0, 6890, 6891, 1, 0, 0, 0, 6891, 6899,
		1, 0, 0, 0, 6892, 6893, 5, 323, 0, 0, 6893, 6895, 5, 1154, 0, 0, 6894,
		6896, 3, 590, 295, 0, 6895, 6894, 1, 0, 0, 0, 6895, 6896, 1, 0, 0, 0, 6896,
		6897, 1, 0, 0, 0, 6897, 6899, 5, 1155, 0, 0, 6898, 6884, 1, 0, 0, 0, 6898,
		6892, 1, 0, 0, 0, 6899, 635, 1, 0, 0, 0, 6900, 6903, 3, 688, 344, 0, 6901,
		6903, 5, 43, 0, 0, 6902, 6900, 1, 0, 0, 0, 6902, 6901, 1, 0, 0, 0, 6903,
		637, 1, 0, 0, 0, 6904, 6905, 5, 77, 0, 0, 6905, 6906, 5, 60, 0, 0, 6906,
		639, 1, 0, 0, 0, 6907, 6908, 5, 77, 0, 0, 6908, 6909, 5, 114, 0, 0, 6909,
		6910, 5, 60, 0, 0, 6910, 641, 1, 0, 0, 0, 6911, 6912, 5, 123, 0, 0, 6912,
		6913, 5, 142, 0, 0, 6913, 643, 1, 0, 0, 0, 6914, 6915, 5, 678, 0, 0, 6915,
		6918, 3, 590, 295, 0, 6916, 6918, 5, 528, 0, 0, 6917, 6914, 1, 0, 0, 0,
		6917, 6916, 1, 0, 0, 0, 6918, 645, 1, 0, 0, 0, 6919, 6923, 3, 644, 322,
		0, 6920, 6921, 5, 158, 0, 0, 6921, 6923, 5, 104, 0, 0, 6922, 6919, 1, 0,
		0, 0, 6922, 6920, 1, 0, 0, 0, 6923, 647, 1, 0, 0, 0, 6924, 6943, 3, 650,
		325, 0, 6925, 6943, 3, 658, 329, 0, 6926, 6943, 3, 660, 330, 0, 6927, 6928,
		3, 680, 340, 0, 6928, 6930, 5, 1154, 0, 0, 6929, 6931, 3, 684, 342, 0,
		6930, 6929, 1, 0, 0, 0, 6930, 6931, 1, 0, 0, 0, 6931, 6932, 1, 0, 0, 0,
		6932, 6933, 5, 1155, 0, 0, 6933, 6943, 1, 0, 0, 0, 6934, 6935, 3, 554,
		277, 0, 6935, 6937, 5, 1154, 0, 0, 6936, 6938, 3, 684, 342, 0, 6937, 6936,
		1, 0, 0, 0, 6937, 6938, 1, 0, 0, 0, 6938, 6939, 1, 0, 0, 0, 6939, 6940,
		5, 1155, 0, 0, 6940, 6943, 1, 0, 0, 0, 6941, 6943, 3, 682, 341, 0, 6942,
		6924, 1, 0, 0, 0, 6942, 6925, 1, 0, 0, 0, 6942, 6926, 1, 0, 0, 0, 6942,
		6927, 1, 0, 0, 0, 6942, 6934, 1, 0, 0, 0, 6942, 6941, 1, 0, 0, 0, 6943,
		649, 1, 0, 0, 0, 6944, 6947, 7, 126, 0, 0, 6945, 6946, 5, 1154, 0, 0, 6946,
		6948, 5, 1155, 0, 0, 6947, 6945, 1, 0, 0, 0, 6947, 6948, 1, 0, 0, 0, 6948,
		7123, 1, 0, 0, 0, 6949, 6950, 5, 33, 0, 0, 6950, 6951, 5, 1154, 0, 0, 6951,
		6952, 3, 688, 344, 0, 6952, 6953, 5, 1156, 0, 0, 6953, 6954, 3, 608, 304,
		0, 6954, 6955, 5, 1155, 0, 0, 6955, 7123, 1, 0, 0, 0, 6956, 6957, 5, 33,
		0, 0, 6957, 6958, 5, 1154, 0, 0, 6958, 6959, 3, 688, 344, 0, 6959, 6960,
		5, 187, 0, 0, 6960, 6961, 3, 568, 284, 0, 6961, 6962, 5, 1155, 0, 0, 6962,
		7123, 1, 0, 0, 0, 6963, 6964, 5, 24, 0, 0, 6964, 6965, 5, 1154, 0, 0, 6965,
		6966, 3, 688, 344, 0, 6966, 6967, 5, 12, 0, 0, 6967, 6968, 3, 608, 304,
		0, 6968, 6969, 5, 1155, 0, 0, 6969, 7123, 1, 0, 0, 0, 6970, 6971, 5, 188,
		0, 0, 6971, 6972, 5, 1154, 0, 0, 6972, 6973, 3, 560, 280, 0, 6973, 6974,
		5, 1155, 0, 0, 6974, 7123, 1, 0, 0, 0, 6975, 6976, 5, 23, 0, 0, 6976, 6978,
		3, 688, 344, 0, 6977, 6979, 3, 652, 326, 0, 6978, 6977, 1, 0, 0, 0, 6979,
		6980, 1, 0, 0, 0, 6980, 6978, 1, 0, 0, 0, 6980, 6981, 1, 0, 0, 0, 6981,
		6984, 1, 0, 0, 0, 6982, 6983, 5, 54, 0, 0, 6983, 6985, 3, 686, 343, 0,
		6984, 6982, 1, 0, 0, 0, 6984, 6985, 1, 0, 0, 0, 6985, 6986, 1, 0, 0, 0,
		6986, 6987, 5, 407, 0, 0, 6987, 7123, 1, 0, 0, 0, 6988, 6990, 5, 23, 0,
		0, 6989, 6991, 3, 652, 326, 0, 6990, 6989, 1, 0, 0, 0, 6991, 6992, 1, 0,
		0, 0, 6992, 6990, 1, 0, 0, 0, 6992, 6993, 1, 0, 0, 0, 6993, 6996, 1, 0,
		0, 0, 6994, 6995, 5, 54, 0, 0, 6995, 6997, 3, 686, 343, 0, 6996, 6994,
		1, 0, 0, 0, 6996, 6997, 1, 0, 0, 0, 6997, 6998, 1, 0, 0, 0, 6998, 6999,
		5, 407, 0, 0, 6999, 7123, 1, 0, 0, 0, 7000, 7001, 5, 222, 0, 0, 7001, 7002,
		5, 1154, 0, 0, 7002, 7005, 3, 684, 342, 0, 7003, 7004, 5, 187, 0, 0, 7004,
		7006, 3, 568, 284, 0, 7005, 7003, 1, 0, 0, 0, 7005, 7006, 1, 0, 0, 0, 7006,
		7007, 1, 0, 0, 0, 7007, 7008, 5, 1155, 0, 0, 7008, 7123, 1, 0, 0, 0, 7009,
		7010, 5, 324, 0, 0, 7010, 7013, 5, 1154, 0, 0, 7011, 7014, 3, 594, 297,
		0, 7012, 7014, 3, 688, 344, 0, 7013, 7011, 1, 0, 0, 0, 7013, 7012, 1, 0,
		0, 0, 7014, 7015, 1, 0, 0, 0, 7015, 7018, 5, 80, 0, 0, 7016, 7019, 3, 594,
		297, 0, 7017, 7019, 3, 688, 344, 0, 7018, 7016, 1, 0, 0, 0, 7018, 7017,
		1, 0, 0, 0, 7019, 7020, 1, 0, 0, 0, 7020, 7021, 5, 1155, 0, 0, 7021, 7123,
		1, 0, 0, 0, 7022, 7023, 7, 127, 0, 0, 7023, 7026, 5, 1154, 0, 0, 7024,
		7027, 3, 594, 297, 0, 7025, 7027, 3, 688, 344, 0, 7026, 7024, 1, 0, 0,
		0, 7026, 7025, 1, 0, 0, 0, 7027, 7028, 1, 0, 0, 0, 7028, 7031, 5, 68, 0,
		0, 7029, 7032, 3, 590, 295, 0, 7030, 7032, 3, 688, 344, 0, 7031, 7029,
		1, 0, 0, 0, 7031, 7030, 1, 0, 0, 0, 7032, 7038, 1, 0, 0, 0, 7033, 7036,
		5, 65, 0, 0, 7034, 7037, 3, 590, 295, 0, 7035, 7037, 3, 688, 344, 0, 7036,
		7034, 1, 0, 0, 0, 7036, 7035, 1, 0, 0, 0, 7037, 7039, 1, 0, 0, 0, 7038,
		7033, 1, 0, 0, 0, 7038, 7039, 1, 0, 0, 0, 7039, 7040, 1, 0, 0, 0, 7040,
		7041, 5, 1155, 0, 0, 7041, 7123, 1, 0, 0, 0, 7042, 7043, 5, 328, 0, 0,
		7043, 7044, 5, 1154, 0, 0, 7044, 7047, 7, 128, 0, 0, 7045, 7048, 3, 594,
		297, 0, 7046, 7048, 3, 688, 344, 0, 7047, 7045, 1, 0, 0, 0, 7047, 7046,
		1, 0, 0, 0, 7047, 7048, 1, 0, 0, 0, 7048, 7049, 1, 0, 0, 0, 7049, 7052,
		5, 68, 0, 0, 7050, 7053, 3, 594, 297, 0, 7051, 7053, 3, 688, 344, 0, 7052,
		7050, 1, 0, 0, 0, 7052, 7051, 1, 0, 0, 0, 7053, 7054, 1, 0, 0, 0, 7054,
		7055, 5, 1155, 0, 0, 7055, 7123, 1, 0, 0, 0, 7056, 7057, 5, 328, 0, 0,
		7057, 7060, 5, 1154, 0, 0, 7058, 7061, 3, 594, 297, 0, 7059, 7061, 3, 688,
		344, 0, 7060, 7058, 1, 0, 0, 0, 7060, 7059, 1, 0, 0, 0, 7061, 7062, 1,
		0, 0, 0, 7062, 7065, 5, 68, 0, 0, 7063, 7066, 3, 594, 297, 0, 7064, 7066,
		3, 688, 344, 0, 7065, 7063, 1, 0, 0, 0, 7065, 7064, 1, 0, 0, 0, 7066, 7067,
		1, 0, 0, 0, 7067, 7068, 5, 1155, 0, 0, 7068, 7123, 1, 0, 0, 0, 7069, 7070,
		5, 1108, 0, 0, 7070, 7073, 5, 1154, 0, 0, 7071, 7074, 3, 594, 297, 0, 7072,
		7074, 3, 688, 344, 0, 7073, 7071, 1, 0, 0, 0, 7073, 7072, 1, 0, 0, 0, 7074,
		7081, 1, 0, 0, 0, 7075, 7076, 5, 12, 0, 0, 7076, 7077, 7, 129, 0, 0, 7077,
		7078, 5, 1154, 0, 0, 7078, 7079, 3, 590, 295, 0, 7079, 7080, 5, 1155, 0,
		0, 7080, 7082, 1, 0, 0, 0, 7081, 7075, 1, 0, 0, 0, 7081, 7082, 1, 0, 0,
		0, 7082, 7084, 1, 0, 0, 0, 7083, 7085, 3, 654, 327, 0, 7084, 7083, 1, 0,
		0, 0, 7084, 7085, 1, 0, 0, 0, 7085, 7086, 1, 0, 0, 0, 7086, 7087, 5, 1155,
		0, 0, 7087, 7123, 1, 0, 0, 0, 7088, 7089, 5, 321, 0, 0, 7089, 7090, 5,
		1154, 0, 0, 7090, 7091, 3, 78, 39, 0, 7091, 7094, 5, 68, 0, 0, 7092, 7095,
		3, 594, 297, 0, 7093, 7095, 3, 688, 344, 0, 7094, 7092, 1, 0, 0, 0, 7094,
		7093, 1, 0, 0, 0, 7095, 7096, 1, 0, 0, 0, 7096, 7097, 5, 1155, 0, 0, 7097,
		7123, 1, 0, 0, 0, 7098, 7099, 5, 907, 0, 0, 7099, 7100, 5, 1154, 0, 0,
		7100, 7101, 7, 130, 0, 0, 7101, 7102, 5, 1156, 0, 0, 7102, 7103, 3, 594,
		297, 0, 7103, 7104, 5, 1155, 0, 0, 7104, 7123, 1, 0, 0, 0, 7105, 7106,
		5, 282, 0, 0, 7106, 7107, 5, 1154, 0, 0, 7107, 7108, 3, 688, 344, 0, 7108,
		7109, 5, 1156, 0, 0, 7109, 7112, 3, 688, 344, 0, 7110, 7111, 5, 595, 0,
		0, 7111, 7113, 3, 608, 304, 0, 7112, 7110, 1, 0, 0, 0, 7112, 7113, 1, 0,
		0, 0, 7113, 7115, 1, 0, 0, 0, 7114, 7116, 3, 274, 137, 0, 7115, 7114, 1,
		0, 0, 0, 7115, 7116, 1, 0, 0, 0, 7116, 7118, 1, 0, 0, 0, 7117, 7119, 3,
		276, 138, 0, 7118, 7117, 1, 0, 0, 0, 7118, 7119, 1, 0, 0, 0, 7119, 7120,
		1, 0, 0, 0, 7120, 7121, 5, 1155, 0, 0, 7121, 7123, 1, 0, 0, 0, 7122, 6944,
		1, 0, 0, 0, 7122, 6949, 1, 0, 0, 0, 7122, 6956, 1, 0, 0, 0, 7122, 6963,
		1, 0, 0, 0, 7122, 6970, 1, 0, 0, 0, 7122, 6975, 1, 0, 0, 0, 7122, 6988,
		1, 0, 0, 0, 7122, 7000, 1, 0, 0, 0, 7122, 7009, 1, 0, 0, 0, 7122, 7022,
		1, 0, 0, 0, 7122, 7042, 1, 0, 0, 0, 7122, 7056, 1, 0, 0, 0, 7122, 7069,
		1, 0, 0, 0, 7122, 7088, 1, 0, 0, 0, 7122, 7098, 1, 0, 0, 0, 7122, 7105,
		1, 0, 0, 0, 7123, 651, 1, 0, 0, 0, 7124, 7125, 5, 189, 0, 0, 7125, 7126,
		3, 686, 343, 0, 7126, 7127, 5, 174, 0, 0, 7127, 7128, 3, 686, 343, 0, 7128,
		653, 1, 0, 0, 0, 7129, 7130, 5, 472, 0, 0, 7130, 7135, 3, 656, 328, 0,
		7131, 7132, 5, 1156, 0, 0, 7132, 7134, 3, 656, 328, 0, 7133, 7131, 1, 0,
		0, 0, 7134, 7137, 1, 0, 0, 0, 7135, 7133, 1, 0, 0, 0, 7135, 7136, 1, 0,
		0, 0, 7136, 7144, 1, 0, 0, 0, 7137, 7135, 1, 0, 0, 0, 7138, 7139, 5, 472,
		0, 0, 7139, 7140, 3, 590, 295, 0, 7140, 7141, 5, 1142, 0, 0, 7141, 7142,
		3, 590, 295, 0, 7142, 7144, 1, 0, 0, 0, 7143, 7129, 1, 0, 0, 0, 7143, 7138,
		1, 0, 0, 0, 7144, 655, 1, 0, 0, 0, 7145, 7147, 3, 590, 295, 0, 7146, 7148,
		7, 131, 0, 0, 7147, 7146, 1, 0, 0, 0, 7147, 7148, 1, 0, 0, 0, 7148, 657,
		1, 0, 0, 0, 7149, 7150, 7, 132, 0, 0, 7150, 7152, 5, 1154, 0, 0, 7151,
		7153, 7, 48, 0, 0, 7152, 7151, 1, 0, 0, 0, 7152, 7153, 1, 0, 0, 0, 7153,
		7154, 1, 0, 0, 0, 7154, 7155, 3, 686, 343, 0, 7155, 7157, 5, 1155, 0, 0,
		7156, 7158, 3, 662, 331, 0, 7157, 7156, 1, 0, 0, 0, 7157, 7158, 1, 0, 0,
		0, 7158, 7209, 1, 0, 0, 0, 7159, 7160, 5, 290, 0, 0, 7160, 7168, 5, 1154,
		0, 0, 7161, 7169, 5, 1138, 0, 0, 7162, 7164, 5, 6, 0, 0, 7163, 7162, 1,
		0, 0, 0, 7163, 7164, 1, 0, 0, 0, 7164, 7165, 1, 0, 0, 0, 7165, 7169, 3,
		686, 343, 0, 7166, 7167, 5, 50, 0, 0, 7167, 7169, 3, 684, 342, 0, 7168,
		7161, 1, 0, 0, 0, 7168, 7163, 1, 0, 0, 0, 7168, 7166, 1, 0, 0, 0, 7169,
		7170, 1, 0, 0, 0, 7170, 7172, 5, 1155, 0, 0, 7171, 7173, 3, 662, 331, 0,
		7172, 7171, 1, 0, 0, 0, 7172, 7173, 1, 0, 0, 0, 7173, 7209, 1, 0, 0, 0,
		7174, 7175, 7, 133, 0, 0, 7175, 7177, 5, 1154, 0, 0, 7176, 7178, 5, 6,
		0, 0, 7177, 7176, 1, 0, 0, 0, 7177, 7178, 1, 0, 0, 0, 7178, 7179, 1, 0,
		0, 0, 7179, 7180, 3, 686, 343, 0, 7180, 7182, 5, 1155, 0, 0, 7181, 7183,
		3, 662, 331, 0, 7182, 7181, 1, 0, 0, 0, 7182, 7183, 1, 0, 0, 0, 7183, 7209,
		1, 0, 0, 0, 7184, 7185, 5, 294, 0, 0, 7185, 7187, 5, 1154, 0, 0, 7186,
		7188, 5, 50, 0, 0, 7187, 7186, 1, 0, 0, 0, 7187, 7188, 1, 0, 0, 0, 7188,
		7189, 1, 0, 0, 0, 7189, 7200, 3, 684, 342, 0, 7190, 7191, 5, 124, 0, 0,
		7191, 7192, 5, 20, 0, 0, 7192, 7197, 3, 240, 120, 0, 7193, 7194, 5, 1156,
		0, 0, 7194, 7196, 3, 240, 120, 0, 7195, 7193, 1, 0, 0, 0, 7196, 7199, 1,
		0, 0, 0, 7197, 7195, 1, 0, 0, 0, 7197, 7198, 1, 0, 0, 0, 7198, 7201, 1,
		0, 0, 0, 7199, 7197, 1, 0, 0, 0, 7200, 7190, 1, 0, 0, 0, 7200, 7201, 1,
		0, 0, 0, 7201, 7204, 1, 0, 0, 0, 7202, 7203, 5, 155, 0, 0, 7203, 7205,
		5, 1169, 0, 0, 7204, 7202, 1, 0, 0, 0, 7204, 7205, 1, 0, 0, 0, 7205, 7206,
		1, 0, 0, 0, 7206, 7207, 5, 1155, 0, 0, 7207, 7209, 1, 0, 0, 0, 7208, 7149,
		1, 0, 0, 0, 7208, 7159, 1, 0, 0, 0, 7208, 7174, 1, 0, 0, 0, 7208, 7184,
		1, 0, 0, 0, 7209, 659, 1, 0, 0, 0, 7210, 7211, 7, 134, 0, 0, 7211, 7212,
		5, 1154, 0, 0, 7212, 7215, 3, 688, 344, 0, 7213, 7214, 5, 1156, 0, 0, 7214,
		7216, 3, 590, 295, 0, 7215, 7213, 1, 0, 0, 0, 7215, 7216, 1, 0, 0, 0, 7216,
		7219, 1, 0, 0, 0, 7217, 7218, 5, 1156, 0, 0, 7218, 7220, 3, 590, 295, 0,
		7219, 7217, 1, 0, 0, 0, 7219, 7220, 1, 0, 0, 0, 7220, 7221, 1, 0, 0, 0,
		7221, 7222, 5, 1155, 0, 0, 7222, 7223, 3, 662, 331, 0, 7223, 7249, 1, 0,
		0, 0, 7224, 7225, 7, 135, 0, 0, 7225, 7226, 5, 1154, 0, 0, 7226, 7227,
		3, 688, 344, 0, 7227, 7228, 5, 1155, 0, 0, 7228, 7229, 3, 662, 331, 0,
		7229, 7249, 1, 0, 0, 0, 7230, 7231, 7, 136, 0, 0, 7231, 7232, 5, 1154,
		0, 0, 7232, 7233, 5, 1155, 0, 0, 7233, 7249, 3, 662, 331, 0, 7234, 7235,
		5, 301, 0, 0, 7235, 7236, 5, 1154, 0, 0, 7236, 7237, 3, 688, 344, 0, 7237,
		7238, 5, 1156, 0, 0, 7238, 7239, 3, 590, 295, 0, 7239, 7240, 5, 1155, 0,
		0, 7240, 7241, 3, 662, 331, 0, 7241, 7249, 1, 0, 0, 0, 7242, 7243, 5, 300,
		0, 0, 7243, 7244, 5, 1154, 0, 0, 7244, 7245, 3, 590, 295, 0, 7245, 7246,
		5, 1155, 0, 0, 7246, 7247, 3, 662, 331, 0, 7247, 7249, 1, 0, 0, 0, 7248,
		7210, 1, 0, 0, 0, 7248, 7224, 1, 0, 0, 0, 7248, 7230, 1, 0, 0, 0, 7248,
		7234, 1, 0, 0, 0, 7248, 7242, 1, 0, 0, 0, 7249, 661, 1, 0, 0, 0, 7250,
		7257, 5, 128, 0, 0, 7251, 7253, 5, 1154, 0, 0, 7252, 7254, 3, 664, 332,
		0, 7253, 7252, 1, 0, 0, 0, 7253, 7254, 1, 0, 0, 0, 7254, 7255, 1, 0, 0,
		0, 7255, 7258, 5, 1155, 0, 0, 7256, 7258, 3, 666, 333, 0, 7257, 7251, 1,
		0, 0, 0, 7257, 7256, 1, 0, 0, 0, 7258, 663, 1, 0, 0, 0, 7259, 7261, 3,
		666, 333, 0, 7260, 7259, 1, 0, 0, 0, 7260, 7261, 1, 0, 0, 0, 7261, 7263,
		1, 0, 0, 0, 7262, 7264, 3, 678, 339, 0, 7263, 7262, 1, 0, 0, 0, 7263, 7264,
		1, 0, 0, 0, 7264, 7266, 1, 0, 0, 0, 7265, 7267, 3, 238, 119, 0, 7266, 7265,
		1, 0, 0, 0, 7266, 7267, 1, 0, 0, 0, 7267, 7269, 1, 0, 0, 0, 7268, 7270,
		3, 668, 334, 0, 7269, 7268, 1, 0, 0, 0, 7269, 7270, 1, 0, 0, 0, 7270, 665,
		1, 0, 0, 0, 7271, 7272, 3, 584, 292, 0, 7272, 667, 1, 0, 0, 0, 7273, 7274,
		3, 670, 335, 0, 7274, 7275, 3, 672, 336, 0, 7275, 669, 1, 0, 0, 0, 7276,
		7277, 7, 137, 0, 0, 7277, 671, 1, 0, 0, 0, 7278, 7281, 3, 676, 338, 0,
		7279, 7281, 3, 674, 337, 0, 7280, 7278, 1, 0, 0, 0, 7280, 7279, 1, 0, 0,
		0, 7281, 673, 1, 0, 0, 0, 7282, 7283, 5, 16, 0, 0, 7283, 7284, 3, 676,
		338, 0, 7284, 7285, 5, 10, 0, 0, 7285, 7286, 3, 676, 338, 0, 7286, 675,
		1, 0, 0, 0, 7287, 7288, 5, 36, 0, 0, 7288, 7295, 5, 602, 0, 0, 7289, 7290,
		5, 661, 0, 0, 7290, 7295, 7, 138, 0, 0, 7291, 7292, 3, 688, 344, 0, 7292,
		7293, 7, 138, 0, 0, 7293, 7295, 1, 0, 0, 0, 7294, 7287, 1, 0, 0, 0, 7294,
		7289, 1, 0, 0, 0, 7294, 7291, 1, 0, 0, 0, 7295, 677, 1, 0, 0, 0, 7296,
		7297, 5, 129, 0, 0, 7297, 7298, 5, 20, 0, 0, 7298, 7303, 3, 688, 344, 0,
		7299, 7300, 5, 1156, 0, 0, 7300, 7302, 3, 688, 344, 0, 7301, 7299, 1, 0,
		0, 0, 7302, 7305, 1, 0, 0, 0, 7303, 7301, 1, 0, 0, 0, 7303, 7304, 1, 0,
		0, 0, 7304, 679, 1, 0, 0, 0, 7305, 7303, 1, 0, 0, 0, 7306, 7330, 3, 718,
		359, 0, 7307, 7330, 5, 754, 0, 0, 7308, 7330, 5, 317, 0, 0, 7309, 7330,
		5, 313, 0, 0, 7310, 7330, 5, 314, 0, 0, 7311, 7330, 5, 315, 0, 0, 7312,
		7330, 5, 318, 0, 0, 7313, 7330, 5, 319, 0, 0, 7314, 7330, 5, 320, 0, 0,
		7315, 7330, 5, 77, 0, 0, 7316, 7330, 5, 85, 0, 0, 7317, 7330, 5, 316, 0,
		0, 7318, 7330, 5, 322, 0, 0, 7319, 7330, 5, 509, 0, 0, 7320, 7330, 5, 323,
		0, 0, 7321, 7330, 5, 142, 0, 0, 7322, 7330, 5, 325, 0, 0, 7323, 7330, 5,
		326, 0, 0, 7324, 7330, 5, 327, 0, 0, 7325, 7330, 5, 328, 0, 0, 7326, 7330,
		5, 329, 0, 0, 7327, 7330, 5, 330, 0, 0, 7328, 7330, 5, 331, 0, 0, 7329,
		7306, 1, 0, 0, 0, 7329, 7307, 1, 0, 0, 0, 7329, 7308, 1, 0, 0, 0, 7329,
		7309, 1, 0, 0, 0, 7329, 7310, 1, 0, 0, 0, 7329, 7311, 1, 0, 0, 0, 7329,
		7312, 1, 0, 0, 0, 7329, 7313, 1, 0, 0, 0, 7329, 7314, 1, 0, 0, 0, 7329,
		7315, 1, 0, 0, 0, 7329, 7316, 1, 0, 0, 0, 7329, 7317, 1, 0, 0, 0, 7329,
		7318, 1, 0, 0, 0, 7329, 7319, 1, 0, 0, 0, 7329, 7320, 1, 0, 0, 0, 7329,
		7321, 1, 0, 0, 0, 7329, 7322, 1, 0, 0, 0, 7329, 7323, 1, 0, 0, 0, 7329,
		7324, 1, 0, 0, 0, 7329, 7325, 1, 0, 0, 0, 7329, 7326, 1, 0, 0, 0, 7329,
		7327, 1, 0, 0, 0, 7329, 7328, 1, 0, 0, 0, 7330, 681, 1, 0, 0, 0, 7331,
		7332, 7, 139, 0, 0, 7332, 7333, 5, 1154, 0, 0, 7333, 7334, 3, 686, 343,
		0, 7334, 7335, 5, 1155, 0, 0, 7335, 683, 1, 0, 0, 0, 7336, 7341, 3, 602,
		301, 0, 7337, 7341, 3, 560, 280, 0, 7338, 7341, 3, 648, 324, 0, 7339, 7341,
		3, 688, 344, 0, 7340, 7336, 1, 0, 0, 0, 7340, 7337, 1, 0, 0, 0, 7340, 7338,
		1, 0, 0, 0, 7340, 7339, 1, 0, 0, 0, 7341, 7351, 1, 0, 0, 0, 7342, 7347,
		5, 1156, 0, 0, 7343, 7348, 3, 602, 301, 0, 7344, 7348, 3, 560, 280, 0,
		7345, 7348, 3, 648, 324, 0, 7346, 7348, 3, 688, 344, 0, 7347, 7343, 1,
		0, 0, 0, 7347, 7344, 1, 0, 0, 0, 7347, 7345, 1, 0, 0, 0, 7347, 7346, 1,
		0, 0, 0, 7348, 7350, 1, 0, 0, 0, 7349, 7342, 1, 0, 0, 0, 7350, 7353, 1,
		0, 0, 0, 7351, 7349, 1, 0, 0, 0, 7351, 7352, 1, 0, 0, 0, 7352, 685, 1,
		0, 0, 0, 7353, 7351, 1, 0, 0, 0, 7354, 7359, 3, 602, 301, 0, 7355, 7359,
		3, 560, 280, 0, 7356, 7359, 3, 648, 324, 0, 7357, 7359, 3, 688, 344, 0,
		7358, 7354, 1, 0, 0, 0, 7358, 7355, 1, 0, 0, 0, 7358, 7356, 1, 0, 0, 0,
		7358, 7357, 1, 0, 0, 0, 7359, 687, 1, 0, 0, 0, 7360, 7361, 6, 344, -1,
		0, 7361, 7362, 7, 140, 0, 0, 7362, 7372, 3, 688, 344, 4, 7363, 7364, 3,
		690, 345, 0, 7364, 7366, 5, 88, 0, 0, 7365, 7367, 5, 114, 0, 0, 7366, 7365,
		1, 0, 0, 0, 7366, 7367, 1, 0, 0, 0, 7367, 7368, 1, 0, 0, 0, 7368, 7369,
		7, 141, 0, 0, 7369, 7372, 1, 0, 0, 0, 7370, 7372, 3, 690, 345, 0, 7371,
		7360, 1, 0, 0, 0, 7371, 7363, 1, 0, 0, 0, 7371, 7370, 1, 0, 0, 0, 7372,
		7379, 1, 0, 0, 0, 7373, 7374, 10, 3, 0, 0, 7374, 7375, 3, 698, 349, 0,
		7375, 7376, 3, 688, 344, 4, 7376, 7378, 1, 0, 0, 0, 7377, 7373, 1, 0, 0,
		0, 7378, 7381, 1, 0, 0, 0, 7379, 7377, 1, 0, 0, 0, 7379, 7380, 1, 0, 0,
		0, 7380, 689, 1, 0, 0, 0, 7381, 7379, 1, 0, 0, 0, 7382, 7385, 6, 345, -1,
		0, 7383, 7384, 5, 1182, 0, 0, 7384, 7386, 5, 1129, 0, 0, 7385, 7383, 1,
		0, 0, 0, 7385, 7386, 1, 0, 0, 0, 7386, 7387, 1, 0, 0, 0, 7387, 7388, 3,
		692, 346, 0, 7388, 7453, 1, 0, 0, 0, 7389, 7390, 10, 8, 0, 0, 7390, 7391,
		3, 696, 348, 0, 7391, 7392, 3, 690, 345, 9, 7392, 7452, 1, 0, 0, 0, 7393,
		7395, 10, 6, 0, 0, 7394, 7396, 5, 114, 0, 0, 7395, 7394, 1, 0, 0, 0, 7395,
		7396, 1, 0, 0, 0, 7396, 7397, 1, 0, 0, 0, 7397, 7398, 5, 16, 0, 0, 7398,
		7399, 3, 690, 345, 0, 7399, 7400, 5, 10, 0, 0, 7400, 7401, 3, 690, 345,
		7, 7401, 7452, 1, 0, 0, 0, 7402, 7403, 10, 5, 0, 0, 7403, 7404, 5, 623,
		0, 0, 7404, 7405, 5, 98, 0, 0, 7405, 7452, 3, 690, 345, 6, 7406, 7408,
		10, 3, 0, 0, 7407, 7409, 5, 114, 0, 0, 7408, 7407, 1, 0, 0, 0, 7408, 7409,
		1, 0, 0, 0, 7409, 7410, 1, 0, 0, 0, 7410, 7411, 7, 142, 0, 0, 7411, 7452,
		3, 690, 345, 4, 7412, 7414, 10, 10, 0, 0, 7413, 7415, 5, 114, 0, 0, 7414,
		7413, 1, 0, 0, 0, 7414, 7415, 1, 0, 0, 0, 7415, 7416, 1, 0, 0, 0, 7416,
		7417, 5, 80, 0, 0, 7417, 7420, 5, 1154, 0, 0, 7418, 7421, 3, 208, 104,
		0, 7419, 7421, 3, 622, 311, 0, 7420, 7418, 1, 0, 0, 0, 7420, 7419, 1, 0,
		0, 0, 7421, 7422, 1, 0, 0, 0, 7422, 7423, 5, 1155, 0, 0, 7423, 7452, 1,
		0, 0, 0, 7424, 7425, 10, 9, 0, 0, 7425, 7426, 5, 88, 0, 0, 7426, 7452,
		3, 600, 300, 0, 7427, 7428, 10, 7, 0, 0, 7428, 7429, 3, 696, 348, 0, 7429,
		7430, 7, 143, 0, 0, 7430, 7431, 5, 1154, 0, 0, 7431, 7432, 3, 208, 104,
		0, 7432, 7433, 5, 1155, 0, 0, 7433, 7452, 1, 0, 0, 0, 7434, 7436, 10, 4,
		0, 0, 7435, 7437, 5, 114, 0, 0, 7436, 7435, 1, 0, 0, 0, 7436, 7437, 1,
		0, 0, 0, 7437, 7438, 1, 0, 0, 0, 7438, 7439, 5, 98, 0, 0, 7439, 7442, 3,
		690, 345, 0, 7440, 7441, 5, 413, 0, 0, 7441, 7443, 5, 1169, 0, 0, 7442,
		7440, 1, 0, 0, 0, 7442, 7443, 1, 0, 0, 0, 7443, 7452, 1, 0, 0, 0, 7444,
		7445, 10, 1, 0, 0, 7445, 7446, 5, 506, 0, 0, 7446, 7447, 5, 534, 0, 0,
		7447, 7448, 5, 1154, 0, 0, 7448, 7449, 3, 690, 345, 0, 7449, 7450, 5, 1155,
		0, 0, 7450, 7452, 1, 0, 0, 0, 7451, 7389, 1, 0, 0, 0, 7451, 7393, 1, 0,
		0, 0, 7451, 7402, 1, 0, 0, 0, 7451, 7406, 1, 0, 0, 0, 7451, 7412, 1, 0,
		0, 0, 7451, 7424, 1, 0, 0, 0, 7451, 7427, 1, 0, 0, 0, 7451, 7434, 1, 0,
		0, 0, 7451, 7444, 1, 0, 0, 0, 7452, 7455, 1, 0, 0, 0, 7453, 7451, 1, 0,
		0, 0, 7453, 7454, 1, 0, 0, 0, 7454, 691, 1, 0, 0, 0, 7455, 7453, 1, 0,
		0, 0, 7456, 7457, 6, 346, -1, 0, 7457, 7502, 3, 602, 301, 0, 7458, 7502,
		3, 560, 280, 0, 7459, 7502, 3, 648, 324, 0, 7460, 7502, 3, 566, 283, 0,
		7461, 7462, 3, 694, 347, 0, 7462, 7463, 3, 692, 346, 10, 7463, 7502, 1,
		0, 0, 0, 7464, 7465, 5, 226, 0, 0, 7465, 7502, 3, 692, 346, 9, 7466, 7467,
		5, 1154, 0, 0, 7467, 7472, 3, 688, 344, 0, 7468, 7469, 5, 1156, 0, 0, 7469,
		7471, 3, 688, 344, 0, 7470, 7468, 1, 0, 0, 0, 7471, 7474, 1, 0, 0, 0, 7472,
		7470, 1, 0, 0, 0, 7472, 7473, 1, 0, 0, 0, 7473, 7475, 1, 0, 0, 0, 7474,
		7472, 1, 0, 0, 0, 7475, 7476, 5, 1155, 0, 0, 7476, 7502, 1, 0, 0, 0, 7477,
		7478, 5, 602, 0, 0, 7478, 7479, 5, 1154, 0, 0, 7479, 7482, 3, 688, 344,
		0, 7480, 7481, 5, 1156, 0, 0, 7481, 7483, 3, 688, 344, 0, 7482, 7480, 1,
		0, 0, 0, 7483, 7484, 1, 0, 0, 0, 7484, 7482, 1, 0, 0, 0, 7484, 7485, 1,
		0, 0, 0, 7485, 7486, 1, 0, 0, 0, 7486, 7487, 5, 1155, 0, 0, 7487, 7502,
		1, 0, 0, 0, 7488, 7489, 5, 60, 0, 0, 7489, 7490, 5, 1154, 0, 0, 7490, 7491,
		3, 208, 104, 0, 7491, 7492, 5, 1155, 0, 0, 7492, 7502, 1, 0, 0, 0, 7493,
		7494, 5, 1154, 0, 0, 7494, 7495, 3, 208, 104, 0, 7495, 7496, 5, 1155, 0,
		0, 7496, 7502, 1, 0, 0, 0, 7497, 7498, 5, 86, 0, 0, 7498, 7499, 3, 688,
		344, 0, 7499, 7500, 3, 78, 39, 0, 7500, 7502, 1, 0, 0, 0, 7501, 7456, 1,
		0, 0, 0, 7501, 7458, 1, 0, 0, 0, 7501, 7459, 1, 0, 0, 0, 7501, 7460, 1,
		0, 0, 0, 7501, 7461, 1, 0, 0, 0, 7501, 7464, 1, 0, 0, 0, 7501, 7466, 1,
		0, 0, 0, 7501, 7477, 1, 0, 0, 0, 7501, 7488, 1, 0, 0, 0, 7501, 7493, 1,
		0, 0, 0, 7501, 7497, 1, 0, 0, 0, 7502, 7520, 1, 0, 0, 0, 7503, 7504, 10,
		3, 0, 0, 7504, 7505, 3, 700, 350, 0, 7505, 7506, 3, 692, 346, 4, 7506,
		7519, 1, 0, 0, 0, 7507, 7508, 10, 2, 0, 0, 7508, 7509, 3, 702, 351, 0,
		7509, 7510, 3, 692, 346, 3, 7510, 7519, 1, 0, 0, 0, 7511, 7512, 10, 1,
		0, 0, 7512, 7513, 3, 704, 352, 0, 7513, 7514, 3, 692, 346, 2, 7514, 7519,
		1, 0, 0, 0, 7515, 7516, 10, 12, 0, 0, 7516, 7517, 5, 28, 0, 0, 7517, 7519,
		3, 570, 285, 0, 7518, 7503, 1, 0, 0, 0, 7518, 7507, 1, 0, 0, 0, 7518, 7511,
		1, 0, 0, 0, 7518, 7515, 1, 0, 0, 0, 7519, 7522, 1, 0, 0, 0, 7520, 7518,
		1, 0, 0, 0, 7520, 7521, 1, 0, 0, 0, 7521, 693, 1, 0, 0, 0, 7522, 7520,
		1, 0, 0, 0, 7523, 7524, 7, 144, 0, 0, 7524, 695, 1, 0, 0, 0, 7525, 7540,
		5, 1145, 0, 0, 7526, 7540, 5, 1146, 0, 0, 7527, 7540, 5, 1147, 0, 0, 7528,
		7529, 5, 1147, 0, 0, 7529, 7540, 5, 1145, 0, 0, 7530, 7531, 5, 1146, 0,
		0, 7531, 7540, 5, 1145, 0, 0, 7532, 7533, 5, 1147, 0, 0, 7533, 7540, 5,
		1146, 0, 0, 7534, 7535, 5, 1148, 0, 0, 7535, 7540, 5, 1145, 0, 0, 7536,
		7537, 5, 1147, 0, 0, 7537, 7538, 5, 1145, 0, 0, 7538, 7540, 5, 1146, 0,
		0, 7539, 7525, 1, 0, 0, 0, 7539, 7526, 1, 0, 0, 0, 7539, 7527, 1, 0, 0,
		0, 7539, 7528, 1, 0, 0, 0, 7539, 7530, 1, 0, 0, 0, 7539, 7532, 1, 0, 0,
		0, 7539, 7534, 1, 0, 0, 0, 7539, 7536, 1, 0, 0, 0, 7540, 697, 1, 0, 0,
		0, 7541, 7549, 5, 10, 0, 0, 7542, 7543, 5, 1151, 0, 0, 7543, 7549, 5, 1151,
		0, 0, 7544, 7549, 5, 194, 0, 0, 7545, 7549, 5, 123, 0, 0, 7546, 7547, 5,
		1150, 0, 0, 7547, 7549, 5, 1150, 0, 0, 7548, 7541, 1, 0, 0, 0, 7548, 7542,
		1, 0, 0, 0, 7548, 7544, 1, 0, 0, 0, 7548, 7545, 1, 0, 0, 0, 7548, 7546,
		1, 0, 0, 0, 7549, 699, 1, 0, 0, 0, 7550, 7551, 5, 1147, 0, 0, 7551, 7558,
		5, 1147, 0, 0, 7552, 7553, 5, 1146, 0, 0, 7553, 7558, 5, 1146, 0, 0, 7554,
		7558, 5, 1151, 0, 0, 7555, 7558, 5, 1152, 0, 0, 7556, 7558, 5, 1150, 0,
		0, 7557, 7550, 1, 0, 0, 0, 7557, 7552, 1, 0, 0, 0, 7557, 7554, 1, 0, 0,
		0, 7557, 7555, 1, 0, 0, 0, 7557, 7556, 1, 0, 0, 0, 7558, 701, 1, 0, 0,
		0, 7559, 7560, 7, 145, 0, 0, 7560, 703, 1, 0, 0, 0, 7561, 7562, 5, 1142,
		0, 0, 7562, 7567, 5, 1146, 0, 0, 7563, 7564, 5, 1142, 0, 0, 7564, 7565,
		5, 1146, 0, 0, 7565, 7567, 5, 1146, 0, 0, 7566, 7561, 1, 0, 0, 0, 7566,
		7563, 1, 0, 0, 0, 7567, 705, 1, 0, 0, 0, 7568, 7569, 7, 146, 0, 0, 7569,
		707, 1, 0, 0, 0, 7570, 7571, 7, 147, 0, 0, 7571, 709, 1, 0, 0, 0, 7572,
		7573, 7, 148, 0, 0, 7573, 711, 1, 0, 0, 0, 7574, 7575, 7, 149, 0, 0, 7575,
		713, 1, 0, 0, 0, 7576, 7577, 7, 150, 0, 0, 7577, 715, 1, 0, 0, 0, 7578,
		7579, 7, 151, 0, 0, 7579, 717, 1, 0, 0, 0, 7580, 7581, 7, 152, 0, 0, 7581,
		719, 1, 0, 0, 0, 1118, 721, 725, 732, 735, 738, 740, 746, 749, 752, 755,
		764, 777, 825, 838, 849, 866, 871, 883, 911, 920, 925, 931, 936, 940, 949,
		952, 955, 959, 966, 969, 972, 976, 980, 986, 991, 996, 1001, 1004, 1006,
		1018, 1021, 1025, 1028, 1032, 1035, 1039, 1042, 1045, 1049, 1052, 1056,
		1062, 1065, 1071, 1077, 1084, 1091, 1094, 1097, 1101, 1106, 1112, 1121,
		1126, 1131, 1138, 1155, 1162, 1165, 1169, 1179, 1183, 1186, 1190, 1194,
		1198, 1203, 1206, 1209, 1212, 1215, 1221, 1224, 1228, 1234, 1239, 1242,
		1245, 1247, 1258, 1262, 1265, 1279, 1282, 1286, 1289, 1293, 1296, 1300,
		1303, 1307, 1310, 1313, 1317, 1320, 1324, 1330, 1333, 1346, 1352, 1363,
		1368, 1376, 1384, 1389, 1392, 1397, 1405, 1410, 1416, 1421, 1425, 1427,
		1431, 1434, 1438, 1443, 1445, 1450, 1455, 1463, 1471, 1476, 1484, 1487,
		1490, 1494, 1498, 1501, 1505, 1509, 1513, 1519, 1522, 1529, 1534, 1541,
		1548, 1554, 1562, 1565, 1572, 1575, 1577, 1583, 1589, 1606, 1613, 1620,
		1632, 1637, 1646, 1648, 1651, 1664, 1677, 1682, 1698, 1706, 1716, 1722,
		1734, 1737, 1742, 1755, 1762, 1769, 1771, 1778, 1782, 1784, 1789, 1792,
		1798, 1803, 1805, 1809, 1812, 1815, 1821, 1826, 1828, 1833, 1840, 1842,
		1849, 1854, 1858, 1861, 1869, 1877, 1879, 1887, 1891, 1894, 1900, 1905,
		1908, 1914, 1917, 1921, 1924, 1928, 1933, 1938, 1943, 1947, 1951, 1955,
		1959, 1963, 1967, 1972, 1977, 1982, 1988, 1993, 1998, 2003, 2009, 2014,
		2019, 2025, 2030, 2035, 2040, 2045, 2050, 2055, 2060, 2067, 2072, 2077,
		2082, 2086, 2091, 2099, 2104, 2110, 2122, 2129, 2131, 2139, 2144, 2147,
		2155, 2161, 2177, 2189, 2191, 2194, 2202, 2208, 2214, 2227, 2234, 2243,
		2248, 2259, 2268, 2273, 2285, 2292, 2301, 2306, 2318, 2325, 2334, 2339,
		2346, 2355, 2360, 2362, 2367, 2375, 2384, 2388, 2391, 2395, 2400, 2406,
		2412, 2417, 2422, 2427, 2432, 2435, 2440, 2445, 2455, 2459, 2466, 2471,
		2474, 2479, 2482, 2486, 2490, 2498, 2517, 2520, 2523, 2527, 2537, 2550,
		2557, 2560, 2565, 2572, 2575, 2578, 2589, 2592, 2596, 2604, 2607, 2612,
		2620, 2626, 2630, 2635, 2641, 2645, 2650, 2655, 2658, 2665, 2669, 2672,
		2683, 2691, 2694, 2697, 2703, 2709, 2711, 2716, 2719, 2725, 2731, 2733,
		2737, 2740, 2743, 2746, 2752, 2758, 2761, 2767, 2773, 2775, 2780, 2783,
		2791, 2793, 2802, 2807, 2815, 2819, 2822, 2830, 2840, 2845, 2848, 2855,
		2859, 2862, 2866, 2871, 2880, 2898, 2907, 2911, 2923, 2926, 2935, 2947,
		2955, 2963, 2970, 2977, 2984, 2999, 3012, 3018, 3024, 3030, 3036, 3042,
		3050, 3053, 3061, 3066, 3071, 3078, 3085, 3088, 3095, 3100, 3103, 3105,
		3109, 3122, 3129, 3136, 3142, 3146, 3150, 3153, 3160, 3163, 3168, 3175,
		3182, 3186, 3191, 3198, 3211, 3214, 3219, 3224, 3228, 3234, 3238, 3242,
		3245, 3252, 3262, 3267, 3274, 3278, 3285, 3288, 3292, 3301, 3305, 3308,
		3311, 3317, 3320, 3326, 3335, 3338, 3349, 3352, 3357, 3360, 3365, 3375,
		3380, 3386, 3388, 3394, 3396, 3402, 3410, 3415, 3423, 3426, 3431, 3434,
		3439, 3447, 3455, 3461, 3469, 3474, 3482, 3485, 3489, 3492, 3500, 3506,
		3515, 3518, 3522, 3526, 3532, 3536, 3540, 3542, 3545, 3548, 3551, 3557,
		3561, 3564, 3567, 3570, 3573, 3580, 3582, 3586, 3591, 3597, 3602, 3609,
		3615, 3620, 3623, 3629, 3633, 3641, 3644, 3648, 3651, 3654, 3663, 3667,
		3670, 3674, 3678, 3681, 3684, 3689, 3695, 3699, 3709, 3715, 3719, 3725,
		3729, 3735, 3738, 3750, 3754, 3758, 3766, 3770, 3778, 3781, 3785, 3788,
		3796, 3801, 3804, 3807, 3811, 3814, 3823, 3828, 3837, 3842, 3849, 3856,
		3864, 3870, 3878, 3881, 3884, 3891, 3894, 3901, 3904, 3912, 3918, 3929,
		3932, 3936, 3946, 3952, 3956, 3960, 3970, 3975, 3977, 3981, 3991, 4001,
		4007, 4012, 4015, 4018, 4021, 4024, 4027, 4030, 4036, 4041, 4044, 4047,
		4050, 4053, 4056, 4059, 4061, 4067, 4072, 4075, 4078, 4081, 4084, 4087,
		4091, 4097, 4101, 4109, 4113, 4116, 4118, 4131, 4134, 4141, 4151, 4154,
		4159, 4161, 4165, 4173, 4179, 4188, 4201, 4205, 4211, 4220, 4223, 4227,
		4230, 4234, 4238, 4241, 4243, 4251, 4263, 4269, 4271, 4277, 4279, 4281,
		4287, 4295, 4303, 4307, 4311, 4320, 4325, 4345, 4350, 4356, 4363, 4368,
		4377, 4380, 4384, 4388, 4392, 4395, 4398, 4401, 4405, 4409, 4412, 4415,
		4418, 4425, 4429, 4444, 4448, 4460, 4468, 4478, 4482, 4485, 4491, 4494,
		4497, 4506, 4515, 4525, 4529, 4539, 4549, 4557, 4560, 4569, 4572, 4576,
		4581, 4585, 4594, 4597, 4628, 4631, 4634, 4690, 4695, 4723, 4737, 4744,
		4748, 4754, 4762, 4764, 4775, 4785, 4792, 4798, 4806, 4811, 4819, 4827,
		4835, 4843, 4849, 4852, 4856, 4861, 4866, 4872, 4874, 4885, 4890, 4897,
		4899, 4913, 4919, 4924, 4929, 4935, 4942, 4950, 4958, 4963, 4969, 4972,
		4980, 4987, 4996, 4999, 5016, 5024, 5032, 5036, 5043, 5049, 5057, 5066,
		5072, 5079, 5086, 5091, 5094, 5096, 5102, 5104, 5108, 5110, 5117, 5119,
		5128, 5134, 5141, 5148, 5153, 5156, 5158, 5164, 5166, 5170, 5172, 5179,
		5181, 5186, 5193, 5202, 5207, 5216, 5223, 5228, 5231, 5233, 5239, 5241,
		5244, 5252, 5257, 5262, 5266, 5272, 5277, 5281, 5287, 5289, 5300, 5303,
		5310, 5313, 5325, 5331, 5340, 5349, 5354, 5363, 5369, 5380, 5389, 5395,
		5400, 5404, 5407, 5419, 5426, 5431, 5449, 5459, 5463, 5468, 5474, 5484,
		5494, 5504, 5510, 5519, 5525, 5532, 5534, 5544, 5548, 5552, 5562, 5567,
		5585, 5641, 5666, 5684, 5692, 5704, 5711, 5713, 5723, 5726, 5734, 5741,
		5745, 5750, 5754, 5759, 5762, 5765, 5774, 5778, 5781, 5785, 5808, 5815,
		5819, 5826, 5833, 5836, 5852, 5855, 5865, 5869, 5872, 5877, 5882, 5886,
		5889, 5894, 5899, 5903, 5910, 5913, 5919, 5930, 5950, 5962, 5965, 5975,
		5983, 5987, 5994, 5997, 6006, 6009, 6014, 6017, 6022, 6028, 6035, 6042,
		6046, 6048, 6052, 6062, 6065, 6068, 6080, 6083, 6089, 6092, 6101, 6103,
		6107, 6124, 6130, 6134, 6148, 6160, 6167, 6170, 6177, 6184, 6189, 6193,
		6206, 6217, 6223, 6228, 6241, 6243, 6248, 6252, 6255, 6257, 6264, 6271,
		6274, 6277, 6283, 6287, 6293, 6299, 6316, 6321, 6329, 6332, 6337, 6342,
		6350, 6353, 6361, 6365, 6378, 6384, 6396, 6399, 6408, 6413, 6419, 6425,
		6430, 6432, 6437, 6439, 6443, 6449, 6452, 6455, 6464, 6472, 6476, 6498,
		6505, 6507, 6514, 6516, 6520, 6525, 6536, 6541, 6547, 6550, 6554, 6559,
		6562, 6566, 6570, 6572, 6577, 6582, 6595, 6598, 6602, 6605, 6608, 6613,
		6618, 6623, 6626, 6631, 6634, 6640, 6643, 6647, 6652, 6657, 6662, 6667,
		6670, 6675, 6680, 6685, 6691, 6696, 6701, 6706, 6709, 6714, 6718, 6722,
		6730, 6737, 6741, 6746, 6751, 6755, 6757, 6760, 6776, 6785, 6793, 6802,
		6812, 6820, 6828, 6836, 6844, 6856, 6863, 6882, 6887, 6890, 6895, 6898,
		6902, 6917, 6922, 6930, 6937, 6942, 6947, 6980, 6984, 6992, 6996, 7005,
		7013, 7018, 7026, 7031, 7036, 7038, 7047, 7052, 7060, 7065, 7073, 7081,
		7084, 7094, 7112, 7115, 7118, 7122, 7135, 7143, 7147, 7152, 7157, 7163,
		7168, 7172, 7177, 7182, 7187, 7197, 7200, 7204, 7208, 7215, 7219, 7248,
		7253, 7257, 7260, 7263, 7266, 7269, 7280, 7294, 7303, 7329, 7340, 7347,
		7351, 7358, 7366, 7371, 7379, 7385, 7395, 7408, 7414, 7420, 7436, 7442,
		7451, 7453, 7472, 7484, 7501, 7518, 7520, 7539, 7548, 7557, 7566,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MariaDBParserInit initializes any static state used to implement MariaDBParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMariaDBParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MariaDBParserInit() {
	staticData := &MariaDBParserParserStaticData
	staticData.once.Do(mariadbparserParserInit)
}

// NewMariaDBParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMariaDBParser(input antlr.TokenStream) *MariaDBParser {
	MariaDBParserInit()
	this := new(MariaDBParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MariaDBParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MariaDBParser.g4"

	return this
}

// MariaDBParser tokens.
const (
	MariaDBParserEOF                               = antlr.TokenEOF
	MariaDBParserSPACE                             = 1
	MariaDBParserSPEC_MYSQL_COMMENT                = 2
	MariaDBParserCOMMENT_INPUT                     = 3
	MariaDBParserLINE_COMMENT                      = 4
	MariaDBParserADD                               = 5
	MariaDBParserALL                               = 6
	MariaDBParserALTER                             = 7
	MariaDBParserALWAYS                            = 8
	MariaDBParserANALYZE                           = 9
	MariaDBParserAND                               = 10
	MariaDBParserARRAY                             = 11
	MariaDBParserAS                                = 12
	MariaDBParserASC                               = 13
	MariaDBParserATTRIBUTE                         = 14
	MariaDBParserBEFORE                            = 15
	MariaDBParserBETWEEN                           = 16
	MariaDBParserBODY                              = 17
	MariaDBParserBOTH                              = 18
	MariaDBParserBUCKETS                           = 19
	MariaDBParserBY                                = 20
	MariaDBParserCALL                              = 21
	MariaDBParserCASCADE                           = 22
	MariaDBParserCASE                              = 23
	MariaDBParserCAST                              = 24
	MariaDBParserCHANGE                            = 25
	MariaDBParserCHARACTER                         = 26
	MariaDBParserCHECK                             = 27
	MariaDBParserCOLLATE                           = 28
	MariaDBParserCOLUMN                            = 29
	MariaDBParserCONDITION                         = 30
	MariaDBParserCONSTRAINT                        = 31
	MariaDBParserCONTINUE                          = 32
	MariaDBParserCONVERT                           = 33
	MariaDBParserCREATE                            = 34
	MariaDBParserCROSS                             = 35
	MariaDBParserCURRENT                           = 36
	MariaDBParserCURRENT_ROLE                      = 37
	MariaDBParserCURRENT_USER                      = 38
	MariaDBParserCURSOR                            = 39
	MariaDBParserDATABASE                          = 40
	MariaDBParserDATABASES                         = 41
	MariaDBParserDECLARE                           = 42
	MariaDBParserDEFAULT                           = 43
	MariaDBParserDELAYED                           = 44
	MariaDBParserDELETE                            = 45
	MariaDBParserDESC                              = 46
	MariaDBParserDESCRIBE                          = 47
	MariaDBParserDETERMINISTIC                     = 48
	MariaDBParserDIAGNOSTICS                       = 49
	MariaDBParserDISTINCT                          = 50
	MariaDBParserDISTINCTROW                       = 51
	MariaDBParserDROP                              = 52
	MariaDBParserEACH                              = 53
	MariaDBParserELSE                              = 54
	MariaDBParserELSEIF                            = 55
	MariaDBParserEMPTY                             = 56
	MariaDBParserENCLOSED                          = 57
	MariaDBParserESCAPED                           = 58
	MariaDBParserEXCEPT                            = 59
	MariaDBParserEXISTS                            = 60
	MariaDBParserEXIT                              = 61
	MariaDBParserEXPLAIN                           = 62
	MariaDBParserFALSE                             = 63
	MariaDBParserFETCH                             = 64
	MariaDBParserFOR                               = 65
	MariaDBParserFORCE                             = 66
	MariaDBParserFOREIGN                           = 67
	MariaDBParserFROM                              = 68
	MariaDBParserFULLTEXT                          = 69
	MariaDBParserGENERATED                         = 70
	MariaDBParserGET                               = 71
	MariaDBParserGRANT                             = 72
	MariaDBParserGROUP                             = 73
	MariaDBParserHAVING                            = 74
	MariaDBParserHIGH_PRIORITY                     = 75
	MariaDBParserHISTOGRAM                         = 76
	MariaDBParserIF                                = 77
	MariaDBParserIGNORE                            = 78
	MariaDBParserIGNORED                           = 79
	MariaDBParserIN                                = 80
	MariaDBParserINDEX                             = 81
	MariaDBParserINFILE                            = 82
	MariaDBParserINNER                             = 83
	MariaDBParserINOUT                             = 84
	MariaDBParserINSERT                            = 85
	MariaDBParserINTERVAL                          = 86
	MariaDBParserINTO                              = 87
	MariaDBParserIS                                = 88
	MariaDBParserITERATE                           = 89
	MariaDBParserJOIN                              = 90
	MariaDBParserKEY                               = 91
	MariaDBParserKEYS                              = 92
	MariaDBParserKILL                              = 93
	MariaDBParserLATERAL                           = 94
	MariaDBParserLEADING                           = 95
	MariaDBParserLEAVE                             = 96
	MariaDBParserLEFT                              = 97
	MariaDBParserLIKE                              = 98
	MariaDBParserLIMIT                             = 99
	MariaDBParserLINEAR                            = 100
	MariaDBParserLINES                             = 101
	MariaDBParserLOAD                              = 102
	MariaDBParserLOCK                              = 103
	MariaDBParserLOCKED                            = 104
	MariaDBParserLOOP                              = 105
	MariaDBParserLOW_PRIORITY                      = 106
	MariaDBParserMASTER_BIND                       = 107
	MariaDBParserMASTER_SSL_VERIFY_SERVER_CERT     = 108
	MariaDBParserMATCH                             = 109
	MariaDBParserMAXVALUE                          = 110
	MariaDBParserMINVALUE                          = 111
	MariaDBParserMODIFIES                          = 112
	MariaDBParserNATURAL                           = 113
	MariaDBParserNOT                               = 114
	MariaDBParserNO_WRITE_TO_BINLOG                = 115
	MariaDBParserNULL_LITERAL                      = 116
	MariaDBParserNUMBER                            = 117
	MariaDBParserON                                = 118
	MariaDBParserOPTIMIZE                          = 119
	MariaDBParserOPTION                            = 120
	MariaDBParserOPTIONAL                          = 121
	MariaDBParserOPTIONALLY                        = 122
	MariaDBParserOR                                = 123
	MariaDBParserORDER                             = 124
	MariaDBParserOUT                               = 125
	MariaDBParserOUTER                             = 126
	MariaDBParserOUTFILE                           = 127
	MariaDBParserOVER                              = 128
	MariaDBParserPARTITION                         = 129
	MariaDBParserPRIMARY                           = 130
	MariaDBParserPACKAGE                           = 131
	MariaDBParserPROCEDURE                         = 132
	MariaDBParserPURGE                             = 133
	MariaDBParserRANGE                             = 134
	MariaDBParserREAD                              = 135
	MariaDBParserREADS                             = 136
	MariaDBParserREFERENCES                        = 137
	MariaDBParserREGEXP                            = 138
	MariaDBParserRELEASE                           = 139
	MariaDBParserRENAME                            = 140
	MariaDBParserREPEAT                            = 141
	MariaDBParserREPLACE                           = 142
	MariaDBParserREQUIRE                           = 143
	MariaDBParserRESIGNAL                          = 144
	MariaDBParserRESTRICT                          = 145
	MariaDBParserRETAIN                            = 146
	MariaDBParserRETURN                            = 147
	MariaDBParserREVOKE                            = 148
	MariaDBParserRIGHT                             = 149
	MariaDBParserRLIKE                             = 150
	MariaDBParserSCHEMA                            = 151
	MariaDBParserSCHEMAS                           = 152
	MariaDBParserSELECT                            = 153
	MariaDBParserSET                               = 154
	MariaDBParserSEPARATOR                         = 155
	MariaDBParserSHOW                              = 156
	MariaDBParserSIGNAL                            = 157
	MariaDBParserSKIP_                             = 158
	MariaDBParserSPATIAL                           = 159
	MariaDBParserSQL                               = 160
	MariaDBParserSQLEXCEPTION                      = 161
	MariaDBParserSQLSTATE                          = 162
	MariaDBParserSQLWARNING                        = 163
	MariaDBParserSQL_BIG_RESULT                    = 164
	MariaDBParserSQL_CALC_FOUND_ROWS               = 165
	MariaDBParserSQL_SMALL_RESULT                  = 166
	MariaDBParserSSL                               = 167
	MariaDBParserSTACKED                           = 168
	MariaDBParserSTARTING                          = 169
	MariaDBParserSTATEMENT                         = 170
	MariaDBParserSTRAIGHT_JOIN                     = 171
	MariaDBParserTABLE                             = 172
	MariaDBParserTERMINATED                        = 173
	MariaDBParserTHEN                              = 174
	MariaDBParserTO                                = 175
	MariaDBParserTRAILING                          = 176
	MariaDBParserTRIGGER                           = 177
	MariaDBParserTRUE                              = 178
	MariaDBParserUNDO                              = 179
	MariaDBParserUNION                             = 180
	MariaDBParserUNIQUE                            = 181
	MariaDBParserUNLOCK                            = 182
	MariaDBParserUNSIGNED                          = 183
	MariaDBParserUPDATE                            = 184
	MariaDBParserUSAGE                             = 185
	MariaDBParserUSE                               = 186
	MariaDBParserUSING                             = 187
	MariaDBParserVALUES                            = 188
	MariaDBParserWHEN                              = 189
	MariaDBParserWHERE                             = 190
	MariaDBParserWHILE                             = 191
	MariaDBParserWITH                              = 192
	MariaDBParserWRITE                             = 193
	MariaDBParserXOR                               = 194
	MariaDBParserZEROFILL                          = 195
	MariaDBParserTINYINT                           = 196
	MariaDBParserSMALLINT                          = 197
	MariaDBParserMEDIUMINT                         = 198
	MariaDBParserMIDDLEINT                         = 199
	MariaDBParserINT                               = 200
	MariaDBParserINT1                              = 201
	MariaDBParserINT2                              = 202
	MariaDBParserINT3                              = 203
	MariaDBParserINT4                              = 204
	MariaDBParserINT8                              = 205
	MariaDBParserINTEGER                           = 206
	MariaDBParserBIGINT                            = 207
	MariaDBParserREAL                              = 208
	MariaDBParserDOUBLE                            = 209
	MariaDBParserPRECISION                         = 210
	MariaDBParserFLOAT                             = 211
	MariaDBParserFLOAT4                            = 212
	MariaDBParserFLOAT8                            = 213
	MariaDBParserDECIMAL                           = 214
	MariaDBParserDEC                               = 215
	MariaDBParserNUMERIC                           = 216
	MariaDBParserDATE                              = 217
	MariaDBParserTIME                              = 218
	MariaDBParserTIMESTAMP                         = 219
	MariaDBParserDATETIME                          = 220
	MariaDBParserYEAR                              = 221
	MariaDBParserCHAR                              = 222
	MariaDBParserVARCHAR                           = 223
	MariaDBParserNVARCHAR                          = 224
	MariaDBParserNATIONAL                          = 225
	MariaDBParserBINARY                            = 226
	MariaDBParserVARBINARY                         = 227
	MariaDBParserTINYBLOB                          = 228
	MariaDBParserBLOB                              = 229
	MariaDBParserMEDIUMBLOB                        = 230
	MariaDBParserLONG                              = 231
	MariaDBParserLONGBLOB                          = 232
	MariaDBParserTINYTEXT                          = 233
	MariaDBParserTEXT                              = 234
	MariaDBParserMEDIUMTEXT                        = 235
	MariaDBParserLONGTEXT                          = 236
	MariaDBParserENUM                              = 237
	MariaDBParserVARYING                           = 238
	MariaDBParserSERIAL                            = 239
	MariaDBParserYEAR_MONTH                        = 240
	MariaDBParserDAY_HOUR                          = 241
	MariaDBParserDAY_MINUTE                        = 242
	MariaDBParserDAY_SECOND                        = 243
	MariaDBParserHOUR_MINUTE                       = 244
	MariaDBParserHOUR_SECOND                       = 245
	MariaDBParserMINUTE_SECOND                     = 246
	MariaDBParserSECOND_MICROSECOND                = 247
	MariaDBParserMINUTE_MICROSECOND                = 248
	MariaDBParserHOUR_MICROSECOND                  = 249
	MariaDBParserDAY_MICROSECOND                   = 250
	MariaDBParserJSON_ARRAY                        = 251
	MariaDBParserJSON_ARRAYAGG                     = 252
	MariaDBParserJSON_ARRAY_APPEND                 = 253
	MariaDBParserJSON_ARRAY_INSERT                 = 254
	MariaDBParserJSON_CONTAINS                     = 255
	MariaDBParserJSON_CONTAINS_PATH                = 256
	MariaDBParserJSON_DEPTH                        = 257
	MariaDBParserJSON_EXTRACT                      = 258
	MariaDBParserJSON_INSERT                       = 259
	MariaDBParserJSON_KEYS                         = 260
	MariaDBParserJSON_LENGTH                       = 261
	MariaDBParserJSON_MERGE                        = 262
	MariaDBParserJSON_MERGE_PATCH                  = 263
	MariaDBParserJSON_MERGE_PRESERVE               = 264
	MariaDBParserJSON_OBJECT                       = 265
	MariaDBParserJSON_OBJECTAGG                    = 266
	MariaDBParserJSON_OVERLAPS                     = 267
	MariaDBParserJSON_PRETTY                       = 268
	MariaDBParserJSON_QUOTE                        = 269
	MariaDBParserJSON_REMOVE                       = 270
	MariaDBParserJSON_REPLACE                      = 271
	MariaDBParserJSON_SCHEMA_VALID                 = 272
	MariaDBParserJSON_SCHEMA_VALIDATION_REPORT     = 273
	MariaDBParserJSON_SEARCH                       = 274
	MariaDBParserJSON_SET                          = 275
	MariaDBParserJSON_STORAGE_FREE                 = 276
	MariaDBParserJSON_STORAGE_SIZE                 = 277
	MariaDBParserJSON_TABLE                        = 278
	MariaDBParserJSON_TYPE                         = 279
	MariaDBParserJSON_UNQUOTE                      = 280
	MariaDBParserJSON_VALID                        = 281
	MariaDBParserJSON_VALUE                        = 282
	MariaDBParserNESTED                            = 283
	MariaDBParserORDINALITY                        = 284
	MariaDBParserPATH                              = 285
	MariaDBParserAVG                               = 286
	MariaDBParserBIT_AND                           = 287
	MariaDBParserBIT_OR                            = 288
	MariaDBParserBIT_XOR                           = 289
	MariaDBParserCOUNT                             = 290
	MariaDBParserCUME_DIST                         = 291
	MariaDBParserDENSE_RANK                        = 292
	MariaDBParserFIRST_VALUE                       = 293
	MariaDBParserGROUP_CONCAT                      = 294
	MariaDBParserLAG                               = 295
	MariaDBParserLAST_VALUE                        = 296
	MariaDBParserLEAD                              = 297
	MariaDBParserMAX                               = 298
	MariaDBParserMIN                               = 299
	MariaDBParserNTILE                             = 300
	MariaDBParserNTH_VALUE                         = 301
	MariaDBParserPERCENT_RANK                      = 302
	MariaDBParserRANK                              = 303
	MariaDBParserROW_NUMBER                        = 304
	MariaDBParserSTD                               = 305
	MariaDBParserSTDDEV                            = 306
	MariaDBParserSTDDEV_POP                        = 307
	MariaDBParserSTDDEV_SAMP                       = 308
	MariaDBParserSUM                               = 309
	MariaDBParserVAR_POP                           = 310
	MariaDBParserVAR_SAMP                          = 311
	MariaDBParserVARIANCE                          = 312
	MariaDBParserCURRENT_DATE                      = 313
	MariaDBParserCURRENT_TIME                      = 314
	MariaDBParserCURRENT_TIMESTAMP                 = 315
	MariaDBParserLOCALTIME                         = 316
	MariaDBParserCURDATE                           = 317
	MariaDBParserCURTIME                           = 318
	MariaDBParserDATE_ADD                          = 319
	MariaDBParserDATE_SUB                          = 320
	MariaDBParserEXTRACT                           = 321
	MariaDBParserLOCALTIMESTAMP                    = 322
	MariaDBParserNOW                               = 323
	MariaDBParserPOSITION                          = 324
	MariaDBParserSUBSTR                            = 325
	MariaDBParserSUBSTRING                         = 326
	MariaDBParserSYSDATE                           = 327
	MariaDBParserTRIM                              = 328
	MariaDBParserUTC_DATE                          = 329
	MariaDBParserUTC_TIME                          = 330
	MariaDBParserUTC_TIMESTAMP                     = 331
	MariaDBParserACCOUNT                           = 332
	MariaDBParserACTION                            = 333
	MariaDBParserAFTER                             = 334
	MariaDBParserAGGREGATE                         = 335
	MariaDBParserALGORITHM                         = 336
	MariaDBParserANY                               = 337
	MariaDBParserAT                                = 338
	MariaDBParserAUTHORS                           = 339
	MariaDBParserAUTOCOMMIT                        = 340
	MariaDBParserAUTOEXTEND_SIZE                   = 341
	MariaDBParserAUTO_INCREMENT                    = 342
	MariaDBParserAVG_ROW_LENGTH                    = 343
	MariaDBParserBEGIN                             = 344
	MariaDBParserBINLOG                            = 345
	MariaDBParserBIT                               = 346
	MariaDBParserBLOCK                             = 347
	MariaDBParserBOOL                              = 348
	MariaDBParserBOOLEAN                           = 349
	MariaDBParserBTREE                             = 350
	MariaDBParserCACHE                             = 351
	MariaDBParserCASCADED                          = 352
	MariaDBParserCHAIN                             = 353
	MariaDBParserCHANGED                           = 354
	MariaDBParserCHANNEL                           = 355
	MariaDBParserCHECKSUM                          = 356
	MariaDBParserPAGE_CHECKSUM                     = 357
	MariaDBParserCIPHER                            = 358
	MariaDBParserCLASS_ORIGIN                      = 359
	MariaDBParserCLIENT                            = 360
	MariaDBParserCLOSE                             = 361
	MariaDBParserCLUSTERING                        = 362
	MariaDBParserCOALESCE                          = 363
	MariaDBParserCODE                              = 364
	MariaDBParserCOLUMNS                           = 365
	MariaDBParserCOLUMN_FORMAT                     = 366
	MariaDBParserCOLUMN_NAME                       = 367
	MariaDBParserCOMMENT                           = 368
	MariaDBParserCOMMIT                            = 369
	MariaDBParserCOMPACT                           = 370
	MariaDBParserCOMPLETION                        = 371
	MariaDBParserCOMPRESSED                        = 372
	MariaDBParserCOMPRESSION                       = 373
	MariaDBParserCONCURRENT                        = 374
	MariaDBParserCONNECT                           = 375
	MariaDBParserCONNECTION                        = 376
	MariaDBParserCONSISTENT                        = 377
	MariaDBParserCONSTRAINT_CATALOG                = 378
	MariaDBParserCONSTRAINT_SCHEMA                 = 379
	MariaDBParserCONSTRAINT_NAME                   = 380
	MariaDBParserCONTAINS                          = 381
	MariaDBParserCONTEXT                           = 382
	MariaDBParserCONTRIBUTORS                      = 383
	MariaDBParserCOPY                              = 384
	MariaDBParserCPU                               = 385
	MariaDBParserCYCLE                             = 386
	MariaDBParserCURSOR_NAME                       = 387
	MariaDBParserDATA                              = 388
	MariaDBParserDATAFILE                          = 389
	MariaDBParserDEALLOCATE                        = 390
	MariaDBParserDEFAULT_AUTH                      = 391
	MariaDBParserDEFINER                           = 392
	MariaDBParserDELAY_KEY_WRITE                   = 393
	MariaDBParserDES_KEY_FILE                      = 394
	MariaDBParserDIRECTORY                         = 395
	MariaDBParserDISABLE                           = 396
	MariaDBParserDISCARD                           = 397
	MariaDBParserDISK                              = 398
	MariaDBParserDO                                = 399
	MariaDBParserDUMPFILE                          = 400
	MariaDBParserDUPLICATE                         = 401
	MariaDBParserDYNAMIC                           = 402
	MariaDBParserENABLE                            = 403
	MariaDBParserENCRYPTED                         = 404
	MariaDBParserENCRYPTION                        = 405
	MariaDBParserENCRYPTION_KEY_ID                 = 406
	MariaDBParserEND                               = 407
	MariaDBParserENDS                              = 408
	MariaDBParserENGINE                            = 409
	MariaDBParserENGINES                           = 410
	MariaDBParserERROR                             = 411
	MariaDBParserERRORS                            = 412
	MariaDBParserESCAPE                            = 413
	MariaDBParserEVEN                              = 414
	MariaDBParserEVENT                             = 415
	MariaDBParserEVENTS                            = 416
	MariaDBParserEVERY                             = 417
	MariaDBParserEXCHANGE                          = 418
	MariaDBParserEXCLUSIVE                         = 419
	MariaDBParserEXPIRE                            = 420
	MariaDBParserEXPORT                            = 421
	MariaDBParserEXTENDED                          = 422
	MariaDBParserEXTENT_SIZE                       = 423
	MariaDBParserFAILED_LOGIN_ATTEMPTS             = 424
	MariaDBParserFAST                              = 425
	MariaDBParserFAULTS                            = 426
	MariaDBParserFIELDS                            = 427
	MariaDBParserFILE_BLOCK_SIZE                   = 428
	MariaDBParserFILTER                            = 429
	MariaDBParserFIRST                             = 430
	MariaDBParserFIXED                             = 431
	MariaDBParserFLUSH                             = 432
	MariaDBParserFOLLOWING                         = 433
	MariaDBParserFOLLOWS                           = 434
	MariaDBParserFOUND                             = 435
	MariaDBParserFULL                              = 436
	MariaDBParserFUNCTION                          = 437
	MariaDBParserGENERAL                           = 438
	MariaDBParserGLOBAL                            = 439
	MariaDBParserGRANTS                            = 440
	MariaDBParserGROUP_REPLICATION                 = 441
	MariaDBParserHANDLER                           = 442
	MariaDBParserHASH                              = 443
	MariaDBParserHELP                              = 444
	MariaDBParserHISTORY                           = 445
	MariaDBParserHOST                              = 446
	MariaDBParserHOSTS                             = 447
	MariaDBParserIDENTIFIED                        = 448
	MariaDBParserIGNORE_SERVER_IDS                 = 449
	MariaDBParserIMPORT                            = 450
	MariaDBParserINCREMENT                         = 451
	MariaDBParserINDEXES                           = 452
	MariaDBParserINITIAL_SIZE                      = 453
	MariaDBParserINPLACE                           = 454
	MariaDBParserINSERT_METHOD                     = 455
	MariaDBParserINSTALL                           = 456
	MariaDBParserINSTANCE                          = 457
	MariaDBParserINSTANT                           = 458
	MariaDBParserINVISIBLE                         = 459
	MariaDBParserINVOKER                           = 460
	MariaDBParserIO                                = 461
	MariaDBParserIO_THREAD                         = 462
	MariaDBParserIPC                               = 463
	MariaDBParserISOLATION                         = 464
	MariaDBParserISSUER                            = 465
	MariaDBParserJSON                              = 466
	MariaDBParserKEY_BLOCK_SIZE                    = 467
	MariaDBParserLANGUAGE                          = 468
	MariaDBParserLAST                              = 469
	MariaDBParserLEAVES                            = 470
	MariaDBParserLESS                              = 471
	MariaDBParserLEVEL                             = 472
	MariaDBParserLIST                              = 473
	MariaDBParserLOCAL                             = 474
	MariaDBParserLOCALES                           = 475
	MariaDBParserLOGFILE                           = 476
	MariaDBParserLOGS                              = 477
	MariaDBParserMASTER                            = 478
	MariaDBParserMASTER_AUTO_POSITION              = 479
	MariaDBParserMASTER_CONNECT_RETRY              = 480
	MariaDBParserMASTER_DELAY                      = 481
	MariaDBParserMASTER_HEARTBEAT_PERIOD           = 482
	MariaDBParserMASTER_HOST                       = 483
	MariaDBParserMASTER_LOG_FILE                   = 484
	MariaDBParserMASTER_LOG_POS                    = 485
	MariaDBParserMASTER_PASSWORD                   = 486
	MariaDBParserMASTER_PORT                       = 487
	MariaDBParserMASTER_RETRY_COUNT                = 488
	MariaDBParserMASTER_SSL                        = 489
	MariaDBParserMASTER_SSL_CA                     = 490
	MariaDBParserMASTER_SSL_CAPATH                 = 491
	MariaDBParserMASTER_SSL_CERT                   = 492
	MariaDBParserMASTER_SSL_CIPHER                 = 493
	MariaDBParserMASTER_SSL_CRL                    = 494
	MariaDBParserMASTER_SSL_CRLPATH                = 495
	MariaDBParserMASTER_SSL_KEY                    = 496
	MariaDBParserMASTER_TLS_VERSION                = 497
	MariaDBParserMASTER_USER                       = 498
	MariaDBParserMAX_CONNECTIONS_PER_HOUR          = 499
	MariaDBParserMAX_QUERIES_PER_HOUR              = 500
	MariaDBParserMAX_ROWS                          = 501
	MariaDBParserMAX_SIZE                          = 502
	MariaDBParserMAX_UPDATES_PER_HOUR              = 503
	MariaDBParserMAX_USER_CONNECTIONS              = 504
	MariaDBParserMEDIUM                            = 505
	MariaDBParserMEMBER                            = 506
	MariaDBParserMERGE                             = 507
	MariaDBParserMESSAGE_TEXT                      = 508
	MariaDBParserMID                               = 509
	MariaDBParserMIGRATE                           = 510
	MariaDBParserMIN_ROWS                          = 511
	MariaDBParserMODE                              = 512
	MariaDBParserMODIFY                            = 513
	MariaDBParserMUTEX                             = 514
	MariaDBParserMYSQL                             = 515
	MariaDBParserMYSQL_ERRNO                       = 516
	MariaDBParserNAME                              = 517
	MariaDBParserNAMES                             = 518
	MariaDBParserNCHAR                             = 519
	MariaDBParserNEVER                             = 520
	MariaDBParserNEXT                              = 521
	MariaDBParserNO                                = 522
	MariaDBParserNOCACHE                           = 523
	MariaDBParserNOCOPY                            = 524
	MariaDBParserNOCYCLE                           = 525
	MariaDBParserNOMAXVALUE                        = 526
	MariaDBParserNOMINVALUE                        = 527
	MariaDBParserNOWAIT                            = 528
	MariaDBParserNODEGROUP                         = 529
	MariaDBParserNONE                              = 530
	MariaDBParserODBC                              = 531
	MariaDBParserOFFLINE                           = 532
	MariaDBParserOFFSET                            = 533
	MariaDBParserOF                                = 534
	MariaDBParserOJ                                = 535
	MariaDBParserOLD_PASSWORD                      = 536
	MariaDBParserONE                               = 537
	MariaDBParserONLINE                            = 538
	MariaDBParserONLY                              = 539
	MariaDBParserOPEN                              = 540
	MariaDBParserOPTIMIZER_COSTS                   = 541
	MariaDBParserOPTIONS                           = 542
	MariaDBParserOWNER                             = 543
	MariaDBParserPACK_KEYS                         = 544
	MariaDBParserPAGE                              = 545
	MariaDBParserPAGE_COMPRESSED                   = 546
	MariaDBParserPAGE_COMPRESSION_LEVEL            = 547
	MariaDBParserPARSER                            = 548
	MariaDBParserPARTIAL                           = 549
	MariaDBParserPARTITIONING                      = 550
	MariaDBParserPARTITIONS                        = 551
	MariaDBParserPASSWORD                          = 552
	MariaDBParserPASSWORD_LOCK_TIME                = 553
	MariaDBParserPHASE                             = 554
	MariaDBParserPLUGIN                            = 555
	MariaDBParserPLUGIN_DIR                        = 556
	MariaDBParserPLUGINS                           = 557
	MariaDBParserPORT                              = 558
	MariaDBParserPRECEDES                          = 559
	MariaDBParserPRECEDING                         = 560
	MariaDBParserPREPARE                           = 561
	MariaDBParserPRESERVE                          = 562
	MariaDBParserPREV                              = 563
	MariaDBParserPROCESSLIST                       = 564
	MariaDBParserPROFILE                           = 565
	MariaDBParserPROFILES                          = 566
	MariaDBParserPROXY                             = 567
	MariaDBParserQUERY                             = 568
	MariaDBParserQUERY_RESPONSE_TIME               = 569
	MariaDBParserQUICK                             = 570
	MariaDBParserREBUILD                           = 571
	MariaDBParserRECOVER                           = 572
	MariaDBParserRECURSIVE                         = 573
	MariaDBParserREDO_BUFFER_SIZE                  = 574
	MariaDBParserREDUNDANT                         = 575
	MariaDBParserRELAY                             = 576
	MariaDBParserRELAY_LOG_FILE                    = 577
	MariaDBParserRELAY_LOG_POS                     = 578
	MariaDBParserRELAYLOG                          = 579
	MariaDBParserREMOVE                            = 580
	MariaDBParserREORGANIZE                        = 581
	MariaDBParserREPAIR                            = 582
	MariaDBParserREPLICATE_DO_DB                   = 583
	MariaDBParserREPLICATE_DO_TABLE                = 584
	MariaDBParserREPLICATE_IGNORE_DB               = 585
	MariaDBParserREPLICATE_IGNORE_TABLE            = 586
	MariaDBParserREPLICATE_REWRITE_DB              = 587
	MariaDBParserREPLICATE_WILD_DO_TABLE           = 588
	MariaDBParserREPLICATE_WILD_IGNORE_TABLE       = 589
	MariaDBParserREPLICATION                       = 590
	MariaDBParserRESET                             = 591
	MariaDBParserRESTART                           = 592
	MariaDBParserRESUME                            = 593
	MariaDBParserRETURNED_SQLSTATE                 = 594
	MariaDBParserRETURNING                         = 595
	MariaDBParserRETURNS                           = 596
	MariaDBParserREUSE                             = 597
	MariaDBParserROLE                              = 598
	MariaDBParserROLLBACK                          = 599
	MariaDBParserROLLUP                            = 600
	MariaDBParserROTATE                            = 601
	MariaDBParserROW                               = 602
	MariaDBParserROWS                              = 603
	MariaDBParserROW_FORMAT                        = 604
	MariaDBParserRTREE                             = 605
	MariaDBParserSAVEPOINT                         = 606
	MariaDBParserSCHEDULE                          = 607
	MariaDBParserSECURITY                          = 608
	MariaDBParserSEQUENCE                          = 609
	MariaDBParserSERVER                            = 610
	MariaDBParserSESSION                           = 611
	MariaDBParserSHARE                             = 612
	MariaDBParserSHARED                            = 613
	MariaDBParserSIGNED                            = 614
	MariaDBParserSIMPLE                            = 615
	MariaDBParserSLAVE                             = 616
	MariaDBParserSLAVES                            = 617
	MariaDBParserSLOW                              = 618
	MariaDBParserSNAPSHOT                          = 619
	MariaDBParserSOCKET                            = 620
	MariaDBParserSOME                              = 621
	MariaDBParserSONAME                            = 622
	MariaDBParserSOUNDS                            = 623
	MariaDBParserSOURCE                            = 624
	MariaDBParserSQL_AFTER_GTIDS                   = 625
	MariaDBParserSQL_AFTER_MTS_GAPS                = 626
	MariaDBParserSQL_BEFORE_GTIDS                  = 627
	MariaDBParserSQL_BUFFER_RESULT                 = 628
	MariaDBParserSQL_CACHE                         = 629
	MariaDBParserSQL_NO_CACHE                      = 630
	MariaDBParserSQL_THREAD                        = 631
	MariaDBParserSTART                             = 632
	MariaDBParserSTARTS                            = 633
	MariaDBParserSTATS_AUTO_RECALC                 = 634
	MariaDBParserSTATS_PERSISTENT                  = 635
	MariaDBParserSTATS_SAMPLE_PAGES                = 636
	MariaDBParserSTATUS                            = 637
	MariaDBParserSTOP                              = 638
	MariaDBParserSTORAGE                           = 639
	MariaDBParserSTORED                            = 640
	MariaDBParserSTRING                            = 641
	MariaDBParserSUBCLASS_ORIGIN                   = 642
	MariaDBParserSUBJECT                           = 643
	MariaDBParserSUBPARTITION                      = 644
	MariaDBParserSUBPARTITIONS                     = 645
	MariaDBParserSUSPEND                           = 646
	MariaDBParserSWAPS                             = 647
	MariaDBParserSWITCHES                          = 648
	MariaDBParserTABLE_NAME                        = 649
	MariaDBParserTABLESPACE                        = 650
	MariaDBParserTABLE_TYPE                        = 651
	MariaDBParserTEMPORARY                         = 652
	MariaDBParserTEMPTABLE                         = 653
	MariaDBParserTHAN                              = 654
	MariaDBParserTRADITIONAL                       = 655
	MariaDBParserTRANSACTION                       = 656
	MariaDBParserTRANSACTIONAL                     = 657
	MariaDBParserTRIGGERS                          = 658
	MariaDBParserTRUNCATE                          = 659
	MariaDBParserTYPES                             = 660
	MariaDBParserUNBOUNDED                         = 661
	MariaDBParserUNDEFINED                         = 662
	MariaDBParserUNDOFILE                          = 663
	MariaDBParserUNDO_BUFFER_SIZE                  = 664
	MariaDBParserUNINSTALL                         = 665
	MariaDBParserUNKNOWN                           = 666
	MariaDBParserUNTIL                             = 667
	MariaDBParserUPGRADE                           = 668
	MariaDBParserUSER                              = 669
	MariaDBParserUSE_FRM                           = 670
	MariaDBParserUSER_RESOURCES                    = 671
	MariaDBParserVALIDATION                        = 672
	MariaDBParserVALUE                             = 673
	MariaDBParserVARIABLES                         = 674
	MariaDBParserVIEW                              = 675
	MariaDBParserVIRTUAL                           = 676
	MariaDBParserVISIBLE                           = 677
	MariaDBParserWAIT                              = 678
	MariaDBParserWARNINGS                          = 679
	MariaDBParserWINDOW                            = 680
	MariaDBParserWITHOUT                           = 681
	MariaDBParserWORK                              = 682
	MariaDBParserWRAPPER                           = 683
	MariaDBParserWSREP_MEMBERSHIP                  = 684
	MariaDBParserWSREP_STATUS                      = 685
	MariaDBParserX509                              = 686
	MariaDBParserXA                                = 687
	MariaDBParserXML                               = 688
	MariaDBParserYES                               = 689
	MariaDBParserEUR                               = 690
	MariaDBParserUSA                               = 691
	MariaDBParserJIS                               = 692
	MariaDBParserISO                               = 693
	MariaDBParserINTERNAL                          = 694
	MariaDBParserQUARTER                           = 695
	MariaDBParserMONTH                             = 696
	MariaDBParserDAY                               = 697
	MariaDBParserHOUR                              = 698
	MariaDBParserMINUTE                            = 699
	MariaDBParserWEEK                              = 700
	MariaDBParserSECOND                            = 701
	MariaDBParserMICROSECOND                       = 702
	MariaDBParserUSER_STATISTICS                   = 703
	MariaDBParserCLIENT_STATISTICS                 = 704
	MariaDBParserINDEX_STATISTICS                  = 705
	MariaDBParserTABLE_STATISTICS                  = 706
	MariaDBParserADMIN                             = 707
	MariaDBParserAPPLICATION_PASSWORD_ADMIN        = 708
	MariaDBParserAUDIT_ADMIN                       = 709
	MariaDBParserBACKUP_ADMIN                      = 710
	MariaDBParserBINLOG_ADMIN                      = 711
	MariaDBParserBINLOG_ENCRYPTION_ADMIN           = 712
	MariaDBParserCLONE_ADMIN                       = 713
	MariaDBParserCONNECTION_ADMIN                  = 714
	MariaDBParserENCRYPTION_KEY_ADMIN              = 715
	MariaDBParserEXECUTE                           = 716
	MariaDBParserFILE                              = 717
	MariaDBParserFIREWALL_ADMIN                    = 718
	MariaDBParserFIREWALL_USER                     = 719
	MariaDBParserFLUSH_OPTIMIZER_COSTS             = 720
	MariaDBParserFLUSH_STATUS                      = 721
	MariaDBParserFLUSH_TABLES                      = 722
	MariaDBParserFLUSH_USER_RESOURCES              = 723
	MariaDBParserGROUP_REPLICATION_ADMIN           = 724
	MariaDBParserINNODB_REDO_LOG_ARCHIVE           = 725
	MariaDBParserINNODB_REDO_LOG_ENABLE            = 726
	MariaDBParserINVOKE                            = 727
	MariaDBParserLAMBDA                            = 728
	MariaDBParserNDB_STORED_USER                   = 729
	MariaDBParserPASSWORDLESS_USER_ADMIN           = 730
	MariaDBParserPERSIST_RO_VARIABLES_ADMIN        = 731
	MariaDBParserPRIVILEGES                        = 732
	MariaDBParserPROCESS                           = 733
	MariaDBParserRELOAD                            = 734
	MariaDBParserREPLICATION_APPLIER               = 735
	MariaDBParserREPLICATION_SLAVE_ADMIN           = 736
	MariaDBParserRESOURCE_GROUP_ADMIN              = 737
	MariaDBParserRESOURCE_GROUP_USER               = 738
	MariaDBParserROLE_ADMIN                        = 739
	MariaDBParserROUTINE                           = 740
	MariaDBParserS3                                = 741
	MariaDBParserSERVICE_CONNECTION_ADMIN          = 742
	MariaDBParserSESSION_VARIABLES_ADMIN           = 743
	MariaDBParserSET_USER_ID                       = 744
	MariaDBParserSHOW_ROUTINE                      = 745
	MariaDBParserSHUTDOWN                          = 746
	MariaDBParserSUPER                             = 747
	MariaDBParserSYSTEM_VARIABLES_ADMIN            = 748
	MariaDBParserTABLES                            = 749
	MariaDBParserTABLE_ENCRYPTION_ADMIN            = 750
	MariaDBParserVERSION_TOKEN_ADMIN               = 751
	MariaDBParserXA_RECOVER_ADMIN                  = 752
	MariaDBParserARMSCII8                          = 753
	MariaDBParserASCII                             = 754
	MariaDBParserBIG5                              = 755
	MariaDBParserCP1250                            = 756
	MariaDBParserCP1251                            = 757
	MariaDBParserCP1256                            = 758
	MariaDBParserCP1257                            = 759
	MariaDBParserCP850                             = 760
	MariaDBParserCP852                             = 761
	MariaDBParserCP866                             = 762
	MariaDBParserCP932                             = 763
	MariaDBParserDEC8                              = 764
	MariaDBParserEUCJPMS                           = 765
	MariaDBParserEUCKR                             = 766
	MariaDBParserGB18030                           = 767
	MariaDBParserGB2312                            = 768
	MariaDBParserGBK                               = 769
	MariaDBParserGEOSTD8                           = 770
	MariaDBParserGREEK                             = 771
	MariaDBParserHEBREW                            = 772
	MariaDBParserHP8                               = 773
	MariaDBParserKEYBCS2                           = 774
	MariaDBParserKOI8R                             = 775
	MariaDBParserKOI8U                             = 776
	MariaDBParserLATIN1                            = 777
	MariaDBParserLATIN2                            = 778
	MariaDBParserLATIN5                            = 779
	MariaDBParserLATIN7                            = 780
	MariaDBParserMACCE                             = 781
	MariaDBParserMACROMAN                          = 782
	MariaDBParserSJIS                              = 783
	MariaDBParserSWE7                              = 784
	MariaDBParserTIS620                            = 785
	MariaDBParserUCS2                              = 786
	MariaDBParserUJIS                              = 787
	MariaDBParserUTF16                             = 788
	MariaDBParserUTF16LE                           = 789
	MariaDBParserUTF32                             = 790
	MariaDBParserUTF8                              = 791
	MariaDBParserUTF8MB3                           = 792
	MariaDBParserUTF8MB4                           = 793
	MariaDBParserARCHIVE                           = 794
	MariaDBParserBLACKHOLE                         = 795
	MariaDBParserCSV                               = 796
	MariaDBParserFEDERATED                         = 797
	MariaDBParserINNODB                            = 798
	MariaDBParserMEMORY                            = 799
	MariaDBParserMRG_MYISAM                        = 800
	MariaDBParserMYISAM                            = 801
	MariaDBParserNDB                               = 802
	MariaDBParserNDBCLUSTER                        = 803
	MariaDBParserPERFORMANCE_SCHEMA                = 804
	MariaDBParserTOKUDB                            = 805
	MariaDBParserREPEATABLE                        = 806
	MariaDBParserCOMMITTED                         = 807
	MariaDBParserUNCOMMITTED                       = 808
	MariaDBParserSERIALIZABLE                      = 809
	MariaDBParserGEOMETRYCOLLECTION                = 810
	MariaDBParserGEOMCOLLECTION                    = 811
	MariaDBParserGEOMETRY                          = 812
	MariaDBParserLINESTRING                        = 813
	MariaDBParserMULTILINESTRING                   = 814
	MariaDBParserMULTIPOINT                        = 815
	MariaDBParserMULTIPOLYGON                      = 816
	MariaDBParserPOINT                             = 817
	MariaDBParserPOLYGON                           = 818
	MariaDBParserABS                               = 819
	MariaDBParserACOS                              = 820
	MariaDBParserADDDATE                           = 821
	MariaDBParserADDTIME                           = 822
	MariaDBParserAES_DECRYPT                       = 823
	MariaDBParserAES_ENCRYPT                       = 824
	MariaDBParserAREA                              = 825
	MariaDBParserASBINARY                          = 826
	MariaDBParserASIN                              = 827
	MariaDBParserASTEXT                            = 828
	MariaDBParserASWKB                             = 829
	MariaDBParserASWKT                             = 830
	MariaDBParserASYMMETRIC_DECRYPT                = 831
	MariaDBParserASYMMETRIC_DERIVE                 = 832
	MariaDBParserASYMMETRIC_ENCRYPT                = 833
	MariaDBParserASYMMETRIC_SIGN                   = 834
	MariaDBParserASYMMETRIC_VERIFY                 = 835
	MariaDBParserATAN                              = 836
	MariaDBParserATAN2                             = 837
	MariaDBParserBENCHMARK                         = 838
	MariaDBParserBIN                               = 839
	MariaDBParserBIT_COUNT                         = 840
	MariaDBParserBIT_LENGTH                        = 841
	MariaDBParserBUFFER                            = 842
	MariaDBParserCATALOG_NAME                      = 843
	MariaDBParserCEIL                              = 844
	MariaDBParserCEILING                           = 845
	MariaDBParserCENTROID                          = 846
	MariaDBParserCHARACTER_LENGTH                  = 847
	MariaDBParserCHARSET                           = 848
	MariaDBParserCHAR_LENGTH                       = 849
	MariaDBParserCOERCIBILITY                      = 850
	MariaDBParserCOLLATION                         = 851
	MariaDBParserCOMPRESS                          = 852
	MariaDBParserCONCAT                            = 853
	MariaDBParserCONCAT_WS                         = 854
	MariaDBParserCONNECTION_ID                     = 855
	MariaDBParserCONV                              = 856
	MariaDBParserCONVERT_TZ                        = 857
	MariaDBParserCOS                               = 858
	MariaDBParserCOT                               = 859
	MariaDBParserCRC32                             = 860
	MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY        = 861
	MariaDBParserCREATE_ASYMMETRIC_PUB_KEY         = 862
	MariaDBParserCREATE_DH_PARAMETERS              = 863
	MariaDBParserCREATE_DIGEST                     = 864
	MariaDBParserCROSSES                           = 865
	MariaDBParserDATEDIFF                          = 866
	MariaDBParserDATE_FORMAT                       = 867
	MariaDBParserDAYNAME                           = 868
	MariaDBParserDAYOFMONTH                        = 869
	MariaDBParserDAYOFWEEK                         = 870
	MariaDBParserDAYOFYEAR                         = 871
	MariaDBParserDECODE                            = 872
	MariaDBParserDEGREES                           = 873
	MariaDBParserDES_DECRYPT                       = 874
	MariaDBParserDES_ENCRYPT                       = 875
	MariaDBParserDIMENSION                         = 876
	MariaDBParserDISJOINT                          = 877
	MariaDBParserELT                               = 878
	MariaDBParserENCODE                            = 879
	MariaDBParserENCRYPT                           = 880
	MariaDBParserENDPOINT                          = 881
	MariaDBParserENGINE_ATTRIBUTE                  = 882
	MariaDBParserENVELOPE                          = 883
	MariaDBParserEQUALS                            = 884
	MariaDBParserEXP                               = 885
	MariaDBParserEXPORT_SET                        = 886
	MariaDBParserEXTERIORRING                      = 887
	MariaDBParserEXTRACTVALUE                      = 888
	MariaDBParserFIELD                             = 889
	MariaDBParserFIND_IN_SET                       = 890
	MariaDBParserFLOOR                             = 891
	MariaDBParserFORMAT                            = 892
	MariaDBParserFOUND_ROWS                        = 893
	MariaDBParserFROM_BASE64                       = 894
	MariaDBParserFROM_DAYS                         = 895
	MariaDBParserFROM_UNIXTIME                     = 896
	MariaDBParserGEOMCOLLFROMTEXT                  = 897
	MariaDBParserGEOMCOLLFROMWKB                   = 898
	MariaDBParserGEOMETRYCOLLECTIONFROMTEXT        = 899
	MariaDBParserGEOMETRYCOLLECTIONFROMWKB         = 900
	MariaDBParserGEOMETRYFROMTEXT                  = 901
	MariaDBParserGEOMETRYFROMWKB                   = 902
	MariaDBParserGEOMETRYN                         = 903
	MariaDBParserGEOMETRYTYPE                      = 904
	MariaDBParserGEOMFROMTEXT                      = 905
	MariaDBParserGEOMFROMWKB                       = 906
	MariaDBParserGET_FORMAT                        = 907
	MariaDBParserGET_LOCK                          = 908
	MariaDBParserGLENGTH                           = 909
	MariaDBParserGREATEST                          = 910
	MariaDBParserGTID_SUBSET                       = 911
	MariaDBParserGTID_SUBTRACT                     = 912
	MariaDBParserHEX                               = 913
	MariaDBParserIFNULL                            = 914
	MariaDBParserINET6_ATON                        = 915
	MariaDBParserINET6_NTOA                        = 916
	MariaDBParserINET_ATON                         = 917
	MariaDBParserINET_NTOA                         = 918
	MariaDBParserINSTR                             = 919
	MariaDBParserINTERIORRINGN                     = 920
	MariaDBParserINTERSECTS                        = 921
	MariaDBParserISCLOSED                          = 922
	MariaDBParserISEMPTY                           = 923
	MariaDBParserISNULL                            = 924
	MariaDBParserISSIMPLE                          = 925
	MariaDBParserIS_FREE_LOCK                      = 926
	MariaDBParserIS_IPV4                           = 927
	MariaDBParserIS_IPV4_COMPAT                    = 928
	MariaDBParserIS_IPV4_MAPPED                    = 929
	MariaDBParserIS_IPV6                           = 930
	MariaDBParserIS_USED_LOCK                      = 931
	MariaDBParserLAST_INSERT_ID                    = 932
	MariaDBParserLCASE                             = 933
	MariaDBParserLEAST                             = 934
	MariaDBParserLENGTH                            = 935
	MariaDBParserLINEFROMTEXT                      = 936
	MariaDBParserLINEFROMWKB                       = 937
	MariaDBParserLINESTRINGFROMTEXT                = 938
	MariaDBParserLINESTRINGFROMWKB                 = 939
	MariaDBParserLN                                = 940
	MariaDBParserLOAD_FILE                         = 941
	MariaDBParserLOCATE                            = 942
	MariaDBParserLOG                               = 943
	MariaDBParserLOG10                             = 944
	MariaDBParserLOG2                              = 945
	MariaDBParserLOWER                             = 946
	MariaDBParserLPAD                              = 947
	MariaDBParserLTRIM                             = 948
	MariaDBParserMAKEDATE                          = 949
	MariaDBParserMAKETIME                          = 950
	MariaDBParserMAKE_SET                          = 951
	MariaDBParserMASTER_POS_WAIT                   = 952
	MariaDBParserMBRCONTAINS                       = 953
	MariaDBParserMBRDISJOINT                       = 954
	MariaDBParserMBREQUAL                          = 955
	MariaDBParserMBRINTERSECTS                     = 956
	MariaDBParserMBROVERLAPS                       = 957
	MariaDBParserMBRTOUCHES                        = 958
	MariaDBParserMBRWITHIN                         = 959
	MariaDBParserMD5                               = 960
	MariaDBParserMLINEFROMTEXT                     = 961
	MariaDBParserMLINEFROMWKB                      = 962
	MariaDBParserMONTHNAME                         = 963
	MariaDBParserMPOINTFROMTEXT                    = 964
	MariaDBParserMPOINTFROMWKB                     = 965
	MariaDBParserMPOLYFROMTEXT                     = 966
	MariaDBParserMPOLYFROMWKB                      = 967
	MariaDBParserMULTILINESTRINGFROMTEXT           = 968
	MariaDBParserMULTILINESTRINGFROMWKB            = 969
	MariaDBParserMULTIPOINTFROMTEXT                = 970
	MariaDBParserMULTIPOINTFROMWKB                 = 971
	MariaDBParserMULTIPOLYGONFROMTEXT              = 972
	MariaDBParserMULTIPOLYGONFROMWKB               = 973
	MariaDBParserNAME_CONST                        = 974
	MariaDBParserNULLIF                            = 975
	MariaDBParserNUMGEOMETRIES                     = 976
	MariaDBParserNUMINTERIORRINGS                  = 977
	MariaDBParserNUMPOINTS                         = 978
	MariaDBParserOCT                               = 979
	MariaDBParserOCTET_LENGTH                      = 980
	MariaDBParserORD                               = 981
	MariaDBParserOVERLAPS                          = 982
	MariaDBParserPERIOD_ADD                        = 983
	MariaDBParserPERIOD_DIFF                       = 984
	MariaDBParserPI                                = 985
	MariaDBParserPOINTFROMTEXT                     = 986
	MariaDBParserPOINTFROMWKB                      = 987
	MariaDBParserPOINTN                            = 988
	MariaDBParserPOLYFROMTEXT                      = 989
	MariaDBParserPOLYFROMWKB                       = 990
	MariaDBParserPOLYGONFROMTEXT                   = 991
	MariaDBParserPOLYGONFROMWKB                    = 992
	MariaDBParserPOW                               = 993
	MariaDBParserPOWER                             = 994
	MariaDBParserQUOTE                             = 995
	MariaDBParserRADIANS                           = 996
	MariaDBParserRAND                              = 997
	MariaDBParserRANDOM_BYTES                      = 998
	MariaDBParserRELEASE_LOCK                      = 999
	MariaDBParserREVERSE                           = 1000
	MariaDBParserROUND                             = 1001
	MariaDBParserROW_COUNT                         = 1002
	MariaDBParserRPAD                              = 1003
	MariaDBParserRTRIM                             = 1004
	MariaDBParserSEC_TO_TIME                       = 1005
	MariaDBParserSECONDARY_ENGINE_ATTRIBUTE        = 1006
	MariaDBParserSESSION_USER                      = 1007
	MariaDBParserSHA                               = 1008
	MariaDBParserSHA1                              = 1009
	MariaDBParserSHA2                              = 1010
	MariaDBParserSCHEMA_NAME                       = 1011
	MariaDBParserSIGN                              = 1012
	MariaDBParserSIN                               = 1013
	MariaDBParserSLEEP                             = 1014
	MariaDBParserSOUNDEX                           = 1015
	MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1016
	MariaDBParserSQRT                              = 1017
	MariaDBParserSRID                              = 1018
	MariaDBParserSTARTPOINT                        = 1019
	MariaDBParserSTRCMP                            = 1020
	MariaDBParserSTR_TO_DATE                       = 1021
	MariaDBParserST_AREA                           = 1022
	MariaDBParserST_ASBINARY                       = 1023
	MariaDBParserST_ASTEXT                         = 1024
	MariaDBParserST_ASWKB                          = 1025
	MariaDBParserST_ASWKT                          = 1026
	MariaDBParserST_BUFFER                         = 1027
	MariaDBParserST_CENTROID                       = 1028
	MariaDBParserST_CONTAINS                       = 1029
	MariaDBParserST_CROSSES                        = 1030
	MariaDBParserST_DIFFERENCE                     = 1031
	MariaDBParserST_DIMENSION                      = 1032
	MariaDBParserST_DISJOINT                       = 1033
	MariaDBParserST_DISTANCE                       = 1034
	MariaDBParserST_ENDPOINT                       = 1035
	MariaDBParserST_ENVELOPE                       = 1036
	MariaDBParserST_EQUALS                         = 1037
	MariaDBParserST_EXTERIORRING                   = 1038
	MariaDBParserST_GEOMCOLLFROMTEXT               = 1039
	MariaDBParserST_GEOMCOLLFROMTXT                = 1040
	MariaDBParserST_GEOMCOLLFROMWKB                = 1041
	MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1042
	MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB      = 1043
	MariaDBParserST_GEOMETRYFROMTEXT               = 1044
	MariaDBParserST_GEOMETRYFROMWKB                = 1045
	MariaDBParserST_GEOMETRYN                      = 1046
	MariaDBParserST_GEOMETRYTYPE                   = 1047
	MariaDBParserST_GEOMFROMTEXT                   = 1048
	MariaDBParserST_GEOMFROMWKB                    = 1049
	MariaDBParserST_INTERIORRINGN                  = 1050
	MariaDBParserST_INTERSECTION                   = 1051
	MariaDBParserST_INTERSECTS                     = 1052
	MariaDBParserST_ISCLOSED                       = 1053
	MariaDBParserST_ISEMPTY                        = 1054
	MariaDBParserST_ISSIMPLE                       = 1055
	MariaDBParserST_LINEFROMTEXT                   = 1056
	MariaDBParserST_LINEFROMWKB                    = 1057
	MariaDBParserST_LINESTRINGFROMTEXT             = 1058
	MariaDBParserST_LINESTRINGFROMWKB              = 1059
	MariaDBParserST_NUMGEOMETRIES                  = 1060
	MariaDBParserST_NUMINTERIORRING                = 1061
	MariaDBParserST_NUMINTERIORRINGS               = 1062
	MariaDBParserST_NUMPOINTS                      = 1063
	MariaDBParserST_OVERLAPS                       = 1064
	MariaDBParserST_POINTFROMTEXT                  = 1065
	MariaDBParserST_POINTFROMWKB                   = 1066
	MariaDBParserST_POINTN                         = 1067
	MariaDBParserST_POLYFROMTEXT                   = 1068
	MariaDBParserST_POLYFROMWKB                    = 1069
	MariaDBParserST_POLYGONFROMTEXT                = 1070
	MariaDBParserST_POLYGONFROMWKB                 = 1071
	MariaDBParserST_SRID                           = 1072
	MariaDBParserST_STARTPOINT                     = 1073
	MariaDBParserST_SYMDIFFERENCE                  = 1074
	MariaDBParserST_TOUCHES                        = 1075
	MariaDBParserST_UNION                          = 1076
	MariaDBParserST_WITHIN                         = 1077
	MariaDBParserST_X                              = 1078
	MariaDBParserST_Y                              = 1079
	MariaDBParserSUBDATE                           = 1080
	MariaDBParserSUBSTRING_INDEX                   = 1081
	MariaDBParserSUBTIME                           = 1082
	MariaDBParserSYSTEM_USER                       = 1083
	MariaDBParserTAN                               = 1084
	MariaDBParserTIMEDIFF                          = 1085
	MariaDBParserTIMESTAMPADD                      = 1086
	MariaDBParserTIMESTAMPDIFF                     = 1087
	MariaDBParserTIME_FORMAT                       = 1088
	MariaDBParserTIME_TO_SEC                       = 1089
	MariaDBParserTOUCHES                           = 1090
	MariaDBParserTO_BASE64                         = 1091
	MariaDBParserTO_DAYS                           = 1092
	MariaDBParserTO_SECONDS                        = 1093
	MariaDBParserUCASE                             = 1094
	MariaDBParserUNCOMPRESS                        = 1095
	MariaDBParserUNCOMPRESSED_LENGTH               = 1096
	MariaDBParserUNHEX                             = 1097
	MariaDBParserUNIX_TIMESTAMP                    = 1098
	MariaDBParserUPDATEXML                         = 1099
	MariaDBParserUPPER                             = 1100
	MariaDBParserUUID                              = 1101
	MariaDBParserUUID_SHORT                        = 1102
	MariaDBParserVALIDATE_PASSWORD_STRENGTH        = 1103
	MariaDBParserVERSION                           = 1104
	MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1105
	MariaDBParserWEEKDAY                           = 1106
	MariaDBParserWEEKOFYEAR                        = 1107
	MariaDBParserWEIGHT_STRING                     = 1108
	MariaDBParserWITHIN                            = 1109
	MariaDBParserYEARWEEK                          = 1110
	MariaDBParserY_FUNCTION                        = 1111
	MariaDBParserX_FUNCTION                        = 1112
	MariaDBParserVIA                               = 1113
	MariaDBParserLASTVAL                           = 1114
	MariaDBParserNEXTVAL                           = 1115
	MariaDBParserSETVAL                            = 1116
	MariaDBParserPREVIOUS                          = 1117
	MariaDBParserPERSISTENT                        = 1118
	MariaDBParserBINLOG_MONITOR                    = 1119
	MariaDBParserBINLOG_REPLAY                     = 1120
	MariaDBParserFEDERATED_ADMIN                   = 1121
	MariaDBParserREAD_ONLY_ADMIN                   = 1122
	MariaDBParserREPLICA                           = 1123
	MariaDBParserREPLICAS                          = 1124
	MariaDBParserREPLICATION_MASTER_ADMIN          = 1125
	MariaDBParserMONITOR                           = 1126
	MariaDBParserREAD_ONLY                         = 1127
	MariaDBParserREPLAY                            = 1128
	MariaDBParserVAR_ASSIGN                        = 1129
	MariaDBParserPLUS_ASSIGN                       = 1130
	MariaDBParserMINUS_ASSIGN                      = 1131
	MariaDBParserMULT_ASSIGN                       = 1132
	MariaDBParserDIV_ASSIGN                        = 1133
	MariaDBParserMOD_ASSIGN                        = 1134
	MariaDBParserAND_ASSIGN                        = 1135
	MariaDBParserXOR_ASSIGN                        = 1136
	MariaDBParserOR_ASSIGN                         = 1137
	MariaDBParserSTAR                              = 1138
	MariaDBParserDIVIDE                            = 1139
	MariaDBParserMODULE                            = 1140
	MariaDBParserPLUS                              = 1141
	MariaDBParserMINUS                             = 1142
	MariaDBParserDIV                               = 1143
	MariaDBParserMOD                               = 1144
	MariaDBParserEQUAL_SYMBOL                      = 1145
	MariaDBParserGREATER_SYMBOL                    = 1146
	MariaDBParserLESS_SYMBOL                       = 1147
	MariaDBParserEXCLAMATION_SYMBOL                = 1148
	MariaDBParserBIT_NOT_OP                        = 1149
	MariaDBParserBIT_OR_OP                         = 1150
	MariaDBParserBIT_AND_OP                        = 1151
	MariaDBParserBIT_XOR_OP                        = 1152
	MariaDBParserDOT                               = 1153
	MariaDBParserLR_BRACKET                        = 1154
	MariaDBParserRR_BRACKET                        = 1155
	MariaDBParserCOMMA                             = 1156
	MariaDBParserSEMI                              = 1157
	MariaDBParserAT_SIGN                           = 1158
	MariaDBParserZERO_DECIMAL                      = 1159
	MariaDBParserONE_DECIMAL                       = 1160
	MariaDBParserTWO_DECIMAL                       = 1161
	MariaDBParserSINGLE_QUOTE_SYMB                 = 1162
	MariaDBParserDOUBLE_QUOTE_SYMB                 = 1163
	MariaDBParserREVERSE_QUOTE_SYMB                = 1164
	MariaDBParserCOLON_SYMB                        = 1165
	MariaDBParserCHARSET_REVERSE_QOUTE_STRING      = 1166
	MariaDBParserFILESIZE_LITERAL                  = 1167
	MariaDBParserSTART_NATIONAL_STRING_LITERAL     = 1168
	MariaDBParserSTRING_LITERAL                    = 1169
	MariaDBParserDECIMAL_LITERAL                   = 1170
	MariaDBParserHEXADECIMAL_LITERAL               = 1171
	MariaDBParserREAL_LITERAL                      = 1172
	MariaDBParserNULL_SPEC_LITERAL                 = 1173
	MariaDBParserBIT_STRING                        = 1174
	MariaDBParserSTRING_CHARSET_NAME               = 1175
	MariaDBParserDOT_ID                            = 1176
	MariaDBParserID                                = 1177
	MariaDBParserREVERSE_QUOTE_ID                  = 1178
	MariaDBParserSTRING_USER_NAME                  = 1179
	MariaDBParserIP_ADDRESS                        = 1180
	MariaDBParserSTRING_USER_NAME_MARIADB          = 1181
	MariaDBParserLOCAL_ID                          = 1182
	MariaDBParserGLOBAL_ID                         = 1183
	MariaDBParserERROR_RECONGNIGION                = 1184
)

// MariaDBParser rules.
const (
	MariaDBParserRULE_root                                = 0
	MariaDBParserRULE_sqlStatements                       = 1
	MariaDBParserRULE_sqlStatement                        = 2
	MariaDBParserRULE_setStatementFor                     = 3
	MariaDBParserRULE_emptyStatement_                     = 4
	MariaDBParserRULE_ddlStatement                        = 5
	MariaDBParserRULE_dmlStatement                        = 6
	MariaDBParserRULE_transactionStatement                = 7
	MariaDBParserRULE_replicationStatement                = 8
	MariaDBParserRULE_preparedStatement                   = 9
	MariaDBParserRULE_compoundStatement                   = 10
	MariaDBParserRULE_administrationStatement             = 11
	MariaDBParserRULE_utilityStatement                    = 12
	MariaDBParserRULE_createDatabase                      = 13
	MariaDBParserRULE_createEvent                         = 14
	MariaDBParserRULE_createIndex                         = 15
	MariaDBParserRULE_createLogfileGroup                  = 16
	MariaDBParserRULE_createProcedure                     = 17
	MariaDBParserRULE_createFunction                      = 18
	MariaDBParserRULE_createRole                          = 19
	MariaDBParserRULE_createServer                        = 20
	MariaDBParserRULE_createTable                         = 21
	MariaDBParserRULE_createTablespaceInnodb              = 22
	MariaDBParserRULE_createTablespaceNdb                 = 23
	MariaDBParserRULE_createTrigger                       = 24
	MariaDBParserRULE_withClause                          = 25
	MariaDBParserRULE_commonTableExpressions              = 26
	MariaDBParserRULE_cteName                             = 27
	MariaDBParserRULE_cteColumnName                       = 28
	MariaDBParserRULE_createView                          = 29
	MariaDBParserRULE_createSequence                      = 30
	MariaDBParserRULE_sequenceSpec                        = 31
	MariaDBParserRULE_createDatabaseOption                = 32
	MariaDBParserRULE_charSet                             = 33
	MariaDBParserRULE_currentUserExpression               = 34
	MariaDBParserRULE_ownerStatement                      = 35
	MariaDBParserRULE_scheduleExpression                  = 36
	MariaDBParserRULE_timestampValue                      = 37
	MariaDBParserRULE_intervalExpr                        = 38
	MariaDBParserRULE_intervalType                        = 39
	MariaDBParserRULE_enableType                          = 40
	MariaDBParserRULE_indexType                           = 41
	MariaDBParserRULE_indexOption                         = 42
	MariaDBParserRULE_procedureParameter                  = 43
	MariaDBParserRULE_functionParameter                   = 44
	MariaDBParserRULE_routineOption                       = 45
	MariaDBParserRULE_serverOption                        = 46
	MariaDBParserRULE_createDefinitions                   = 47
	MariaDBParserRULE_createDefinition                    = 48
	MariaDBParserRULE_columnDefinition                    = 49
	MariaDBParserRULE_columnConstraint                    = 50
	MariaDBParserRULE_tableConstraint                     = 51
	MariaDBParserRULE_referenceDefinition                 = 52
	MariaDBParserRULE_referenceAction                     = 53
	MariaDBParserRULE_referenceControlType                = 54
	MariaDBParserRULE_indexColumnDefinition               = 55
	MariaDBParserRULE_tableOption                         = 56
	MariaDBParserRULE_tableType                           = 57
	MariaDBParserRULE_tablespaceStorage                   = 58
	MariaDBParserRULE_partitionDefinitions                = 59
	MariaDBParserRULE_partitionFunctionDefinition         = 60
	MariaDBParserRULE_subpartitionFunctionDefinition      = 61
	MariaDBParserRULE_partitionDefinition                 = 62
	MariaDBParserRULE_partitionDefinerAtom                = 63
	MariaDBParserRULE_partitionDefinerVector              = 64
	MariaDBParserRULE_subpartitionDefinition              = 65
	MariaDBParserRULE_partitionOption                     = 66
	MariaDBParserRULE_alterDatabase                       = 67
	MariaDBParserRULE_alterEvent                          = 68
	MariaDBParserRULE_alterFunction                       = 69
	MariaDBParserRULE_alterInstance                       = 70
	MariaDBParserRULE_alterLogfileGroup                   = 71
	MariaDBParserRULE_alterProcedure                      = 72
	MariaDBParserRULE_alterServer                         = 73
	MariaDBParserRULE_alterTable                          = 74
	MariaDBParserRULE_alterTablespace                     = 75
	MariaDBParserRULE_alterView                           = 76
	MariaDBParserRULE_alterSequence                       = 77
	MariaDBParserRULE_alterSpecification                  = 78
	MariaDBParserRULE_dropDatabase                        = 79
	MariaDBParserRULE_dropEvent                           = 80
	MariaDBParserRULE_dropIndex                           = 81
	MariaDBParserRULE_dropLogfileGroup                    = 82
	MariaDBParserRULE_dropProcedure                       = 83
	MariaDBParserRULE_dropFunction                        = 84
	MariaDBParserRULE_dropServer                          = 85
	MariaDBParserRULE_dropTable                           = 86
	MariaDBParserRULE_dropTablespace                      = 87
	MariaDBParserRULE_dropTrigger                         = 88
	MariaDBParserRULE_dropView                            = 89
	MariaDBParserRULE_dropRole                            = 90
	MariaDBParserRULE_setRole                             = 91
	MariaDBParserRULE_dropSequence                        = 92
	MariaDBParserRULE_renameTable                         = 93
	MariaDBParserRULE_renameTableClause                   = 94
	MariaDBParserRULE_truncateTable                       = 95
	MariaDBParserRULE_callStatement                       = 96
	MariaDBParserRULE_deleteStatement                     = 97
	MariaDBParserRULE_doStatement                         = 98
	MariaDBParserRULE_handlerStatement                    = 99
	MariaDBParserRULE_insertStatement                     = 100
	MariaDBParserRULE_loadDataStatement                   = 101
	MariaDBParserRULE_loadXmlStatement                    = 102
	MariaDBParserRULE_replaceStatement                    = 103
	MariaDBParserRULE_selectStatement                     = 104
	MariaDBParserRULE_updateStatement                     = 105
	MariaDBParserRULE_valuesStatement                     = 106
	MariaDBParserRULE_insertStatementValue                = 107
	MariaDBParserRULE_updatedElement                      = 108
	MariaDBParserRULE_assignmentField                     = 109
	MariaDBParserRULE_lockClause                          = 110
	MariaDBParserRULE_singleDeleteStatement               = 111
	MariaDBParserRULE_multipleDeleteStatement             = 112
	MariaDBParserRULE_handlerOpenStatement                = 113
	MariaDBParserRULE_handlerReadIndexStatement           = 114
	MariaDBParserRULE_handlerReadStatement                = 115
	MariaDBParserRULE_handlerCloseStatement               = 116
	MariaDBParserRULE_singleUpdateStatement               = 117
	MariaDBParserRULE_multipleUpdateStatement             = 118
	MariaDBParserRULE_orderByClause                       = 119
	MariaDBParserRULE_orderByExpression                   = 120
	MariaDBParserRULE_tableSources                        = 121
	MariaDBParserRULE_tableSource                         = 122
	MariaDBParserRULE_tableSourceItem                     = 123
	MariaDBParserRULE_indexHint                           = 124
	MariaDBParserRULE_indexHintType                       = 125
	MariaDBParserRULE_joinPart                            = 126
	MariaDBParserRULE_queryExpression                     = 127
	MariaDBParserRULE_queryExpressionNointo               = 128
	MariaDBParserRULE_querySpecification                  = 129
	MariaDBParserRULE_querySpecificationNointo            = 130
	MariaDBParserRULE_unionParenthesis                    = 131
	MariaDBParserRULE_unionStatement                      = 132
	MariaDBParserRULE_lateralStatement                    = 133
	MariaDBParserRULE_jsonTable                           = 134
	MariaDBParserRULE_jsonColumnList                      = 135
	MariaDBParserRULE_jsonColumn                          = 136
	MariaDBParserRULE_jsonOnEmpty                         = 137
	MariaDBParserRULE_jsonOnError                         = 138
	MariaDBParserRULE_selectSpec                          = 139
	MariaDBParserRULE_selectElements                      = 140
	MariaDBParserRULE_selectElement                       = 141
	MariaDBParserRULE_selectIntoExpression                = 142
	MariaDBParserRULE_selectFieldsInto                    = 143
	MariaDBParserRULE_selectLinesInto                     = 144
	MariaDBParserRULE_fromClause                          = 145
	MariaDBParserRULE_groupByClause                       = 146
	MariaDBParserRULE_havingClause                        = 147
	MariaDBParserRULE_windowClause                        = 148
	MariaDBParserRULE_groupByItem                         = 149
	MariaDBParserRULE_limitClause                         = 150
	MariaDBParserRULE_limitClauseAtom                     = 151
	MariaDBParserRULE_startTransaction                    = 152
	MariaDBParserRULE_beginWork                           = 153
	MariaDBParserRULE_commitWork                          = 154
	MariaDBParserRULE_rollbackWork                        = 155
	MariaDBParserRULE_savepointStatement                  = 156
	MariaDBParserRULE_rollbackStatement                   = 157
	MariaDBParserRULE_releaseStatement                    = 158
	MariaDBParserRULE_lockTables                          = 159
	MariaDBParserRULE_unlockTables                        = 160
	MariaDBParserRULE_setAutocommitStatement              = 161
	MariaDBParserRULE_setTransactionStatement             = 162
	MariaDBParserRULE_transactionMode                     = 163
	MariaDBParserRULE_lockTableElement                    = 164
	MariaDBParserRULE_lockAction                          = 165
	MariaDBParserRULE_transactionOption                   = 166
	MariaDBParserRULE_transactionLevel                    = 167
	MariaDBParserRULE_changeMaster                        = 168
	MariaDBParserRULE_changeReplicationFilter             = 169
	MariaDBParserRULE_purgeBinaryLogs                     = 170
	MariaDBParserRULE_resetMaster                         = 171
	MariaDBParserRULE_resetSlave                          = 172
	MariaDBParserRULE_startSlave                          = 173
	MariaDBParserRULE_stopSlave                           = 174
	MariaDBParserRULE_startGroupReplication               = 175
	MariaDBParserRULE_stopGroupReplication                = 176
	MariaDBParserRULE_masterOption                        = 177
	MariaDBParserRULE_stringMasterOption                  = 178
	MariaDBParserRULE_decimalMasterOption                 = 179
	MariaDBParserRULE_boolMasterOption                    = 180
	MariaDBParserRULE_channelOption                       = 181
	MariaDBParserRULE_replicationFilter                   = 182
	MariaDBParserRULE_tablePair                           = 183
	MariaDBParserRULE_threadType                          = 184
	MariaDBParserRULE_untilOption                         = 185
	MariaDBParserRULE_connectionOption                    = 186
	MariaDBParserRULE_gtuidSet                            = 187
	MariaDBParserRULE_xaStartTransaction                  = 188
	MariaDBParserRULE_xaEndTransaction                    = 189
	MariaDBParserRULE_xaPrepareStatement                  = 190
	MariaDBParserRULE_xaCommitWork                        = 191
	MariaDBParserRULE_xaRollbackWork                      = 192
	MariaDBParserRULE_xaRecoverWork                       = 193
	MariaDBParserRULE_prepareStatement                    = 194
	MariaDBParserRULE_executeStatement                    = 195
	MariaDBParserRULE_deallocatePrepare                   = 196
	MariaDBParserRULE_routineBody                         = 197
	MariaDBParserRULE_blockStatement                      = 198
	MariaDBParserRULE_caseStatement                       = 199
	MariaDBParserRULE_ifStatement                         = 200
	MariaDBParserRULE_iterateStatement                    = 201
	MariaDBParserRULE_leaveStatement                      = 202
	MariaDBParserRULE_loopStatement                       = 203
	MariaDBParserRULE_repeatStatement                     = 204
	MariaDBParserRULE_returnStatement                     = 205
	MariaDBParserRULE_whileStatement                      = 206
	MariaDBParserRULE_cursorStatement                     = 207
	MariaDBParserRULE_declareVariable                     = 208
	MariaDBParserRULE_declareCondition                    = 209
	MariaDBParserRULE_declareCursor                       = 210
	MariaDBParserRULE_declareHandler                      = 211
	MariaDBParserRULE_handlerConditionValue               = 212
	MariaDBParserRULE_procedureSqlStatement               = 213
	MariaDBParserRULE_caseAlternative                     = 214
	MariaDBParserRULE_elifAlternative                     = 215
	MariaDBParserRULE_alterUser                           = 216
	MariaDBParserRULE_createUser                          = 217
	MariaDBParserRULE_dropUser                            = 218
	MariaDBParserRULE_grantStatement                      = 219
	MariaDBParserRULE_roleOption                          = 220
	MariaDBParserRULE_grantProxy                          = 221
	MariaDBParserRULE_renameUser                          = 222
	MariaDBParserRULE_revokeStatement                     = 223
	MariaDBParserRULE_revokeProxy                         = 224
	MariaDBParserRULE_setPasswordStatement                = 225
	MariaDBParserRULE_userSpecification                   = 226
	MariaDBParserRULE_userAuthOption                      = 227
	MariaDBParserRULE_authenticationRule                  = 228
	MariaDBParserRULE_tlsOption                           = 229
	MariaDBParserRULE_userResourceOption                  = 230
	MariaDBParserRULE_userPasswordOption                  = 231
	MariaDBParserRULE_userLockOption                      = 232
	MariaDBParserRULE_privelegeClause                     = 233
	MariaDBParserRULE_privilege                           = 234
	MariaDBParserRULE_privilegeLevel                      = 235
	MariaDBParserRULE_renameUserClause                    = 236
	MariaDBParserRULE_analyzeTable                        = 237
	MariaDBParserRULE_checkTable                          = 238
	MariaDBParserRULE_checksumTable                       = 239
	MariaDBParserRULE_optimizeTable                       = 240
	MariaDBParserRULE_repairTable                         = 241
	MariaDBParserRULE_checkTableOption                    = 242
	MariaDBParserRULE_createUdfunction                    = 243
	MariaDBParserRULE_installPlugin                       = 244
	MariaDBParserRULE_uninstallPlugin                     = 245
	MariaDBParserRULE_setStatement                        = 246
	MariaDBParserRULE_showStatement                       = 247
	MariaDBParserRULE_explainStatement                    = 248
	MariaDBParserRULE_variableClause                      = 249
	MariaDBParserRULE_showCommonEntity                    = 250
	MariaDBParserRULE_showFilter                          = 251
	MariaDBParserRULE_showGlobalInfoClause                = 252
	MariaDBParserRULE_showSchemaEntity                    = 253
	MariaDBParserRULE_showProfileType                     = 254
	MariaDBParserRULE_binlogStatement                     = 255
	MariaDBParserRULE_cacheIndexStatement                 = 256
	MariaDBParserRULE_flushStatement                      = 257
	MariaDBParserRULE_killStatement                       = 258
	MariaDBParserRULE_loadIndexIntoCache                  = 259
	MariaDBParserRULE_resetStatement                      = 260
	MariaDBParserRULE_shutdownStatement                   = 261
	MariaDBParserRULE_tableIndexes                        = 262
	MariaDBParserRULE_flushOption                         = 263
	MariaDBParserRULE_flushTableOption                    = 264
	MariaDBParserRULE_loadedTableIndexes                  = 265
	MariaDBParserRULE_simpleDescribeStatement             = 266
	MariaDBParserRULE_fullDescribeStatement               = 267
	MariaDBParserRULE_formatJsonStatement                 = 268
	MariaDBParserRULE_helpStatement                       = 269
	MariaDBParserRULE_useStatement                        = 270
	MariaDBParserRULE_signalStatement                     = 271
	MariaDBParserRULE_resignalStatement                   = 272
	MariaDBParserRULE_signalConditionInformation          = 273
	MariaDBParserRULE_diagnosticsStatement                = 274
	MariaDBParserRULE_diagnosticsConditionInformationName = 275
	MariaDBParserRULE_describeObjectClause                = 276
	MariaDBParserRULE_fullId                              = 277
	MariaDBParserRULE_tableName                           = 278
	MariaDBParserRULE_roleName                            = 279
	MariaDBParserRULE_fullColumnName                      = 280
	MariaDBParserRULE_indexColumnName                     = 281
	MariaDBParserRULE_userName                            = 282
	MariaDBParserRULE_mysqlVariable                       = 283
	MariaDBParserRULE_charsetName                         = 284
	MariaDBParserRULE_collationName                       = 285
	MariaDBParserRULE_engineName                          = 286
	MariaDBParserRULE_encryptedLiteral                    = 287
	MariaDBParserRULE_uuidSet                             = 288
	MariaDBParserRULE_xid                                 = 289
	MariaDBParserRULE_xuidStringId                        = 290
	MariaDBParserRULE_authPlugin                          = 291
	MariaDBParserRULE_uid                                 = 292
	MariaDBParserRULE_simpleId                            = 293
	MariaDBParserRULE_dottedId                            = 294
	MariaDBParserRULE_decimalLiteral                      = 295
	MariaDBParserRULE_fileSizeLiteral                     = 296
	MariaDBParserRULE_stringLiteral                       = 297
	MariaDBParserRULE_booleanLiteral                      = 298
	MariaDBParserRULE_hexadecimalLiteral                  = 299
	MariaDBParserRULE_nullNotnull                         = 300
	MariaDBParserRULE_constant                            = 301
	MariaDBParserRULE_dataType                            = 302
	MariaDBParserRULE_collectionOptions                   = 303
	MariaDBParserRULE_convertedDataType                   = 304
	MariaDBParserRULE_lengthOneDimension                  = 305
	MariaDBParserRULE_lengthTwoDimension                  = 306
	MariaDBParserRULE_lengthTwoOptionalDimension          = 307
	MariaDBParserRULE_uidList                             = 308
	MariaDBParserRULE_tables                              = 309
	MariaDBParserRULE_indexColumnNames                    = 310
	MariaDBParserRULE_expressions                         = 311
	MariaDBParserRULE_expressionsWithDefaults             = 312
	MariaDBParserRULE_constants                           = 313
	MariaDBParserRULE_simpleStrings                       = 314
	MariaDBParserRULE_userVariables                       = 315
	MariaDBParserRULE_defaultValue                        = 316
	MariaDBParserRULE_currentTimestamp                    = 317
	MariaDBParserRULE_expressionOrDefault                 = 318
	MariaDBParserRULE_ifExists                            = 319
	MariaDBParserRULE_ifNotExists                         = 320
	MariaDBParserRULE_orReplace                           = 321
	MariaDBParserRULE_waitNowaitClause                    = 322
	MariaDBParserRULE_lockOption                          = 323
	MariaDBParserRULE_functionCall                        = 324
	MariaDBParserRULE_specificFunction                    = 325
	MariaDBParserRULE_caseFuncAlternative                 = 326
	MariaDBParserRULE_levelsInWeightString                = 327
	MariaDBParserRULE_levelInWeightListElement            = 328
	MariaDBParserRULE_aggregateWindowedFunction           = 329
	MariaDBParserRULE_nonAggregateWindowedFunction        = 330
	MariaDBParserRULE_overClause                          = 331
	MariaDBParserRULE_windowSpec                          = 332
	MariaDBParserRULE_windowName                          = 333
	MariaDBParserRULE_frameClause                         = 334
	MariaDBParserRULE_frameUnits                          = 335
	MariaDBParserRULE_frameExtent                         = 336
	MariaDBParserRULE_frameBetween                        = 337
	MariaDBParserRULE_frameRange                          = 338
	MariaDBParserRULE_partitionClause                     = 339
	MariaDBParserRULE_scalarFunctionName                  = 340
	MariaDBParserRULE_passwordFunctionClause              = 341
	MariaDBParserRULE_functionArgs                        = 342
	MariaDBParserRULE_functionArg                         = 343
	MariaDBParserRULE_expression                          = 344
	MariaDBParserRULE_predicate                           = 345
	MariaDBParserRULE_expressionAtom                      = 346
	MariaDBParserRULE_unaryOperator                       = 347
	MariaDBParserRULE_comparisonOperator                  = 348
	MariaDBParserRULE_logicalOperator                     = 349
	MariaDBParserRULE_bitOperator                         = 350
	MariaDBParserRULE_mathOperator                        = 351
	MariaDBParserRULE_jsonOperator                        = 352
	MariaDBParserRULE_charsetNameBase                     = 353
	MariaDBParserRULE_transactionLevelBase                = 354
	MariaDBParserRULE_privilegesBase                      = 355
	MariaDBParserRULE_intervalTypeBase                    = 356
	MariaDBParserRULE_dataTypeBase                        = 357
	MariaDBParserRULE_keywordsCanBeId                     = 358
	MariaDBParserRULE_functionNameBase                    = 359
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SqlStatements() ISqlStatementsContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MariaDBParserRULE_root)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4616435926009119360) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&4611967499850760195) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&747667907330603) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&36099165796700291) != 0) || ((int64((_la-432)) & ^0x3f) == 0 && ((int64(1)<<(_la-432))&16782337) != 0) || ((int64((_la-561)) & ^0x3f) == 0 && ((int64(1)<<(_la-561))&35460325834753) != 0) || ((int64((_la-632)) & ^0x3f) == 0 && ((int64(1)<<(_la-632))&36028805743116353) != 0) || _la == MariaDBParserEXECUTE || _la == MariaDBParserSHUTDOWN || _la == MariaDBParserLR_BRACKET || _la == MariaDBParserSEMI {
		{
			p.SetState(720)
			p.SqlStatements()
		}

	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserMINUS {
		{
			p.SetState(723)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(727)
		p.Match(MariaDBParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSqlStatement() []ISqlStatementContext
	SqlStatement(i int) ISqlStatementContext
	AllEmptyStatement_() []IEmptyStatement_Context
	EmptyStatement_(i int) IEmptyStatement_Context
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MariaDBParserRULE_sqlStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(738)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserLR_BRACKET:
				{
					p.SetState(729)
					p.SqlStatement()
				}
				p.SetState(732)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserMINUS {
					{
						p.SetState(730)
						p.Match(MariaDBParserMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(731)
						p.Match(MariaDBParserMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(735)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(734)
						p.Match(MariaDBParserSEMI)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case MariaDBParserSEMI:
				{
					p.SetState(737)
					p.EmptyStatement_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserLR_BRACKET:
		{
			p.SetState(743)
			p.SqlStatement()
		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserMINUS {
				{
					p.SetState(744)
					p.Match(MariaDBParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(745)
					p.Match(MariaDBParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(748)
				p.Match(MariaDBParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserSEMI:
		{
			p.SetState(751)
			p.EmptyStatement_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DdlStatement() IDdlStatementContext
	DmlStatement() IDmlStatementContext
	TransactionStatement() ITransactionStatementContext
	ReplicationStatement() IReplicationStatementContext
	PreparedStatement() IPreparedStatementContext
	AdministrationStatement() IAdministrationStatementContext
	UtilityStatement() IUtilityStatementContext
	SetStatementFor() ISetStatementForContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *SqlStatementContext) ReplicationStatement() IReplicationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationStatementContext)
}

func (s *SqlStatementContext) PreparedStatement() IPreparedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparedStatementContext)
}

func (s *SqlStatementContext) AdministrationStatement() IAdministrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdministrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdministrationStatementContext)
}

func (s *SqlStatementContext) UtilityStatement() IUtilityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtilityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtilityStatementContext)
}

func (s *SqlStatementContext) SetStatementFor() ISetStatementForContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementForContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementForContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MariaDBParserRULE_sqlStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(755)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(754)
			p.SetStatementFor()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(757)
			p.DdlStatement()
		}

	case 2:
		{
			p.SetState(758)
			p.DmlStatement()
		}

	case 3:
		{
			p.SetState(759)
			p.TransactionStatement()
		}

	case 4:
		{
			p.SetState(760)
			p.ReplicationStatement()
		}

	case 5:
		{
			p.SetState(761)
			p.PreparedStatement()
		}

	case 6:
		{
			p.SetState(762)
			p.AdministrationStatement()
		}

	case 7:
		{
			p.SetState(763)
			p.UtilityStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementForContext is an interface to support dynamic dispatch.
type ISetStatementForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	STATEMENT() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	FOR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetStatementForContext differentiates from other interfaces.
	IsSetStatementForContext()
}

type SetStatementForContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementForContext() *SetStatementForContext {
	var p = new(SetStatementForContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setStatementFor
	return p
}

func InitEmptySetStatementForContext(p *SetStatementForContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setStatementFor
}

func (*SetStatementForContext) IsSetStatementForContext() {}

func NewSetStatementForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementForContext {
	var p = new(SetStatementForContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setStatementFor

	return p
}

func (s *SetStatementForContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementForContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetStatementForContext) STATEMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATEMENT, 0)
}

func (s *SetStatementForContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserID)
}

func (s *SetStatementForContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, i)
}

func (s *SetStatementForContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *SetStatementForContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *SetStatementForContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementForContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *SetStatementForContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *SetStatementForContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SetStatementForContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SetStatementForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetStatementFor(s)
	}
}

func (s *SetStatementForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetStatementFor(s)
	}
}

func (s *SetStatementForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetStatementFor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetStatementFor() (localctx ISetStatementForContext) {
	localctx = NewSetStatementForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MariaDBParserRULE_setStatementFor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.Match(MariaDBParserSTATEMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)
		p.Match(MariaDBParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Constant()
	}
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(771)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(772)
			p.Match(MariaDBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(774)
			p.Constant()
		}

		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(780)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MariaDBParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(MariaDBParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateDatabase() ICreateDatabaseContext
	CreateEvent() ICreateEventContext
	CreateIndex() ICreateIndexContext
	CreateLogfileGroup() ICreateLogfileGroupContext
	CreateProcedure() ICreateProcedureContext
	CreateFunction() ICreateFunctionContext
	CreateServer() ICreateServerContext
	CreateTable() ICreateTableContext
	CreateTablespaceInnodb() ICreateTablespaceInnodbContext
	CreateTablespaceNdb() ICreateTablespaceNdbContext
	CreateTrigger() ICreateTriggerContext
	CreateView() ICreateViewContext
	CreateRole() ICreateRoleContext
	CreateSequence() ICreateSequenceContext
	AlterDatabase() IAlterDatabaseContext
	AlterEvent() IAlterEventContext
	AlterFunction() IAlterFunctionContext
	AlterInstance() IAlterInstanceContext
	AlterLogfileGroup() IAlterLogfileGroupContext
	AlterProcedure() IAlterProcedureContext
	AlterServer() IAlterServerContext
	AlterTable() IAlterTableContext
	AlterTablespace() IAlterTablespaceContext
	AlterView() IAlterViewContext
	AlterSequence() IAlterSequenceContext
	DropDatabase() IDropDatabaseContext
	DropEvent() IDropEventContext
	DropIndex() IDropIndexContext
	DropLogfileGroup() IDropLogfileGroupContext
	DropProcedure() IDropProcedureContext
	DropFunction() IDropFunctionContext
	DropServer() IDropServerContext
	DropTable() IDropTableContext
	DropTablespace() IDropTablespaceContext
	DropTrigger() IDropTriggerContext
	DropView() IDropViewContext
	DropRole() IDropRoleContext
	DropSequence() IDropSequenceContext
	SetRole() ISetRoleContext
	RenameTable() IRenameTableContext
	TruncateTable() ITruncateTableContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *DdlStatementContext) CreateEvent() ICreateEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateEventContext)
}

func (s *DdlStatementContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *DdlStatementContext) CreateLogfileGroup() ICreateLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateLogfileGroupContext)
}

func (s *DdlStatementContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *DdlStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *DdlStatementContext) CreateServer() ICreateServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServerContext)
}

func (s *DdlStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *DdlStatementContext) CreateTablespaceInnodb() ICreateTablespaceInnodbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceInnodbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceInnodbContext)
}

func (s *DdlStatementContext) CreateTablespaceNdb() ICreateTablespaceNdbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceNdbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceNdbContext)
}

func (s *DdlStatementContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *DdlStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *DdlStatementContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *DdlStatementContext) CreateSequence() ICreateSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSequenceContext)
}

func (s *DdlStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *DdlStatementContext) AlterEvent() IAlterEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterEventContext)
}

func (s *DdlStatementContext) AlterFunction() IAlterFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterFunctionContext)
}

func (s *DdlStatementContext) AlterInstance() IAlterInstanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterInstanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterInstanceContext)
}

func (s *DdlStatementContext) AlterLogfileGroup() IAlterLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupContext)
}

func (s *DdlStatementContext) AlterProcedure() IAlterProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterProcedureContext)
}

func (s *DdlStatementContext) AlterServer() IAlterServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServerContext)
}

func (s *DdlStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *DdlStatementContext) AlterTablespace() IAlterTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceContext)
}

func (s *DdlStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *DdlStatementContext) AlterSequence() IAlterSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSequenceContext)
}

func (s *DdlStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DdlStatementContext) DropEvent() IDropEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropEventContext)
}

func (s *DdlStatementContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *DdlStatementContext) DropLogfileGroup() IDropLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupContext)
}

func (s *DdlStatementContext) DropProcedure() IDropProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *DdlStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DdlStatementContext) DropServer() IDropServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServerContext)
}

func (s *DdlStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DdlStatementContext) DropTablespace() IDropTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTablespaceContext)
}

func (s *DdlStatementContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *DdlStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DdlStatementContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *DdlStatementContext) DropSequence() IDropSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSequenceContext)
}

func (s *DdlStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *DdlStatementContext) RenameTable() IRenameTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableContext)
}

func (s *DdlStatementContext) TruncateTable() ITruncateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (s *DdlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDdlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MariaDBParserRULE_ddlStatement)
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.CreateDatabase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(785)
			p.CreateEvent()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(786)
			p.CreateIndex()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(787)
			p.CreateLogfileGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(788)
			p.CreateProcedure()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(789)
			p.CreateFunction()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(790)
			p.CreateServer()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(791)
			p.CreateTable()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(792)
			p.CreateTablespaceInnodb()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(793)
			p.CreateTablespaceNdb()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(794)
			p.CreateTrigger()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(795)
			p.CreateView()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(796)
			p.CreateRole()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(797)
			p.CreateSequence()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(798)
			p.AlterDatabase()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(799)
			p.AlterEvent()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(800)
			p.AlterFunction()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(801)
			p.AlterInstance()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(802)
			p.AlterLogfileGroup()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(803)
			p.AlterProcedure()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(804)
			p.AlterServer()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(805)
			p.AlterTable()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(806)
			p.AlterTablespace()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(807)
			p.AlterView()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(808)
			p.AlterSequence()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(809)
			p.DropDatabase()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(810)
			p.DropEvent()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(811)
			p.DropIndex()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(812)
			p.DropLogfileGroup()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(813)
			p.DropProcedure()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(814)
			p.DropFunction()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(815)
			p.DropServer()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(816)
			p.DropTable()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(817)
			p.DropTablespace()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(818)
			p.DropTrigger()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(819)
			p.DropView()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(820)
			p.DropRole()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(821)
			p.DropSequence()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(822)
			p.SetRole()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(823)
			p.RenameTable()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(824)
			p.TruncateTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	ReplaceStatement() IReplaceStatementContext
	CallStatement() ICallStatementContext
	LoadDataStatement() ILoadDataStatementContext
	LoadXmlStatement() ILoadXmlStatementContext
	DoStatement() IDoStatementContext
	HandlerStatement() IHandlerStatementContext
	ValuesStatement() IValuesStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dmlStatement
	return p
}

func InitEmptyDmlStatementContext(p *DmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dmlStatement
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DmlStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DmlStatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *DmlStatementContext) LoadDataStatement() ILoadDataStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataStatementContext)
}

func (s *DmlStatementContext) LoadXmlStatement() ILoadXmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadXmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadXmlStatementContext)
}

func (s *DmlStatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *DmlStatementContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *DmlStatementContext) ValuesStatement() IValuesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DmlStatement() (localctx IDmlStatementContext) {
	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MariaDBParserRULE_dmlStatement)
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(827)
			p.SelectStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(828)
			p.InsertStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(829)
			p.UpdateStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(830)
			p.DeleteStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(831)
			p.ReplaceStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(832)
			p.CallStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(833)
			p.LoadDataStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(834)
			p.LoadXmlStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(835)
			p.DoStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(836)
			p.HandlerStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(837)
			p.ValuesStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransaction() IStartTransactionContext
	BeginWork() IBeginWorkContext
	CommitWork() ICommitWorkContext
	RollbackWork() IRollbackWorkContext
	SavepointStatement() ISavepointStatementContext
	RollbackStatement() IRollbackStatementContext
	ReleaseStatement() IReleaseStatementContext
	LockTables() ILockTablesContext
	UnlockTables() IUnlockTablesContext

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionStatement
	return p
}

func InitEmptyTransactionStatementContext(p *TransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionStatement
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) StartTransaction() IStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionContext)
}

func (s *TransactionStatementContext) BeginWork() IBeginWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginWorkContext)
}

func (s *TransactionStatementContext) CommitWork() ICommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitWorkContext)
}

func (s *TransactionStatementContext) RollbackWork() IRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackWorkContext)
}

func (s *TransactionStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionStatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *TransactionStatementContext) ReleaseStatement() IReleaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReleaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *TransactionStatementContext) LockTables() ILockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTablesContext)
}

func (s *TransactionStatementContext) UnlockTables() IUnlockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockTablesContext)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TransactionStatement() (localctx ITransactionStatementContext) {
	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MariaDBParserRULE_transactionStatement)
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(840)
			p.StartTransaction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.BeginWork()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(842)
			p.CommitWork()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(843)
			p.RollbackWork()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(844)
			p.SavepointStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(845)
			p.RollbackStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(846)
			p.ReleaseStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(847)
			p.LockTables()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(848)
			p.UnlockTables()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ChangeMaster() IChangeMasterContext
	ChangeReplicationFilter() IChangeReplicationFilterContext
	PurgeBinaryLogs() IPurgeBinaryLogsContext
	ResetMaster() IResetMasterContext
	ResetSlave() IResetSlaveContext
	StartSlave() IStartSlaveContext
	StopSlave() IStopSlaveContext
	StartGroupReplication() IStartGroupReplicationContext
	StopGroupReplication() IStopGroupReplicationContext
	XaStartTransaction() IXaStartTransactionContext
	XaEndTransaction() IXaEndTransactionContext
	XaPrepareStatement() IXaPrepareStatementContext
	XaCommitWork() IXaCommitWorkContext
	XaRollbackWork() IXaRollbackWorkContext
	XaRecoverWork() IXaRecoverWorkContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replicationStatement
	return p
}

func InitEmptyReplicationStatementContext(p *ReplicationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replicationStatement
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) ChangeReplicationFilter() IChangeReplicationFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationFilterContext)
}

func (s *ReplicationStatementContext) PurgeBinaryLogs() IPurgeBinaryLogsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurgeBinaryLogsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurgeBinaryLogsContext)
}

func (s *ReplicationStatementContext) ResetMaster() IResetMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetMasterContext)
}

func (s *ReplicationStatementContext) ResetSlave() IResetSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetSlaveContext)
}

func (s *ReplicationStatementContext) StartSlave() IStartSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartSlaveContext)
}

func (s *ReplicationStatementContext) StopSlave() IStopSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopSlaveContext)
}

func (s *ReplicationStatementContext) StartGroupReplication() IStartGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartGroupReplicationContext)
}

func (s *ReplicationStatementContext) StopGroupReplication() IStopGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopGroupReplicationContext)
}

func (s *ReplicationStatementContext) XaStartTransaction() IXaStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStartTransactionContext)
}

func (s *ReplicationStatementContext) XaEndTransaction() IXaEndTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaEndTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaEndTransactionContext)
}

func (s *ReplicationStatementContext) XaPrepareStatement() IXaPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaPrepareStatementContext)
}

func (s *ReplicationStatementContext) XaCommitWork() IXaCommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaCommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaCommitWorkContext)
}

func (s *ReplicationStatementContext) XaRollbackWork() IXaRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRollbackWorkContext)
}

func (s *ReplicationStatementContext) XaRecoverWork() IXaRecoverWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRecoverWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRecoverWorkContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReplicationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MariaDBParserRULE_replicationStatement)
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(851)
			p.ChangeMaster()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(852)
			p.ChangeReplicationFilter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(853)
			p.PurgeBinaryLogs()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(854)
			p.ResetMaster()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(855)
			p.ResetSlave()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(856)
			p.StartSlave()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(857)
			p.StopSlave()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(858)
			p.StartGroupReplication()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(859)
			p.StopGroupReplication()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(860)
			p.XaStartTransaction()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(861)
			p.XaEndTransaction()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(862)
			p.XaPrepareStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(863)
			p.XaCommitWork()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(864)
			p.XaRollbackWork()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(865)
			p.XaRecoverWork()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocatePrepare() IDeallocatePrepareContext

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_preparedStatement
	return p
}

func InitEmptyPreparedStatementContext(p *PreparedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_preparedStatement
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DeallocatePrepare() IDeallocatePrepareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocatePrepareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocatePrepareContext)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPreparedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PreparedStatement() (localctx IPreparedStatementContext) {
	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MariaDBParserRULE_preparedStatement)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserPREPARE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.PrepareStatement()
		}

	case MariaDBParserEXECUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.ExecuteStatement()
		}

	case MariaDBParserDROP, MariaDBParserDEALLOCATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(870)
			p.DeallocatePrepare()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	CaseStatement() ICaseStatementContext
	IfStatement() IIfStatementContext
	LeaveStatement() ILeaveStatementContext
	LoopStatement() ILoopStatementContext
	RepeatStatement() IRepeatStatementContext
	WhileStatement() IWhileStatementContext
	IterateStatement() IIterateStatementContext
	ReturnStatement() IReturnStatementContext
	CursorStatement() ICursorStatementContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *CompoundStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) CursorStatement() ICursorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MariaDBParserRULE_compoundStatement)
	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.CaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(875)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(876)
			p.LeaveStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(877)
			p.LoopStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(878)
			p.RepeatStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(879)
			p.WhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(880)
			p.IterateStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(881)
			p.ReturnStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(882)
			p.CursorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdministrationStatementContext is an interface to support dynamic dispatch.
type IAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	GrantStatement() IGrantStatementContext
	GrantProxy() IGrantProxyContext
	RenameUser() IRenameUserContext
	RevokeStatement() IRevokeStatementContext
	RevokeProxy() IRevokeProxyContext
	AnalyzeTable() IAnalyzeTableContext
	CheckTable() ICheckTableContext
	ChecksumTable() IChecksumTableContext
	OptimizeTable() IOptimizeTableContext
	RepairTable() IRepairTableContext
	CreateUdfunction() ICreateUdfunctionContext
	InstallPlugin() IInstallPluginContext
	UninstallPlugin() IUninstallPluginContext
	SetStatement() ISetStatementContext
	ShowStatement() IShowStatementContext
	BinlogStatement() IBinlogStatementContext
	CacheIndexStatement() ICacheIndexStatementContext
	FlushStatement() IFlushStatementContext
	KillStatement() IKillStatementContext
	LoadIndexIntoCache() ILoadIndexIntoCacheContext
	ResetStatement() IResetStatementContext
	ShutdownStatement() IShutdownStatementContext
	ExplainStatement() IExplainStatementContext

	// IsAdministrationStatementContext differentiates from other interfaces.
	IsAdministrationStatementContext()
}

type AdministrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdministrationStatementContext() *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_administrationStatement
	return p
}

func InitEmptyAdministrationStatementContext(p *AdministrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_administrationStatement
}

func (*AdministrationStatementContext) IsAdministrationStatementContext() {}

func NewAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_administrationStatement

	return p
}

func (s *AdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdministrationStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AdministrationStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AdministrationStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AdministrationStatementContext) GrantStatement() IGrantStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantStatementContext)
}

func (s *AdministrationStatementContext) GrantProxy() IGrantProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantProxyContext)
}

func (s *AdministrationStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AdministrationStatementContext) RevokeStatement() IRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeStatementContext)
}

func (s *AdministrationStatementContext) RevokeProxy() IRevokeProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeProxyContext)
}

func (s *AdministrationStatementContext) AnalyzeTable() IAnalyzeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeTableContext)
}

func (s *AdministrationStatementContext) CheckTable() ICheckTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableContext)
}

func (s *AdministrationStatementContext) ChecksumTable() IChecksumTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChecksumTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChecksumTableContext)
}

func (s *AdministrationStatementContext) OptimizeTable() IOptimizeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeTableContext)
}

func (s *AdministrationStatementContext) RepairTable() IRepairTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTableContext)
}

func (s *AdministrationStatementContext) CreateUdfunction() ICreateUdfunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfunctionContext)
}

func (s *AdministrationStatementContext) InstallPlugin() IInstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginContext)
}

func (s *AdministrationStatementContext) UninstallPlugin() IUninstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginContext)
}

func (s *AdministrationStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *AdministrationStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *AdministrationStatementContext) BinlogStatement() IBinlogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinlogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinlogStatementContext)
}

func (s *AdministrationStatementContext) CacheIndexStatement() ICacheIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheIndexStatementContext)
}

func (s *AdministrationStatementContext) FlushStatement() IFlushStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushStatementContext)
}

func (s *AdministrationStatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *AdministrationStatementContext) LoadIndexIntoCache() ILoadIndexIntoCacheContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadIndexIntoCacheContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadIndexIntoCacheContext)
}

func (s *AdministrationStatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *AdministrationStatementContext) ShutdownStatement() IShutdownStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShutdownStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShutdownStatementContext)
}

func (s *AdministrationStatementContext) ExplainStatement() IExplainStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainStatementContext)
}

func (s *AdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAdministrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AdministrationStatement() (localctx IAdministrationStatementContext) {
	localctx = NewAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MariaDBParserRULE_administrationStatement)
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(885)
			p.AlterUser()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(886)
			p.CreateUser()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(887)
			p.DropUser()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(888)
			p.GrantStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(889)
			p.GrantProxy()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(890)
			p.RenameUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(891)
			p.RevokeStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(892)
			p.RevokeProxy()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(893)
			p.AnalyzeTable()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(894)
			p.CheckTable()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(895)
			p.ChecksumTable()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(896)
			p.OptimizeTable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(897)
			p.RepairTable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(898)
			p.CreateUdfunction()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(899)
			p.InstallPlugin()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(900)
			p.UninstallPlugin()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(901)
			p.SetStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(902)
			p.ShowStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(903)
			p.BinlogStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(904)
			p.CacheIndexStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(905)
			p.FlushStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(906)
			p.KillStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(907)
			p.LoadIndexIntoCache()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(908)
			p.ResetStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(909)
			p.ShutdownStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(910)
			p.ExplainStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUtilityStatementContext is an interface to support dynamic dispatch.
type IUtilityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleDescribeStatement() ISimpleDescribeStatementContext
	FullDescribeStatement() IFullDescribeStatementContext
	HelpStatement() IHelpStatementContext
	UseStatement() IUseStatementContext
	SignalStatement() ISignalStatementContext
	ResignalStatement() IResignalStatementContext
	DiagnosticsStatement() IDiagnosticsStatementContext

	// IsUtilityStatementContext differentiates from other interfaces.
	IsUtilityStatementContext()
}

type UtilityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtilityStatementContext() *UtilityStatementContext {
	var p = new(UtilityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_utilityStatement
	return p
}

func InitEmptyUtilityStatementContext(p *UtilityStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_utilityStatement
}

func (*UtilityStatementContext) IsUtilityStatementContext() {}

func NewUtilityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtilityStatementContext {
	var p = new(UtilityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_utilityStatement

	return p
}

func (s *UtilityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UtilityStatementContext) SimpleDescribeStatement() ISimpleDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDescribeStatementContext)
}

func (s *UtilityStatementContext) FullDescribeStatement() IFullDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullDescribeStatementContext)
}

func (s *UtilityStatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *UtilityStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *UtilityStatementContext) SignalStatement() ISignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStatementContext)
}

func (s *UtilityStatementContext) ResignalStatement() IResignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignalStatementContext)
}

func (s *UtilityStatementContext) DiagnosticsStatement() IDiagnosticsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsStatementContext)
}

func (s *UtilityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtilityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UtilityStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUtilityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UtilityStatement() (localctx IUtilityStatementContext) {
	localctx = NewUtilityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MariaDBParserRULE_utilityStatement)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(913)
			p.SimpleDescribeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(914)
			p.FullDescribeStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(915)
			p.HelpStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(916)
			p.UseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(917)
			p.SignalStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(918)
			p.ResignalStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(919)
			p.DiagnosticsStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDatabase
	return p
}

func InitEmptyCreateDatabaseContext(p *CreateDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDatabase
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *CreateDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MariaDBParserRULE_createDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(923)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDATABASE || _la == MariaDBParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(924)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(927)
		p.Uid()
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796428566528) != 0) || _la == MariaDBParserREAD || _la == MariaDBParserCHAR || _la == MariaDBParserENCRYPTION || _la == MariaDBParserCHARSET {
		{
			p.SetState(928)
			p.CreateDatabaseOption()
		}

		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateEventContext is an interface to support dynamic dispatch.
type ICreateEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	IfNotExists() IIfNotExistsContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsCreateEventContext differentiates from other interfaces.
	IsCreateEventContext()
}

type CreateEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateEventContext() *CreateEventContext {
	var p = new(CreateEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createEvent
	return p
}

func InitEmptyCreateEventContext(p *CreateEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createEvent
}

func (*CreateEventContext) IsCreateEventContext() {}

func NewCreateEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateEventContext {
	var p = new(CreateEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createEvent

	return p
}

func (s *CreateEventContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateEventContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *CreateEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserON)
}

func (s *CreateEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, i)
}

func (s *CreateEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEDULE, 0)
}

func (s *CreateEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *CreateEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDO, 0)
}

func (s *CreateEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateEventContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPLETION, 0)
}

func (s *CreateEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRESERVE, 0)
}

func (s *CreateEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *CreateEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *CreateEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *CreateEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateEvent(s)
	}
}

func (s *CreateEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateEvent(s)
	}
}

func (s *CreateEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateEvent() (localctx ICreateEventContext) {
	localctx = NewCreateEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MariaDBParserRULE_createEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(935)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(938)
		p.Match(MariaDBParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(939)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(942)
		p.FullId()
	}
	{
		p.SetState(943)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(944)
		p.Match(MariaDBParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(945)
		p.ScheduleExpression()
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserON {
		{
			p.SetState(946)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(947)
			p.Match(MariaDBParserCOMPLETION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNOT {
			{
				p.SetState(948)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(951)
			p.Match(MariaDBParserPRESERVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDISABLE || _la == MariaDBParserENABLE {
		{
			p.SetState(954)
			p.EnableType()
		}

	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMENT {
		{
			p.SetState(957)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(958)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(961)
		p.Match(MariaDBParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(962)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetIndexCategory returns the indexCategory token.
	GetIndexCategory() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetIndexCategory sets the indexCategory token.
	SetIndexCategory(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	OrReplace() IOrReplaceContext
	IfNotExists() IIfNotExistsContext
	IndexType() IIndexTypeContext
	WaitNowaitClause() IWaitNowaitClauseContext
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	FULLTEXT() antlr.TerminalNode
	SPATIAL() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNOCOPY() []antlr.TerminalNode
	NOCOPY(i int) antlr.TerminalNode
	AllINSTANT() []antlr.TerminalNode
	INSTANT(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	intimeAction  antlr.Token
	indexCategory antlr.Token
	algType       antlr.Token
	lockType      antlr.Token
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *CreateIndexContext) GetIndexCategory() antlr.Token { return s.indexCategory }

func (s *CreateIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *CreateIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *CreateIndexContext) SetIndexCategory(v antlr.Token) { s.indexCategory = v }

func (s *CreateIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *CreateIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *CreateIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *CreateIndexContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateIndexContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *CreateIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *CreateIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserALGORITHM)
}

func (s *CreateIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, i)
}

func (s *CreateIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLOCK)
}

func (s *CreateIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, i)
}

func (s *CreateIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLINE, 0)
}

func (s *CreateIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFLINE, 0)
}

func (s *CreateIndexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNIQUE, 0)
}

func (s *CreateIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULLTEXT, 0)
}

func (s *CreateIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSPATIAL, 0)
}

func (s *CreateIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserDEFAULT)
}

func (s *CreateIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, i)
}

func (s *CreateIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserINPLACE)
}

func (s *CreateIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserINPLACE, i)
}

func (s *CreateIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOPY)
}

func (s *CreateIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOPY, i)
}

func (s *CreateIndexContext) AllNOCOPY() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNOCOPY)
}

func (s *CreateIndexContext) NOCOPY(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCOPY, i)
}

func (s *CreateIndexContext) AllINSTANT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserINSTANT)
}

func (s *CreateIndexContext) INSTANT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTANT, i)
}

func (s *CreateIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNONE)
}

func (s *CreateIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, i)
}

func (s *CreateIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSHARED)
}

func (s *CreateIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARED, i)
}

func (s *CreateIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEXCLUSIVE)
}

func (s *CreateIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLUSIVE, i)
}

func (s *CreateIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *CreateIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MariaDBParserRULE_createIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(965)
			p.OrReplace()
		}

	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOFFLINE || _la == MariaDBParserONLINE {
		{
			p.SetState(968)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserOFFLINE || _la == MariaDBParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFULLTEXT || _la == MariaDBParserSPATIAL || _la == MariaDBParserUNIQUE {
		{
			p.SetState(971)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).indexCategory = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFULLTEXT || _la == MariaDBParserSPATIAL || _la == MariaDBParserUNIQUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).indexCategory = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(974)
		p.Match(MariaDBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(975)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(978)
		p.Uid()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserUSING {
		{
			p.SetState(979)
			p.IndexType()
		}

	}
	{
		p.SetState(982)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(983)
		p.TableName()
	}
	{
		p.SetState(984)
		p.IndexColumnNames()
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(985)
			p.WaitNowaitClause()
		}

	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
		{
			p.SetState(988)
			p.IndexOption()
		}

		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1004)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserALGORITHM:
				{
					p.SetState(994)
					p.Match(MariaDBParserALGORITHM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(996)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserEQUAL_SYMBOL {
					{
						p.SetState(995)
						p.Match(MariaDBParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(998)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserCOPY || _la == MariaDBParserINPLACE || _la == MariaDBParserINSTANT || _la == MariaDBParserNOCOPY) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MariaDBParserLOCK:
				{
					p.SetState(999)
					p.Match(MariaDBParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1001)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserEQUAL_SYMBOL {
					{
						p.SetState(1000)
						p.Match(MariaDBParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1003)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserEXCLUSIVE || _la == MariaDBParserNONE || _la == MariaDBParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateLogfileGroupContext is an interface to support dynamic dispatch.
type ICreateLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUndoFile returns the undoFile token.
	GetUndoFile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetUndoFile sets the undoFile token.
	SetUndoFile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetInitSize returns the initSize rule contexts.
	GetInitSize() IFileSizeLiteralContext

	// GetUndoSize returns the undoSize rule contexts.
	GetUndoSize() IFileSizeLiteralContext

	// GetRedoSize returns the redoSize rule contexts.
	GetRedoSize() IFileSizeLiteralContext

	// SetInitSize sets the initSize rule contexts.
	SetInitSize(IFileSizeLiteralContext)

	// SetUndoSize sets the undoSize rule contexts.
	SetUndoSize(IFileSizeLiteralContext)

	// SetRedoSize sets the redoSize rule contexts.
	SetRedoSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateLogfileGroupContext differentiates from other interfaces.
	IsCreateLogfileGroupContext()
}

type CreateLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	undoFile antlr.Token
	initSize IFileSizeLiteralContext
	undoSize IFileSizeLiteralContext
	redoSize IFileSizeLiteralContext
	comment  antlr.Token
}

func NewEmptyCreateLogfileGroupContext() *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createLogfileGroup
	return p
}

func InitEmptyCreateLogfileGroupContext(p *CreateLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createLogfileGroup
}

func (*CreateLogfileGroupContext) IsCreateLogfileGroupContext() {}

func NewCreateLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createLogfileGroup

	return p
}

func (s *CreateLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLogfileGroupContext) GetUndoFile() antlr.Token { return s.undoFile }

func (s *CreateLogfileGroupContext) GetComment() antlr.Token { return s.comment }

func (s *CreateLogfileGroupContext) SetUndoFile(v antlr.Token) { s.undoFile = v }

func (s *CreateLogfileGroupContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateLogfileGroupContext) GetInitSize() IFileSizeLiteralContext { return s.initSize }

func (s *CreateLogfileGroupContext) GetUndoSize() IFileSizeLiteralContext { return s.undoSize }

func (s *CreateLogfileGroupContext) GetRedoSize() IFileSizeLiteralContext { return s.redoSize }

func (s *CreateLogfileGroupContext) SetInitSize(v IFileSizeLiteralContext) { s.initSize = v }

func (s *CreateLogfileGroupContext) SetUndoSize(v IFileSizeLiteralContext) { s.undoSize = v }

func (s *CreateLogfileGroupContext) SetRedoSize(v IFileSizeLiteralContext) { s.redoSize = v }

func (s *CreateLogfileGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGFILE, 0)
}

func (s *CreateLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *CreateLogfileGroupContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *CreateLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDOFILE, 0)
}

func (s *CreateLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *CreateLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateLogfileGroupContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *CreateLogfileGroupContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *CreateLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINITIAL_SIZE, 0)
}

func (s *CreateLogfileGroupContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNODEGROUP, 0)
}

func (s *CreateLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *CreateLogfileGroupContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *CreateLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *CreateLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *CreateLogfileGroupContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateLogfileGroup() (localctx ICreateLogfileGroupContext) {
	localctx = NewCreateLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MariaDBParserRULE_createLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1010)
		p.Match(MariaDBParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1011)
		p.Match(MariaDBParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1012)
		p.Uid()
	}
	{
		p.SetState(1013)
		p.Match(MariaDBParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1014)
		p.Match(MariaDBParserUNDOFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1015)

		var _m = p.Match(MariaDBParserSTRING_LITERAL)

		localctx.(*CreateLogfileGroupContext).undoFile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINITIAL_SIZE {
		{
			p.SetState(1016)
			p.Match(MariaDBParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1017)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1020)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).initSize = _x
		}

	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserUNDO_BUFFER_SIZE {
		{
			p.SetState(1023)
			p.Match(MariaDBParserUNDO_BUFFER_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1024)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1027)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).undoSize = _x
		}

	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserREDO_BUFFER_SIZE {
		{
			p.SetState(1030)
			p.Match(MariaDBParserREDO_BUFFER_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1031)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1034)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).redoSize = _x
		}

	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNODEGROUP {
		{
			p.SetState(1037)
			p.Match(MariaDBParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1038)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1041)
			p.Uid()
		}

	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWAIT {
		{
			p.SetState(1044)
			p.Match(MariaDBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMENT {
		{
			p.SetState(1047)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1048)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1051)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*CreateLogfileGroupContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1054)
		p.Match(MariaDBParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEQUAL_SYMBOL {
		{
			p.SetState(1055)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1058)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OrReplace() IOrReplaceContext
	OwnerStatement() IOwnerStatementContext
	AllProcedureParameter() []IProcedureParameterContext
	ProcedureParameter(i int) IProcedureParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createProcedure
	return p
}

func InitEmptyCreateProcedureContext(p *CreateProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createProcedure
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateProcedureContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CreateProcedureContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CreateProcedureContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateProcedureContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateProcedureContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateProcedureContext) AllProcedureParameter() []IProcedureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureParameterContext); ok {
			tst[i] = t.(IProcedureParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) ProcedureParameter(i int) IProcedureParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureParameterContext)
}

func (s *CreateProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateProcedure() (localctx ICreateProcedureContext) {
	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MariaDBParserRULE_createProcedure)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(1061)
			p.OrReplace()
		}

	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(1064)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1067)
		p.Match(MariaDBParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1068)
		p.FullId()
	}
	{
		p.SetState(1069)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&439400445314603217) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(1070)
			p.ProcedureParameter()
		}

	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(1073)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.ProcedureParameter()
		}

		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1080)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1081)
				p.RoutineOption()
			}

		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	DataType() IDataTypeContext
	RoutineBody() IRoutineBodyContext
	ReturnStatement() IReturnStatementContext
	OrReplace() IOrReplaceContext
	OwnerStatement() IOwnerStatementContext
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *CreateFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CreateFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNS, 0)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CreateFunctionContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAGGREGATE, 0)
}

func (s *CreateFunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *CreateFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MariaDBParserRULE_createFunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(1090)
			p.OrReplace()
		}

	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(1093)
			p.OwnerStatement()
		}

	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserAGGREGATE {
		{
			p.SetState(1096)
			p.Match(MariaDBParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1099)
		p.Match(MariaDBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1100)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1103)
		p.FullId()
	}
	{
		p.SetState(1104)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(1105)
			p.FunctionParameter()
		}

	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(1108)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1109)
			p.FunctionParameter()
		}

		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1115)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1116)
		p.Match(MariaDBParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1117)
		p.DataType()
	}
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1118)
				p.RoutineOption()
			}

		}
		p.SetState(1123)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCONDITION, MariaDBParserCREATE, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDIAGNOSTICS, MariaDBParserDROP, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIMIZE, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserLR_BRACKET, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		{
			p.SetState(1124)
			p.RoutineBody()
		}

	case MariaDBParserRETURN:
		{
			p.SetState(1125)
			p.ReturnStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfNotExists() IIfNotExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *CreateRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MariaDBParserRULE_createRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1129)
		p.Match(MariaDBParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1130)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1133)
		p.RoleName()
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(1134)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.RoleName()
		}

		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateServerContext is an interface to support dynamic dispatch.
type ICreateServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWrapperName returns the wrapperName token.
	GetWrapperName() antlr.Token

	// SetWrapperName sets the wrapperName token.
	SetWrapperName(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	FOREIGN() antlr.TerminalNode
	DATA() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateServerContext differentiates from other interfaces.
	IsCreateServerContext()
}

type CreateServerContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	wrapperName antlr.Token
}

func NewEmptyCreateServerContext() *CreateServerContext {
	var p = new(CreateServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createServer
	return p
}

func InitEmptyCreateServerContext(p *CreateServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createServer
}

func (*CreateServerContext) IsCreateServerContext() {}

func NewCreateServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServerContext {
	var p = new(CreateServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createServer

	return p
}

func (s *CreateServerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServerContext) GetWrapperName() antlr.Token { return s.wrapperName }

func (s *CreateServerContext) SetWrapperName(v antlr.Token) { s.wrapperName = v }

func (s *CreateServerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERVER, 0)
}

func (s *CreateServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateServerContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOREIGN, 0)
}

func (s *CreateServerContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *CreateServerContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWRAPPER, 0)
}

func (s *CreateServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONS, 0)
}

func (s *CreateServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CreateServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *CreateServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CreateServerContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL, 0)
}

func (s *CreateServerContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateServer(s)
	}
}

func (s *CreateServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateServer(s)
	}
}

func (s *CreateServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateServer() (localctx ICreateServerContext) {
	localctx = NewCreateServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MariaDBParserRULE_createServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1142)
		p.Match(MariaDBParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.Uid()
	}
	{
		p.SetState(1144)
		p.Match(MariaDBParserFOREIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1145)
		p.Match(MariaDBParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1146)
		p.Match(MariaDBParserWRAPPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1147)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateServerContext).wrapperName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserMYSQL || _la == MariaDBParserSTRING_LITERAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateServerContext).wrapperName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1148)
		p.Match(MariaDBParserOPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1149)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1150)
		p.ServerOption()
	}
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(1151)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1152)
			p.ServerOption()
		}

		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1158)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CopyAll(ctx *CreateTableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CopyCreateTableContext struct {
	CreateTableContext
	parenthesisTable ITableNameContext
}

func NewCopyCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyCreateTableContext {
	var p = new(CopyCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *CopyCreateTableContext) GetParenthesisTable() ITableNameContext { return s.parenthesisTable }

func (s *CopyCreateTableContext) SetParenthesisTable(v ITableNameContext) { s.parenthesisTable = v }

func (s *CopyCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CopyCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *CopyCreateTableContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *CopyCreateTableContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CopyCreateTableContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIKE, 0)
}

func (s *CopyCreateTableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CopyCreateTableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CopyCreateTableContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CopyCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *CopyCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CopyCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCopyCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnCreateTableContext struct {
	CreateTableContext
}

func NewColumnCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnCreateTableContext {
	var p = new(ColumnCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *ColumnCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *ColumnCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *ColumnCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *ColumnCreateTableContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *ColumnCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *ColumnCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ColumnCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *ColumnCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *ColumnCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ColumnCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ColumnCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitColumnCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryCreateTableContext struct {
	CreateTableContext
	keyViolate antlr.Token
}

func NewQueryCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryCreateTableContext {
	var p = new(QueryCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *QueryCreateTableContext) GetKeyViolate() antlr.Token { return s.keyViolate }

func (s *QueryCreateTableContext) SetKeyViolate(v antlr.Token) { s.keyViolate = v }

func (s *QueryCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *QueryCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *QueryCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *QueryCreateTableContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QueryCreateTableContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *QueryCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *QueryCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *QueryCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *QueryCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *QueryCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *QueryCreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *QueryCreateTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *QueryCreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *QueryCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *QueryCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *QueryCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitQueryCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MariaDBParserRULE_createTable)
	var _la int

	var _alt int

	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCopyCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1160)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserOR {
			{
				p.SetState(1161)
				p.OrReplace()
			}

		}
		p.SetState(1165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserTEMPORARY {
			{
				p.SetState(1164)
				p.Match(MariaDBParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1167)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1169)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1168)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1171)
			p.TableName()
		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserLIKE:
			{
				p.SetState(1172)
				p.Match(MariaDBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1173)
				p.TableName()
			}

		case MariaDBParserLR_BRACKET:
			{
				p.SetState(1174)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1175)
				p.Match(MariaDBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1176)

				var _x = p.TableName()

				localctx.(*CopyCreateTableContext).parenthesisTable = _x
			}
			{
				p.SetState(1177)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewQueryCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1181)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserOR {
			{
				p.SetState(1182)
				p.OrReplace()
			}

		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserTEMPORARY {
			{
				p.SetState(1185)
				p.Match(MariaDBParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1188)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1189)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1192)
			p.TableName()
		}
		p.SetState(1194)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1193)
				p.CreateDefinitions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&36028797019095045) != 0) || _la == MariaDBParserUNION || _la == MariaDBParserCHAR || ((int64((_la-341)) & ^0x3f) == 0 && ((int64(1)<<(_la-341))&-9218727660950028281) != 0) || ((int64((_la-405)) & ^0x3f) == 0 && ((int64(1)<<(_la-405))&4612811918334230547) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&2366149022974977) != 0) || ((int64((_la-604)) & ^0x3f) == 0 && ((int64(1)<<(_la-604))&9218347631640577) != 0) || _la == MariaDBParserCHARSET || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE || _la == MariaDBParserSTRING_LITERAL {
			{
				p.SetState(1196)
				p.TableOption()
			}
			p.SetState(1203)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&36028797019095045) != 0) || _la == MariaDBParserUNION || _la == MariaDBParserCHAR || ((int64((_la-341)) & ^0x3f) == 0 && ((int64(1)<<(_la-341))&-9218727660950028281) != 0) || ((int64((_la-405)) & ^0x3f) == 0 && ((int64(1)<<(_la-405))&4612811918334230547) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&2366149022974977) != 0) || ((int64((_la-604)) & ^0x3f) == 0 && ((int64(1)<<(_la-604))&9218347631640577) != 0) || _la == MariaDBParserCHARSET || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE || _la == MariaDBParserCOMMA || _la == MariaDBParserSTRING_LITERAL {
				p.SetState(1198)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserCOMMA {
					{
						p.SetState(1197)
						p.Match(MariaDBParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1200)
					p.TableOption()
				}

				p.SetState(1205)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPARTITION {
			{
				p.SetState(1208)
				p.PartitionDefinitions()
			}

		}
		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE {
			{
				p.SetState(1211)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*QueryCreateTableContext).keyViolate = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*QueryCreateTableContext).keyViolate = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(1214)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1217)
			p.SelectStatement()
		}

	case 3:
		localctx = NewColumnCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1219)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserOR {
			{
				p.SetState(1220)
				p.OrReplace()
			}

		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserTEMPORARY {
			{
				p.SetState(1223)
				p.Match(MariaDBParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1226)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1228)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1227)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1230)
			p.TableName()
		}
		{
			p.SetState(1231)
			p.CreateDefinitions()
		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1232)
				p.TableOption()
			}
			p.SetState(1239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(1234)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MariaDBParserCOMMA {
						{
							p.SetState(1233)
							p.Match(MariaDBParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(1236)
						p.TableOption()
					}

				}
				p.SetState(1241)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPARTITION {
			{
				p.SetState(1244)
				p.PartitionDefinitions()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTablespaceInnodbContext is an interface to support dynamic dispatch.
type ICreateTablespaceInnodbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// GetFileBlockSize returns the fileBlockSize rule contexts.
	GetFileBlockSize() IFileSizeLiteralContext

	// SetFileBlockSize sets the fileBlockSize rule contexts.
	SetFileBlockSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	FileSizeLiteral() IFileSizeLiteralContext

	// IsCreateTablespaceInnodbContext differentiates from other interfaces.
	IsCreateTablespaceInnodbContext()
}

type CreateTablespaceInnodbContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	datafile      antlr.Token
	fileBlockSize IFileSizeLiteralContext
}

func NewEmptyCreateTablespaceInnodbContext() *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTablespaceInnodb
	return p
}

func InitEmptyCreateTablespaceInnodbContext(p *CreateTablespaceInnodbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTablespaceInnodb
}

func (*CreateTablespaceInnodbContext) IsCreateTablespaceInnodbContext() {}

func NewCreateTablespaceInnodbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createTablespaceInnodb

	return p
}

func (s *CreateTablespaceInnodbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceInnodbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceInnodbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceInnodbContext) GetFileBlockSize() IFileSizeLiteralContext {
	return s.fileBlockSize
}

func (s *CreateTablespaceInnodbContext) SetFileBlockSize(v IFileSizeLiteralContext) {
	s.fileBlockSize = v
}

func (s *CreateTablespaceInnodbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateTablespaceInnodbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *CreateTablespaceInnodbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceInnodbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *CreateTablespaceInnodbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATAFILE, 0)
}

func (s *CreateTablespaceInnodbContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateTablespaceInnodbContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILE_BLOCK_SIZE, 0)
}

func (s *CreateTablespaceInnodbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceInnodbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceInnodbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *CreateTablespaceInnodbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceInnodbContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceInnodbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceInnodbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceInnodbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateTablespaceInnodb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateTablespaceInnodb() (localctx ICreateTablespaceInnodbContext) {
	localctx = NewCreateTablespaceInnodbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MariaDBParserRULE_createTablespaceInnodb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1249)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1250)
		p.Match(MariaDBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1251)
		p.Uid()
	}
	{
		p.SetState(1252)
		p.Match(MariaDBParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1253)
		p.Match(MariaDBParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1254)

		var _m = p.Match(MariaDBParserSTRING_LITERAL)

		localctx.(*CreateTablespaceInnodbContext).datafile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFILE_BLOCK_SIZE {
		{
			p.SetState(1255)
			p.Match(MariaDBParserFILE_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1256)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1257)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceInnodbContext).fileBlockSize = _x
		}

	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserENGINE {
		{
			p.SetState(1260)
			p.Match(MariaDBParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1261)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1264)
			p.EngineName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTablespaceNdbContext is an interface to support dynamic dispatch.
type ICreateTablespaceNdbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetExtentSize returns the extentSize rule contexts.
	GetExtentSize() IFileSizeLiteralContext

	// GetInitialSize returns the initialSize rule contexts.
	GetInitialSize() IFileSizeLiteralContext

	// GetAutoextendSize returns the autoextendSize rule contexts.
	GetAutoextendSize() IFileSizeLiteralContext

	// GetMaxSize returns the maxSize rule contexts.
	GetMaxSize() IFileSizeLiteralContext

	// SetExtentSize sets the extentSize rule contexts.
	SetExtentSize(IFileSizeLiteralContext)

	// SetInitialSize sets the initialSize rule contexts.
	SetInitialSize(IFileSizeLiteralContext)

	// SetAutoextendSize sets the autoextendSize rule contexts.
	SetAutoextendSize(IFileSizeLiteralContext)

	// SetMaxSize sets the maxSize rule contexts.
	SetMaxSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	USE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateTablespaceNdbContext differentiates from other interfaces.
	IsCreateTablespaceNdbContext()
}

type CreateTablespaceNdbContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	datafile       antlr.Token
	extentSize     IFileSizeLiteralContext
	initialSize    IFileSizeLiteralContext
	autoextendSize IFileSizeLiteralContext
	maxSize        IFileSizeLiteralContext
	comment        antlr.Token
}

func NewEmptyCreateTablespaceNdbContext() *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTablespaceNdb
	return p
}

func InitEmptyCreateTablespaceNdbContext(p *CreateTablespaceNdbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTablespaceNdb
}

func (*CreateTablespaceNdbContext) IsCreateTablespaceNdbContext() {}

func NewCreateTablespaceNdbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createTablespaceNdb

	return p
}

func (s *CreateTablespaceNdbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceNdbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceNdbContext) GetComment() antlr.Token { return s.comment }

func (s *CreateTablespaceNdbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceNdbContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateTablespaceNdbContext) GetExtentSize() IFileSizeLiteralContext { return s.extentSize }

func (s *CreateTablespaceNdbContext) GetInitialSize() IFileSizeLiteralContext { return s.initialSize }

func (s *CreateTablespaceNdbContext) GetAutoextendSize() IFileSizeLiteralContext {
	return s.autoextendSize
}

func (s *CreateTablespaceNdbContext) GetMaxSize() IFileSizeLiteralContext { return s.maxSize }

func (s *CreateTablespaceNdbContext) SetExtentSize(v IFileSizeLiteralContext) { s.extentSize = v }

func (s *CreateTablespaceNdbContext) SetInitialSize(v IFileSizeLiteralContext) { s.initialSize = v }

func (s *CreateTablespaceNdbContext) SetAutoextendSize(v IFileSizeLiteralContext) {
	s.autoextendSize = v
}

func (s *CreateTablespaceNdbContext) SetMaxSize(v IFileSizeLiteralContext) { s.maxSize = v }

func (s *CreateTablespaceNdbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateTablespaceNdbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *CreateTablespaceNdbContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceNdbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *CreateTablespaceNdbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATAFILE, 0)
}

func (s *CreateTablespaceNdbContext) USE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSE, 0)
}

func (s *CreateTablespaceNdbContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGFILE, 0)
}

func (s *CreateTablespaceNdbContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *CreateTablespaceNdbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *CreateTablespaceNdbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceNdbContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *CreateTablespaceNdbContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *CreateTablespaceNdbContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENT_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINITIAL_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTOEXTEND_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNODEGROUP, 0)
}

func (s *CreateTablespaceNdbContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *CreateTablespaceNdbContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *CreateTablespaceNdbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceNdbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceNdbContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceNdbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceNdbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceNdbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateTablespaceNdb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateTablespaceNdb() (localctx ICreateTablespaceNdbContext) {
	localctx = NewCreateTablespaceNdbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MariaDBParserRULE_createTablespaceNdb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1267)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1268)
		p.Match(MariaDBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1269)
		p.Uid()
	}
	{
		p.SetState(1270)
		p.Match(MariaDBParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1271)
		p.Match(MariaDBParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1272)

		var _m = p.Match(MariaDBParserSTRING_LITERAL)

		localctx.(*CreateTablespaceNdbContext).datafile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1273)
		p.Match(MariaDBParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1274)
		p.Match(MariaDBParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1275)
		p.Match(MariaDBParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1276)
		p.Uid()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEXTENT_SIZE {
		{
			p.SetState(1277)
			p.Match(MariaDBParserEXTENT_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1278)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1281)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).extentSize = _x
		}

	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINITIAL_SIZE {
		{
			p.SetState(1284)
			p.Match(MariaDBParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1285)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1288)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).initialSize = _x
		}

	}
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserAUTOEXTEND_SIZE {
		{
			p.SetState(1291)
			p.Match(MariaDBParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1292)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1295)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).autoextendSize = _x
		}

	}
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserMAX_SIZE {
		{
			p.SetState(1298)
			p.Match(MariaDBParserMAX_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1299)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1302)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).maxSize = _x
		}

	}
	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNODEGROUP {
		{
			p.SetState(1305)
			p.Match(MariaDBParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1306)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1309)
			p.Uid()
		}

	}
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWAIT {
		{
			p.SetState(1312)
			p.Match(MariaDBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMENT {
		{
			p.SetState(1315)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1316)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1319)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*CreateTablespaceNdbContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1322)
		p.Match(MariaDBParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEQUAL_SYMBOL {
		{
			p.SetState(1323)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1326)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTriggerTime returns the triggerTime token.
	GetTriggerTime() antlr.Token

	// GetTriggerEvent returns the triggerEvent token.
	GetTriggerEvent() antlr.Token

	// GetTriggerPlace returns the triggerPlace token.
	GetTriggerPlace() antlr.Token

	// SetTriggerTime sets the triggerTime token.
	SetTriggerTime(antlr.Token)

	// SetTriggerEvent sets the triggerEvent token.
	SetTriggerEvent(antlr.Token)

	// SetTriggerPlace sets the triggerPlace token.
	SetTriggerPlace(antlr.Token)

	// GetThisTrigger returns the thisTrigger rule contexts.
	GetThisTrigger() IFullIdContext

	// GetOtherTrigger returns the otherTrigger rule contexts.
	GetOtherTrigger() IFullIdContext

	// SetThisTrigger sets the thisTrigger rule contexts.
	SetThisTrigger(IFullIdContext)

	// SetOtherTrigger sets the otherTrigger rule contexts.
	SetOtherTrigger(IFullIdContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	FOR() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	OwnerStatement() IOwnerStatementContext
	FOLLOWS() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	thisTrigger  IFullIdContext
	triggerTime  antlr.Token
	triggerEvent antlr.Token
	triggerPlace antlr.Token
	otherTrigger IFullIdContext
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) GetTriggerTime() antlr.Token { return s.triggerTime }

func (s *CreateTriggerContext) GetTriggerEvent() antlr.Token { return s.triggerEvent }

func (s *CreateTriggerContext) GetTriggerPlace() antlr.Token { return s.triggerPlace }

func (s *CreateTriggerContext) SetTriggerTime(v antlr.Token) { s.triggerTime = v }

func (s *CreateTriggerContext) SetTriggerEvent(v antlr.Token) { s.triggerEvent = v }

func (s *CreateTriggerContext) SetTriggerPlace(v antlr.Token) { s.triggerPlace = v }

func (s *CreateTriggerContext) GetThisTrigger() IFullIdContext { return s.thisTrigger }

func (s *CreateTriggerContext) GetOtherTrigger() IFullIdContext { return s.otherTrigger }

func (s *CreateTriggerContext) SetThisTrigger(v IFullIdContext) { s.thisTrigger = v }

func (s *CreateTriggerContext) SetOtherTrigger(v IFullIdContext) { s.otherTrigger = v }

func (s *CreateTriggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGER, 0)
}

func (s *CreateTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *CreateTriggerContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTriggerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *CreateTriggerContext) EACH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEACH, 0)
}

func (s *CreateTriggerContext) ROW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW, 0)
}

func (s *CreateTriggerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *CreateTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateTriggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEFORE, 0)
}

func (s *CreateTriggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAFTER, 0)
}

func (s *CreateTriggerContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT, 0)
}

func (s *CreateTriggerContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *CreateTriggerContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELETE, 0)
}

func (s *CreateTriggerContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateTriggerContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateTriggerContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOLLOWS, 0)
}

func (s *CreateTriggerContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRECEDES, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MariaDBParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(1329)
			p.OrReplace()
		}

	}
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(1332)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1335)
		p.Match(MariaDBParserTRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1336)

		var _x = p.FullId()

		localctx.(*CreateTriggerContext).thisTrigger = _x
	}
	{
		p.SetState(1337)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerTime = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserBEFORE || _la == MariaDBParserAFTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerTime = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1338)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerEvent = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDELETE || _la == MariaDBParserINSERT || _la == MariaDBParserUPDATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerEvent = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1339)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1340)
		p.TableName()
	}
	{
		p.SetState(1341)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1342)
		p.Match(MariaDBParserEACH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1343)
		p.Match(MariaDBParserROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1344)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTriggerContext).triggerPlace = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFOLLOWS || _la == MariaDBParserPRECEDES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTriggerContext).triggerPlace = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1345)

			var _x = p.FullId()

			localctx.(*CreateTriggerContext).otherTrigger = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1348)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *WithClauseContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithClauseContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRECURSIVE, 0)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MariaDBParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1350)
		p.Match(MariaDBParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1351)
			p.Match(MariaDBParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1354)
		p.CommonTableExpressions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionsContext is an interface to support dynamic dispatch.
type ICommonTableExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CteName() ICteNameContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	DmlStatement() IDmlStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCteColumnName() []ICteColumnNameContext
	CteColumnName(i int) ICteColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext

	// IsCommonTableExpressionsContext differentiates from other interfaces.
	IsCommonTableExpressionsContext()
}

type CommonTableExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionsContext() *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_commonTableExpressions
	return p
}

func InitEmptyCommonTableExpressionsContext(p *CommonTableExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_commonTableExpressions
}

func (*CommonTableExpressionsContext) IsCommonTableExpressionsContext() {}

func NewCommonTableExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_commonTableExpressions

	return p
}

func (s *CommonTableExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionsContext) CteName() ICteNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteNameContext)
}

func (s *CommonTableExpressionsContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *CommonTableExpressionsContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *CommonTableExpressionsContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CommonTableExpressionsContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *CommonTableExpressionsContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) AllCteColumnName() []ICteColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			len++
		}
	}

	tst := make([]ICteColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteColumnNameContext); ok {
			tst[i] = t.(ICteColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *CommonTableExpressionsContext) CteColumnName(i int) ICteColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteColumnNameContext)
}

func (s *CommonTableExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CommonTableExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CommonTableExpressionsContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *CommonTableExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCommonTableExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CommonTableExpressions() (localctx ICommonTableExpressionsContext) {
	localctx = NewCommonTableExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MariaDBParserRULE_commonTableExpressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.CteName()
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLR_BRACKET {
		{
			p.SetState(1357)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1358)
			p.CteColumnName()
		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(1359)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1360)
				p.CteColumnName()
			}

			p.SetState(1365)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1366)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1370)
		p.Match(MariaDBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1371)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1372)
		p.DmlStatement()
	}
	{
		p.SetState(1373)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMA {
		{
			p.SetState(1374)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1375)
			p.CommonTableExpressions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteNameContext is an interface to support dynamic dispatch.
type ICteNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteNameContext differentiates from other interfaces.
	IsCteNameContext()
}

type CteNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteNameContext() *CteNameContext {
	var p = new(CteNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cteName
	return p
}

func InitEmptyCteNameContext(p *CteNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cteName
}

func (*CteNameContext) IsCteNameContext() {}

func NewCteNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteNameContext {
	var p = new(CteNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_cteName

	return p
}

func (s *CteNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCteName(s)
	}
}

func (s *CteNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCteName(s)
	}
}

func (s *CteNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCteName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CteName() (localctx ICteNameContext) {
	localctx = NewCteNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MariaDBParserRULE_cteName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteColumnNameContext is an interface to support dynamic dispatch.
type ICteColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteColumnNameContext differentiates from other interfaces.
	IsCteColumnNameContext()
}

type CteColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteColumnNameContext() *CteColumnNameContext {
	var p = new(CteColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cteColumnName
	return p
}

func InitEmptyCteColumnNameContext(p *CteColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cteColumnName
}

func (*CteColumnNameContext) IsCteColumnNameContext() {}

func NewCteColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteColumnNameContext {
	var p = new(CteColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_cteColumnName

	return p
}

func (s *CteColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCteColumnName(s)
	}
}

func (s *CteColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCteColumnName(s)
	}
}

func (s *CteColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCteColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CteColumnName() (localctx ICteColumnNameContext) {
	localctx = NewCteColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MariaDBParserRULE_cteColumnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1380)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOption returns the checkOption token.
	GetCheckOption() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOption sets the checkOption token.
	SetCheckOption(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	OrReplace() IOrReplaceContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	UidList() IUidListContext
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	WithClause() IWithClauseContext
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	algType     antlr.Token
	secContext  antlr.Token
	checkOption antlr.Token
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createView
	return p
}

func InitEmptyCreateViewContext(p *CreateViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createView
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *CreateViewContext) GetCheckOption() antlr.Token { return s.checkOption }

func (s *CreateViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *CreateViewContext) SetCheckOption(v antlr.Token) { s.checkOption = v }

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *CreateViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *CreateViewContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *CreateViewContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *CreateViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateViewContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *CreateViewContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *CreateViewContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *CreateViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *CreateViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECURITY, 0)
}

func (s *CreateViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CreateViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDEFINED, 0)
}

func (s *CreateViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMERGE, 0)
}

func (s *CreateViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPTABLE, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKER, 0)
}

func (s *CreateViewContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *CreateViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *CreateViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *CreateViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, 0)
}

func (s *CreateViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADED, 0)
}

func (s *CreateViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateView() (localctx ICreateViewContext) {
	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MariaDBParserRULE_createView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(1383)
			p.OrReplace()
		}

	}
	p.SetState(1389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserALGORITHM {
		{
			p.SetState(1386)
			p.Match(MariaDBParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1388)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserMERGE || _la == MariaDBParserTEMPTABLE || _la == MariaDBParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(1391)
			p.OwnerStatement()
		}

	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserSQL {
		{
			p.SetState(1394)
			p.Match(MariaDBParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1395)
			p.Match(MariaDBParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1396)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFINER || _la == MariaDBParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1399)
		p.Match(MariaDBParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.FullId()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLR_BRACKET {
		{
			p.SetState(1401)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.UidList()
		}
		{
			p.SetState(1403)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1407)
		p.Match(MariaDBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1408)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(1409)
				p.WithClause()
			}

		}
		{
			p.SetState(1412)
			p.SelectStatement()
		}
		{
			p.SetState(1413)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(1415)
				p.WithClause()
			}

		}
		{
			p.SetState(1418)
			p.SelectStatement()
		}
		p.SetState(1425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(1419)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserCASCADED || _la == MariaDBParserLOCAL {
				{
					p.SetState(1420)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateViewContext).checkOption = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserCASCADED || _la == MariaDBParserLOCAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateViewContext).checkOption = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1423)
				p.Match(MariaDBParserCHECK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1424)
				p.Match(MariaDBParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSequenceContext is an interface to support dynamic dispatch.
type ICreateSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	FullId() IFullIdContext
	OrReplace() IOrReplaceContext
	TEMPORARY() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllSequenceSpec() []ISequenceSpecContext
	SequenceSpec(i int) ISequenceSpecContext
	AllTableOption() []ITableOptionContext
	TableOption(i int) ITableOptionContext

	// IsCreateSequenceContext differentiates from other interfaces.
	IsCreateSequenceContext()
}

type CreateSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSequenceContext() *CreateSequenceContext {
	var p = new(CreateSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createSequence
	return p
}

func InitEmptyCreateSequenceContext(p *CreateSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createSequence
}

func (*CreateSequenceContext) IsCreateSequenceContext() {}

func NewCreateSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSequenceContext {
	var p = new(CreateSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createSequence

	return p
}

func (s *CreateSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSequenceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEQUENCE, 0)
}

func (s *CreateSequenceContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateSequenceContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateSequenceContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *CreateSequenceContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateSequenceContext) AllSequenceSpec() []ISequenceSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceSpecContext); ok {
			len++
		}
	}

	tst := make([]ISequenceSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceSpecContext); ok {
			tst[i] = t.(ISequenceSpecContext)
			i++
		}
	}

	return tst
}

func (s *CreateSequenceContext) SequenceSpec(i int) ISequenceSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceSpecContext)
}

func (s *CreateSequenceContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateSequenceContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *CreateSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateSequence(s)
	}
}

func (s *CreateSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateSequence(s)
	}
}

func (s *CreateSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateSequence() (localctx ICreateSequenceContext) {
	localctx = NewCreateSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MariaDBParserRULE_createSequence)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1429)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(1430)
			p.OrReplace()
		}

	}
	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserTEMPORARY {
		{
			p.SetState(1433)
			p.Match(MariaDBParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1436)
		p.Match(MariaDBParserSEQUENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1437)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1440)
		p.FullId()
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1443)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1441)
					p.SequenceSpec()
				}

			case 2:
				{
					p.SetState(1442)
					p.TableOption()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceSpecContext is an interface to support dynamic dispatch.
type ISequenceSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCREMENT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	BY() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	MINVALUE() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOMINVALUE() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NOMAXVALUE() antlr.TerminalNode
	START() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	NOCACHE() antlr.TerminalNode
	CYCLE() antlr.TerminalNode
	NOCYCLE() antlr.TerminalNode
	RESTART() antlr.TerminalNode

	// IsSequenceSpecContext differentiates from other interfaces.
	IsSequenceSpecContext()
}

type SequenceSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceSpecContext() *SequenceSpecContext {
	var p = new(SequenceSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sequenceSpec
	return p
}

func InitEmptySequenceSpecContext(p *SequenceSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_sequenceSpec
}

func (*SequenceSpecContext) IsSequenceSpecContext() {}

func NewSequenceSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceSpecContext {
	var p = new(SequenceSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_sequenceSpec

	return p
}

func (s *SequenceSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceSpecContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINCREMENT, 0)
}

func (s *SequenceSpecContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SequenceSpecContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *SequenceSpecContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *SequenceSpecContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINVALUE, 0)
}

func (s *SequenceSpecContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *SequenceSpecContext) NOMINVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOMINVALUE, 0)
}

func (s *SequenceSpecContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAXVALUE, 0)
}

func (s *SequenceSpecContext) NOMAXVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOMAXVALUE, 0)
}

func (s *SequenceSpecContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *SequenceSpecContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *SequenceSpecContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *SequenceSpecContext) NOCACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCACHE, 0)
}

func (s *SequenceSpecContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCYCLE, 0)
}

func (s *SequenceSpecContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCYCLE, 0)
}

func (s *SequenceSpecContext) RESTART() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTART, 0)
}

func (s *SequenceSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSequenceSpec(s)
	}
}

func (s *SequenceSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSequenceSpec(s)
	}
}

func (s *SequenceSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSequenceSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SequenceSpec() (localctx ISequenceSpecContext) {
	localctx = NewSequenceSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MariaDBParserRULE_sequenceSpec)
	var _la int

	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1448)
			p.Match(MariaDBParserINCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserBY || _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1449)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserBY || _la == MariaDBParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1452)
			p.DecimalLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1453)
			p.Match(MariaDBParserMINVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1454)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1457)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1458)
			p.Match(MariaDBParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Match(MariaDBParserMINVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1460)
			p.Match(MariaDBParserNOMINVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1461)
			p.Match(MariaDBParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1462)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1465)
			p.DecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1466)
			p.Match(MariaDBParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1467)
			p.Match(MariaDBParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1468)
			p.Match(MariaDBParserNOMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1469)
			p.Match(MariaDBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH || _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1470)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserWITH || _la == MariaDBParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1473)
			p.DecimalLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1474)
			p.Match(MariaDBParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1475)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1478)
			p.DecimalLiteral()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1479)
			p.Match(MariaDBParserNOCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1480)
			p.Match(MariaDBParserCYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1481)
			p.Match(MariaDBParserNOCYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1482)
			p.Match(MariaDBParserRESTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH || _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1483)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserWITH || _la == MariaDBParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1486)
			p.DecimalLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseOptionContext is an interface to support dynamic dispatch.
type ICreateDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext
	ENCRYPTION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsCreateDatabaseOptionContext differentiates from other interfaces.
	IsCreateDatabaseOptionContext()
}

type CreateDatabaseOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseOptionContext() *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDatabaseOption
	return p
}

func InitEmptyCreateDatabaseOptionContext(p *CreateDatabaseOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDatabaseOption
}

func (*CreateDatabaseOptionContext) IsCreateDatabaseOptionContext() {}

func NewCreateDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createDatabaseOption

	return p
}

func (s *CreateDatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseOptionContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CreateDatabaseOptionContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CreateDatabaseOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserDEFAULT)
}

func (s *CreateDatabaseOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, i)
}

func (s *CreateDatabaseOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *CreateDatabaseOptionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *CreateDatabaseOptionContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CreateDatabaseOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION, 0)
}

func (s *CreateDatabaseOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *CreateDatabaseOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLY, 0)
}

func (s *CreateDatabaseOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateDatabaseOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateDatabaseOption() (localctx ICreateDatabaseOptionContext) {
	localctx = NewCreateDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MariaDBParserRULE_createDatabaseOption)
	var _la int

	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(1489)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1492)
			p.CharSet()
		}
		p.SetState(1494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1493)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserBINARY, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL:
			{
				p.SetState(1496)
				p.CharsetName()
			}

		case MariaDBParserDEFAULT:
			{
				p.SetState(1497)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(1500)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1503)
			p.Match(MariaDBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1504)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1507)
			p.CollationName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(1508)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1511)
			p.Match(MariaDBParserENCRYPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1512)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1515)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1516)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)
			p.Match(MariaDBParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1518)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1521)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charSet
	return p
}

func InitEmptyCharSetContext(p *CharSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charSet
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (s *CharSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCharSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CharSet() (localctx ICharSetContext) {
	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MariaDBParserRULE_charSet)
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1524)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1526)
			p.Match(MariaDBParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1527)
			p.Match(MariaDBParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1528)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentUserExpressionContext is an interface to support dynamic dispatch.
type ICurrentUserExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_USER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsCurrentUserExpressionContext differentiates from other interfaces.
	IsCurrentUserExpressionContext()
}

type CurrentUserExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentUserExpressionContext() *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_currentUserExpression
	return p
}

func InitEmptyCurrentUserExpressionContext(p *CurrentUserExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_currentUserExpression
}

func (*CurrentUserExpressionContext) IsCurrentUserExpressionContext() {}

func NewCurrentUserExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_currentUserExpression

	return p
}

func (s *CurrentUserExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentUserExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_USER, 0)
}

func (s *CurrentUserExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentUserExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCurrentUserExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CurrentUserExpression() (localctx ICurrentUserExpressionContext) {
	localctx = NewCurrentUserExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MariaDBParserRULE_currentUserExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1531)
		p.Match(MariaDBParserCURRENT_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1532)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOwnerStatementContext is an interface to support dynamic dispatch.
type IOwnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	UserName() IUserNameContext
	CurrentUserExpression() ICurrentUserExpressionContext
	CURRENT_ROLE() antlr.TerminalNode

	// IsOwnerStatementContext differentiates from other interfaces.
	IsOwnerStatementContext()
}

type OwnerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerStatementContext() *OwnerStatementContext {
	var p = new(OwnerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ownerStatement
	return p
}

func InitEmptyOwnerStatementContext(p *OwnerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ownerStatement
}

func (*OwnerStatementContext) IsOwnerStatementContext() {}

func NewOwnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerStatementContext {
	var p = new(OwnerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_ownerStatement

	return p
}

func (s *OwnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerStatementContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFINER, 0)
}

func (s *OwnerStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *OwnerStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *OwnerStatementContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *OwnerStatementContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_ROLE, 0)
}

func (s *OwnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OwnerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOwnerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OwnerStatement() (localctx IOwnerStatementContext) {
	localctx = NewOwnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MariaDBParserRULE_ownerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Match(MariaDBParserDEFINER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1538)
			p.UserName()
		}

	case 2:
		{
			p.SetState(1539)
			p.CurrentUserExpression()
		}

	case 3:
		{
			p.SetState(1540)
			p.Match(MariaDBParserCURRENT_ROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScheduleExpressionContext is an interface to support dynamic dispatch.
type IScheduleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsScheduleExpressionContext differentiates from other interfaces.
	IsScheduleExpressionContext()
}

type ScheduleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScheduleExpressionContext() *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_scheduleExpression
	return p
}

func InitEmptyScheduleExpressionContext(p *ScheduleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_scheduleExpression
}

func (*ScheduleExpressionContext) IsScheduleExpressionContext() {}

func NewScheduleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_scheduleExpression

	return p
}

func (s *ScheduleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleExpressionContext) CopyAll(ctx *ScheduleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ScheduleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PreciseScheduleContext struct {
	ScheduleExpressionContext
}

func NewPreciseScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreciseScheduleContext {
	var p = new(PreciseScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *PreciseScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreciseScheduleContext) AT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAT, 0)
}

func (s *PreciseScheduleContext) TimestampValue() ITimestampValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *PreciseScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *PreciseScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *PreciseScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPreciseSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalScheduleContext struct {
	ScheduleExpressionContext
	startTimestamp ITimestampValueContext
	_intervalExpr  IIntervalExprContext
	startIntervals []IIntervalExprContext
	endTimestamp   ITimestampValueContext
	endIntervals   []IIntervalExprContext
}

func NewIntervalScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalScheduleContext {
	var p = new(IntervalScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *IntervalScheduleContext) GetStartTimestamp() ITimestampValueContext { return s.startTimestamp }

func (s *IntervalScheduleContext) Get_intervalExpr() IIntervalExprContext { return s._intervalExpr }

func (s *IntervalScheduleContext) GetEndTimestamp() ITimestampValueContext { return s.endTimestamp }

func (s *IntervalScheduleContext) SetStartTimestamp(v ITimestampValueContext) { s.startTimestamp = v }

func (s *IntervalScheduleContext) Set_intervalExpr(v IIntervalExprContext) { s._intervalExpr = v }

func (s *IntervalScheduleContext) SetEndTimestamp(v ITimestampValueContext) { s.endTimestamp = v }

func (s *IntervalScheduleContext) GetStartIntervals() []IIntervalExprContext { return s.startIntervals }

func (s *IntervalScheduleContext) GetEndIntervals() []IIntervalExprContext { return s.endIntervals }

func (s *IntervalScheduleContext) SetStartIntervals(v []IIntervalExprContext) { s.startIntervals = v }

func (s *IntervalScheduleContext) SetEndIntervals(v []IIntervalExprContext) { s.endIntervals = v }

func (s *IntervalScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVERY, 0)
}

func (s *IntervalScheduleContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalScheduleContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalScheduleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTARTS, 0)
}

func (s *IntervalScheduleContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENDS, 0)
}

func (s *IntervalScheduleContext) AllTimestampValue() []ITimestampValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimestampValueContext); ok {
			len++
		}
	}

	tst := make([]ITimestampValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimestampValueContext); ok {
			tst[i] = t.(ITimestampValueContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) TimestampValue(i int) ITimestampValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *IntervalScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *IntervalScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIntervalSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ScheduleExpression() (localctx IScheduleExpressionContext) {
	localctx = NewScheduleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MariaDBParserRULE_scheduleExpression)
	var _la int

	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserAT:
		localctx = NewPreciseScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1543)
			p.Match(MariaDBParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1544)
			p.TimestampValue()
		}
		p.SetState(1548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserPLUS {
			{
				p.SetState(1545)
				p.IntervalExpr()
			}

			p.SetState(1550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MariaDBParserEVERY:
		localctx = NewIntervalScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1551)
			p.Match(MariaDBParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1552)
				p.DecimalLiteral()
			}

		case 2:
			{
				p.SetState(1553)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1556)
			p.IntervalType()
		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTARTS {
			{
				p.SetState(1557)
				p.Match(MariaDBParserSTARTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1558)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).startTimestamp = _x
			}
			p.SetState(1562)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserPLUS {
				{
					p.SetState(1559)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).startIntervals = append(localctx.(*IntervalScheduleContext).startIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1564)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserENDS {
			{
				p.SetState(1567)
				p.Match(MariaDBParserENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1568)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).endTimestamp = _x
			}
			p.SetState(1572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserPLUS {
				{
					p.SetState(1569)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).endIntervals = append(localctx.(*IntervalScheduleContext).endIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1574)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestampValueContext is an interface to support dynamic dispatch.
type ITimestampValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsTimestampValueContext differentiates from other interfaces.
	IsTimestampValueContext()
}

type TimestampValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampValueContext() *TimestampValueContext {
	var p = new(TimestampValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_timestampValue
	return p
}

func InitEmptyTimestampValueContext(p *TimestampValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_timestampValue
}

func (*TimestampValueContext) IsTimestampValueContext() {}

func NewTimestampValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampValueContext {
	var p = new(TimestampValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_timestampValue

	return p
}

func (s *TimestampValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampValueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIMESTAMP, 0)
}

func (s *TimestampValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TimestampValueContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimestampValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimestampValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTimestampValue(s)
	}
}

func (s *TimestampValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTimestampValue(s)
	}
}

func (s *TimestampValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTimestampValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TimestampValue() (localctx ITimestampValueContext) {
	localctx = NewTimestampValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MariaDBParserRULE_timestampValue)
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1579)
			p.Match(MariaDBParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1580)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1581)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1582)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalExprContext is an interface to support dynamic dispatch.
type IIntervalExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	IntervalType() IIntervalTypeContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsIntervalExprContext differentiates from other interfaces.
	IsIntervalExprContext()
}

type IntervalExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExprContext() *IntervalExprContext {
	var p = new(IntervalExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalExpr
	return p
}

func InitEmptyIntervalExprContext(p *IntervalExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalExpr
}

func (*IntervalExprContext) IsIntervalExprContext() {}

func NewIntervalExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExprContext {
	var p = new(IntervalExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_intervalExpr

	return p
}

func (s *IntervalExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUS, 0)
}

func (s *IntervalExprContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERVAL, 0)
}

func (s *IntervalExprContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExprContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIntervalExpr(s)
	}
}

func (s *IntervalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIntervalExpr(s)
	}
}

func (s *IntervalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIntervalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IntervalExpr() (localctx IIntervalExprContext) {
	localctx = NewIntervalExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MariaDBParserRULE_intervalExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		p.Match(MariaDBParserPLUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1586)
		p.Match(MariaDBParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1587)
			p.DecimalLiteral()
		}

	case 2:
		{
			p.SetState(1588)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1591)
		p.IntervalType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTypeBase() IIntervalTypeBaseContext
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalType
	return p
}

func InitEmptyIntervalTypeContext(p *IntervalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalType
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IntervalType() (localctx IIntervalTypeContext) {
	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MariaDBParserRULE_intervalType)
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1593)
			p.IntervalTypeBase()
		}

	case MariaDBParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1594)
			p.Match(MariaDBParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1595)
			p.Match(MariaDBParserYEAR_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1596)
			p.Match(MariaDBParserDAY_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1597)
			p.Match(MariaDBParserDAY_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1598)
			p.Match(MariaDBParserDAY_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1599)
			p.Match(MariaDBParserHOUR_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1600)
			p.Match(MariaDBParserHOUR_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1601)
			p.Match(MariaDBParserMINUTE_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1602)
			p.Match(MariaDBParserSECOND_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1603)
			p.Match(MariaDBParserMINUTE_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1604)
			p.Match(MariaDBParserHOUR_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1605)
			p.Match(MariaDBParserDAY_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnableTypeContext is an interface to support dynamic dispatch.
type IEnableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SLAVE() antlr.TerminalNode

	// IsEnableTypeContext differentiates from other interfaces.
	IsEnableTypeContext()
}

type EnableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableTypeContext() *EnableTypeContext {
	var p = new(EnableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_enableType
	return p
}

func InitEmptyEnableTypeContext(p *EnableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_enableType
}

func (*EnableTypeContext) IsEnableTypeContext() {}

func NewEnableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableTypeContext {
	var p = new(EnableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_enableType

	return p
}

func (s *EnableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableTypeContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENABLE, 0)
}

func (s *EnableTypeContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISABLE, 0)
}

func (s *EnableTypeContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *EnableTypeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *EnableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterEnableType(s)
	}
}

func (s *EnableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitEnableType(s)
	}
}

func (s *EnableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitEnableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) EnableType() (localctx IEnableTypeContext) {
	localctx = NewEnableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MariaDBParserRULE_enableType)
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1608)
			p.Match(MariaDBParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1609)
			p.Match(MariaDBParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1610)
			p.Match(MariaDBParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1612)
			p.Match(MariaDBParserSLAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode
	RTREE() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHASH, 0)
}

func (s *IndexTypeContext) RTREE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRTREE, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MariaDBParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(MariaDBParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1616)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserBTREE || _la == MariaDBParserHASH || _la == MariaDBParserRTREE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	EQUAL_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Uid() IUidContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	YES() antlr.TerminalNode
	NO() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLUSTERING, 0)
}

func (s *IndexOptionContext) YES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYES, 0)
}

func (s *IndexOptionContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *IndexOptionContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORED, 0)
}

func (s *IndexOptionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MariaDBParserRULE_indexOption)
	var _la int

	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1618)
			p.Match(MariaDBParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1619)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1622)
			p.FileSizeLiteral()
		}

	case MariaDBParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1623)
			p.IndexType()
		}

	case MariaDBParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1624)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1625)
			p.Match(MariaDBParserPARSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			p.Uid()
		}

	case MariaDBParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1627)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1628)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserINVISIBLE, MariaDBParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1629)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINVISIBLE || _la == MariaDBParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1630)
			p.Match(MariaDBParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1631)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1634)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1635)
			p.Match(MariaDBParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1636)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1639)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCLUSTERING:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1640)
			p.Match(MariaDBParserCLUSTERING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNO || _la == MariaDBParserYES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserIGNORED, MariaDBParserNOT:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(1646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserIGNORED:
			{
				p.SetState(1643)
				p.Match(MariaDBParserIGNORED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserNOT:
			{
				p.SetState(1644)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1645)
				p.Match(MariaDBParserIGNORED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDirection returns the direction token.
	GetDirection() antlr.Token

	// SetDirection sets the direction token.
	SetDirection(antlr.Token)

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	INOUT() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	direction antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_procedureParameter
	return p
}

func InitEmptyProcedureParameterContext(p *ProcedureParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_procedureParameter
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetDirection() antlr.Token { return s.direction }

func (s *ProcedureParameterContext) SetDirection(v antlr.Token) { s.direction = v }

func (s *ProcedureParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ProcedureParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ProcedureParameterContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *ProcedureParameterContext) OUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOUT, 0)
}

func (s *ProcedureParameterContext) INOUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINOUT, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitProcedureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MariaDBParserRULE_procedureParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&35184372088849) != 0 {
		{
			p.SetState(1650)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).direction = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&35184372088849) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).direction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1653)
		p.Uid()
	}
	{
		p.SetState(1654)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MariaDBParserRULE_functionParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1656)
		p.Uid()
	}
	{
		p.SetState(1657)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineOptionContext is an interface to support dynamic dispatch.
type IRoutineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRoutineOptionContext differentiates from other interfaces.
	IsRoutineOptionContext()
}

type RoutineOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineOptionContext() *RoutineOptionContext {
	var p = new(RoutineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_routineOption
	return p
}

func InitEmptyRoutineOptionContext(p *RoutineOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_routineOption
}

func (*RoutineOptionContext) IsRoutineOptionContext() {}

func NewRoutineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineOptionContext {
	var p = new(RoutineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_routineOption

	return p
}

func (s *RoutineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineOptionContext) CopyAll(ctx *RoutineOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RoutineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RoutineBehaviorContext struct {
	RoutineOptionContext
}

func NewRoutineBehaviorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineBehaviorContext {
	var p = new(RoutineBehaviorContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBehaviorContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDETERMINISTIC, 0)
}

func (s *RoutineBehaviorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *RoutineBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineLanguageContext struct {
	RoutineOptionContext
}

func NewRoutineLanguageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineLanguageContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLANGUAGE, 0)
}

func (s *RoutineLanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL, 0)
}

func (s *RoutineLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineLanguage(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineCommentContext struct {
	RoutineOptionContext
}

func NewRoutineCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineCommentContext {
	var p = new(RoutineCommentContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *RoutineCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *RoutineCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineComment(s)
	}
}

func (s *RoutineCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineComment(s)
	}
}

func (s *RoutineCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineSecurityContext struct {
	RoutineOptionContext
	context antlr.Token
}

func NewRoutineSecurityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineSecurityContext {
	var p = new(RoutineSecurityContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineSecurityContext) GetContext() antlr.Token { return s.context }

func (s *RoutineSecurityContext) SetContext(v antlr.Token) { s.context = v }

func (s *RoutineSecurityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineSecurityContext) SQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL, 0)
}

func (s *RoutineSecurityContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECURITY, 0)
}

func (s *RoutineSecurityContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFINER, 0)
}

func (s *RoutineSecurityContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKER, 0)
}

func (s *RoutineSecurityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineSecurity(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineDataContext struct {
	RoutineOptionContext
}

func NewRoutineDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineDataContext {
	var p = new(RoutineDataContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineDataContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTAINS, 0)
}

func (s *RoutineDataContext) SQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL, 0)
}

func (s *RoutineDataContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *RoutineDataContext) READS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREADS, 0)
}

func (s *RoutineDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *RoutineDataContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODIFIES, 0)
}

func (s *RoutineDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineData(s)
	}
}

func (s *RoutineDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineData(s)
	}
}

func (s *RoutineDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RoutineOption() (localctx IRoutineOptionContext) {
	localctx = NewRoutineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MariaDBParserRULE_routineOption)
	var _la int

	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCOMMENT:
		localctx = NewRoutineCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1659)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLANGUAGE:
		localctx = NewRoutineLanguageContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1661)
			p.Match(MariaDBParserLANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.Match(MariaDBParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDETERMINISTIC, MariaDBParserNOT:
		localctx = NewRoutineBehaviorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNOT {
			{
				p.SetState(1663)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1666)
			p.Match(MariaDBParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMODIFIES, MariaDBParserREADS, MariaDBParserCONTAINS, MariaDBParserNO:
		localctx = NewRoutineDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserCONTAINS:
			{
				p.SetState(1667)
				p.Match(MariaDBParserCONTAINS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1668)
				p.Match(MariaDBParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserNO:
			{
				p.SetState(1669)
				p.Match(MariaDBParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1670)
				p.Match(MariaDBParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserREADS:
			{
				p.SetState(1671)
				p.Match(MariaDBParserREADS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1672)
				p.Match(MariaDBParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1673)
				p.Match(MariaDBParserDATA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserMODIFIES:
			{
				p.SetState(1674)
				p.Match(MariaDBParserMODIFIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1675)
				p.Match(MariaDBParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1676)
				p.Match(MariaDBParserDATA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MariaDBParserSQL:
		localctx = NewRoutineSecurityContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1679)
			p.Match(MariaDBParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Match(MariaDBParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1681)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoutineSecurityContext).context = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFINER || _la == MariaDBParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoutineSecurityContext).context = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerOptionContext is an interface to support dynamic dispatch.
type IServerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOST() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	USER() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PORT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsServerOptionContext differentiates from other interfaces.
	IsServerOptionContext()
}

type ServerOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerOptionContext() *ServerOptionContext {
	var p = new(ServerOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_serverOption
	return p
}

func InitEmptyServerOptionContext(p *ServerOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_serverOption
}

func (*ServerOptionContext) IsServerOptionContext() {}

func NewServerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionContext {
	var p = new(ServerOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_serverOption

	return p
}

func (s *ServerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionContext) HOST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOST, 0)
}

func (s *ServerOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ServerOptionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *ServerOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *ServerOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *ServerOptionContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOCKET, 0)
}

func (s *ServerOptionContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOWNER, 0)
}

func (s *ServerOptionContext) PORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPORT, 0)
}

func (s *ServerOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ServerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterServerOption(s)
	}
}

func (s *ServerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitServerOption(s)
	}
}

func (s *ServerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitServerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ServerOption() (localctx IServerOptionContext) {
	localctx = NewServerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MariaDBParserRULE_serverOption)
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserHOST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1684)
			p.Match(MariaDBParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1685)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1686)
			p.Match(MariaDBParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserUSER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1688)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPASSWORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1690)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSOCKET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1692)
			p.Match(MariaDBParserSOCKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserOWNER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1694)
			p.Match(MariaDBParserOWNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPORT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1696)
			p.Match(MariaDBParserPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1697)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllCreateDefinition() []ICreateDefinitionContext
	CreateDefinition(i int) ICreateDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDefinitions
	return p
}

func InitEmptyCreateDefinitionsContext(p *CreateDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDefinitions
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MariaDBParserRULE_createDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1700)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1701)
		p.CreateDefinition()
	}
	p.SetState(1706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(1702)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1703)
			p.CreateDefinition()
		}

		p.SetState(1708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1709)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDefinition
	return p
}

func InitEmptyCreateDefinitionContext(p *CreateDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createDefinition
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyAll(ctx *CreateDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnDeclarationContext struct {
	CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitColumnDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstraintDeclarationContext struct {
	CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitConstraintDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexDeclarationContext struct {
	CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}

func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MariaDBParserRULE_createDefinition)
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1711)
			p.Uid()
		}
		{
			p.SetState(1712)
			p.ColumnDefinition()
		}

	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1714)
			p.TableConstraint()
		}

	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1715)
			p.IndexColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MariaDBParserRULE_columnDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1718)
		p.DataType()
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1719)
				p.ColumnConstraint()
			}

		}
		p.SetState(1724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyAll(ctx *ColumnConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StorageColumnConstraintContext struct {
	ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }

func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStorageColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type VisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitVisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AutoIncrementColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAutoIncrementColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCommentColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type UniqueKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUniqueKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type SerialDefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSerialDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type GeneratedColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORED, 0)
}

func (s *GeneratedColumnConstraintContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERSISTENT, 0)
}

func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGeneratedColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type FormatColumnConstraintContext struct {
	ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }

func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFormatColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCollateColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIMARY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrimaryKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CheckColumnConstraintContext struct {
	ColumnConstraintContext
	name IUidContext
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCheckColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNullColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReferenceColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReferenceColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type InvisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewInvisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvisibilityColumnConstraintContext {
	var p = new(InvisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *InvisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVISIBLE, 0)
}

func (s *InvisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInvisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MariaDBParserRULE_columnConstraint)
	var _la int

	p.SetState(1778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserNOT, MariaDBParserNULL_LITERAL, MariaDBParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.NullNotnull()
		}

	case MariaDBParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1726)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1727)
			p.DefaultValue()
		}

	case MariaDBParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1728)
			p.Match(MariaDBParserVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserINVISIBLE:
		localctx = NewInvisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1729)
			p.Match(MariaDBParserINVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserON, MariaDBParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserAUTO_INCREMENT:
			{
				p.SetState(1730)
				p.Match(MariaDBParserAUTO_INCREMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserON:
			{
				p.SetState(1731)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1732)
				p.Match(MariaDBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1733)
				p.CurrentTimestamp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MariaDBParserKEY, MariaDBParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPRIMARY {
			{
				p.SetState(1736)
				p.Match(MariaDBParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1739)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1740)
			p.Match(MariaDBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1741)
				p.Match(MariaDBParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1744)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1745)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1746)
			p.Match(MariaDBParserCOLUMN_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1747)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserDYNAMIC || _la == MariaDBParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1748)
			p.Match(MariaDBParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1749)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserDISK || _la == MariaDBParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1750)
			p.ReferenceDefinition()
		}

	case MariaDBParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1751)
			p.Match(MariaDBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.CollationName()
		}

	case MariaDBParserAS, MariaDBParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserGENERATED {
			{
				p.SetState(1753)
				p.Match(MariaDBParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1754)
				p.Match(MariaDBParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1757)
			p.Match(MariaDBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1759)
			p.expression(0)
		}
		{
			p.SetState(1760)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTORED || _la == MariaDBParserVIRTUAL || _la == MariaDBParserPERSISTENT {
			{
				p.SetState(1761)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserSTORED || _la == MariaDBParserVIRTUAL || _la == MariaDBParserPERSISTENT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case MariaDBParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1764)
			p.Match(MariaDBParserSERIAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1766)
			p.Match(MariaDBParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCHECK, MariaDBParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(1771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(1767)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1769)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(1768)

					var _x = p.Uid()

					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1773)
			p.Match(MariaDBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1774)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1775)
			p.expression(0)
		}
		{
			p.SetState(1776)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyAll(ctx *TableConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UniqueKeyTableConstraintContext struct {
	TableConstraintContext
	name        IUidContext
	indexFormat antlr.Token
	index       IUidContext
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUniqueKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CheckTableConstraintContext struct {
	TableConstraintContext
	name IUidContext
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrimaryKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForeignKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitForeignKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MariaDBParserRULE_tableConstraint)
	var _la int

	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(1780)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1782)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1781)

					var _x = p.Uid()

					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(1786)
			p.Match(MariaDBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(1788)

				var _x = p.Uid()

				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(1791)
				p.IndexType()
			}

		}
		{
			p.SetState(1794)
			p.IndexColumnNames()
		}
		p.SetState(1798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1795)
				p.IndexOption()
			}

			p.SetState(1800)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(1801)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(1802)

					var _x = p.Uid()

					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1807)
			p.Match(MariaDBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(1808)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(1811)

				var _x = p.Uid()

				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(1814)
				p.IndexType()
			}

		}
		{
			p.SetState(1817)
			p.IndexColumnNames()
		}
		p.SetState(1821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1818)
				p.IndexOption()
			}

			p.SetState(1823)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(1824)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(1825)

					var _x = p.Uid()

					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1830)
			p.Match(MariaDBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1831)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(1832)

				var _x = p.Uid()

				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(1835)
			p.IndexColumnNames()
		}
		{
			p.SetState(1836)
			p.ReferenceDefinition()
		}

	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(1838)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(1839)

					var _x = p.Uid()

					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1844)
			p.Match(MariaDBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1846)
			p.expression(0)
		}
		{
			p.SetState(1847)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token

	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	MATCH() antlr.TerminalNode
	ReferenceAction() IReferenceActionContext
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceDefinition
	return p
}

func InitEmptyReferenceDefinitionContext(p *ReferenceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceDefinition
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }

func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReferenceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MariaDBParserRULE_referenceDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1851)
		p.Match(MariaDBParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1852)
		p.TableName()
	}
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1853)
			p.IndexColumnNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserMATCH {
		{
			p.SetState(1856)
			p.Match(MariaDBParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFULL || _la == MariaDBParserPARTIAL || _la == MariaDBParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1861)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1860)
			p.ReferenceAction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext

	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)

	// Getter signatures
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReferenceControlType() []IReferenceControlTypeContext
	ReferenceControlType(i int) IReferenceControlTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	onDelete IReferenceControlTypeContext
	onUpdate IReferenceControlTypeContext
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceAction
	return p
}

func InitEmptyReferenceActionContext(p *ReferenceActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceAction
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }

func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }

func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (s *ReferenceActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReferenceAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReferenceAction() (localctx IReferenceActionContext) {
	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MariaDBParserRULE_referenceAction)
	p.SetState(1879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1863)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1864)
			p.Match(MariaDBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1865)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(1869)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1866)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1867)
				p.Match(MariaDBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1868)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onUpdate = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1871)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.Match(MariaDBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1873)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1874)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1875)
				p.Match(MariaDBParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1876)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onDelete = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceControlType
	return p
}

func InitEmptyReferenceControlTypeContext(p *ReferenceControlTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_referenceControlType
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserACTION, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReferenceControlType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MariaDBParserRULE_referenceControlType)
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserRESTRICT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1881)
			p.Match(MariaDBParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCASCADE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1882)
			p.Match(MariaDBParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1883)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Match(MariaDBParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserNO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1885)
			p.Match(MariaDBParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1886)
			p.Match(MariaDBParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnDefinition
	return p
}

func InitEmptyIndexColumnDefinitionContext(p *IndexColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnDefinition
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyAll(ctx *IndexColumnDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSpecialIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MariaDBParserRULE_indexColumnDefinition)
	var _la int

	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserINDEX, MariaDBParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1889)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(1890)
				p.Uid()
			}

		}
		p.SetState(1894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(1893)
				p.IndexType()
			}

		}
		{
			p.SetState(1896)
			p.IndexColumnNames()
		}
		p.SetState(1900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1897)
				p.IndexOption()
			}

			p.SetState(1902)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MariaDBParserFULLTEXT, MariaDBParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1903)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFULLTEXT || _la == MariaDBParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(1904)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(1907)
				p.Uid()
			}

		}
		{
			p.SetState(1910)
			p.IndexColumnNames()
		}
		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1911)
				p.IndexOption()
			}

			p.SetState(1916)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableOption
	return p
}

func InitEmptyTableOptionContext(p *TableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableOption
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyAll(ctx *TableOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableOptionEngineContext struct {
	TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionMaxRowsContext struct {
	TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCollateContext struct {
	TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPersistentContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionPersistent(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTablespaceContext struct {
	TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}

func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAutoextendSizeContext struct {
	TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionAutoextendSize(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPageCompressedContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressedContext {
	var p = new(TableOptionPageCompressedContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressedContext) PAGE_COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE_COMPRESSED, 0)
}

func (s *TableOptionPageCompressedContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressedContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionPageCompressed(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionStartTransactionContext struct {
	TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTION, 0)
}

func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPackKeysContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionPackKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPasswordContext struct {
	TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionUnionContext struct {
	TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionSamplePageContext struct {
	TableOptionContext
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionSamplePage(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCharsetContext struct {
	TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionIndexDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTableTypeContext struct {
	TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionTableType(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionKeyBlockSizeContext struct {
	TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionKeyBlockSize(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEncryptionContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionDataDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionRecalculationContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionRecalculation(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAutoIncrementContext struct {
	TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionAutoIncrement(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEncryptionKeyIdContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionKeyIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionKeyIdContext {
	var p = new(TableOptionEncryptionKeyIdContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionKeyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionKeyIdContext) ENCRYPTION_KEY_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION_KEY_ID, 0)
}

func (s *TableOptionEncryptionKeyIdContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionEncryptionKeyIdContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionKeyIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionEncryptionKeyId(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionChecksumContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionChecksum(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEncryptedContext struct {
	TableOptionContext
}

func NewTableOptionEncryptedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptedContext {
	var p = new(TableOptionEncryptedContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptedContext) EncryptedLiteral() IEncryptedLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEncryptedLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEncryptedLiteralContext)
}

func (s *TableOptionEncryptedContext) YES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYES, 0)
}

func (s *TableOptionEncryptedContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *TableOptionEncryptedContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionEncrypted(s)
	}
}

func (s *TableOptionEncryptedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionEncrypted(s)
	}
}

func (s *TableOptionEncryptedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionEncrypted(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionDelayContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionDelay(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionConnectionContext struct {
	TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTransactionalContext struct {
	TableOptionContext
}

func NewTableOptionTransactionalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTransactionalContext {
	var p = new(TableOptionTransactionalContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTransactionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTransactionalContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTIONAL, 0)
}

func (s *TableOptionTransactionalContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTransactionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionTransactional(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPageCompressionLevelContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressionLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressionLevelContext {
	var p = new(TableOptionPageCompressionLevelContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressionLevelContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionPageCompressionLevelContext) PAGE_COMPRESSION_LEVEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE_COMPRESSION_LEVEL, 0)
}

func (s *TableOptionPageCompressionLevelContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionPageCompressionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionSecondaryEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionSecondaryEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCommentContext struct {
	TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAverageContext struct {
	TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionAverage(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionRowFormatContext struct {
	TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }

func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionRowFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCompressionContext struct {
	TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionCompression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionInsertMethodContext struct {
	TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }

func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionInsertMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionMinRowsContext struct {
	TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableOption() (localctx ITableOptionContext) {
	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MariaDBParserRULE_tableOption)
	var _la int

	p.SetState(2110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1919)
			p.Match(MariaDBParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1920)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1923)
				p.EngineName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1926)
			p.Match(MariaDBParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1927)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1930)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1931)
			p.Match(MariaDBParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1932)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1935)
			p.DecimalLiteral()
		}

	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1936)
			p.Match(MariaDBParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1937)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1940)
			p.DecimalLiteral()
		}

	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1941)
			p.Match(MariaDBParserAVG_ROW_LENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1942)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1945)
			p.DecimalLiteral()
		}

	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(1946)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1949)
			p.CharSet()
		}
		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1950)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserBINARY, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL:
			{
				p.SetState(1953)
				p.CharsetName()
			}

		case MariaDBParserDEFAULT:
			{
				p.SetState(1954)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1957)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCHECKSUM || _la == MariaDBParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1958)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1961)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(1962)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1965)
			p.Match(MariaDBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1966)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1969)
			p.CollationName()
		}

	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1970)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1971)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1974)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1975)
			p.Match(MariaDBParserCOMPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1976)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1979)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSTRING_LITERAL || _la == MariaDBParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1980)
			p.Match(MariaDBParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1981)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1984)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1985)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1986)
			p.Match(MariaDBParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1987)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1990)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1991)
			p.Match(MariaDBParserDELAY_KEY_WRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1992)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1995)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1996)
			p.Match(MariaDBParserENCRYPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(1997)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2000)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewTableOptionEncryptedContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2001)
			p.EncryptedLiteral()
		}
		p.SetState(2003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2002)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2005)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNO || _la == MariaDBParserYES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		localctx = NewTableOptionPageCompressedContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2007)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserPAGE_COMPRESSED || _la == MariaDBParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2008)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2011)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewTableOptionPageCompressionLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2012)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserPAGE_COMPRESSION_LEVEL || _la == MariaDBParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2013)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2016)
			p.DecimalLiteral()
		}

	case 18:
		localctx = NewTableOptionEncryptionKeyIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2017)
			p.Match(MariaDBParserENCRYPTION_KEY_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2018)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2021)
			p.DecimalLiteral()
		}

	case 19:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2022)
			p.Match(MariaDBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.Match(MariaDBParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2024)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2027)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2028)
			p.Match(MariaDBParserINSERT_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2029)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2032)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFIRST || _la == MariaDBParserLAST || _la == MariaDBParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 21:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2033)
			p.Match(MariaDBParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2034)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2037)
			p.FileSizeLiteral()
		}

	case 22:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2038)
			p.Match(MariaDBParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2039)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2042)
			p.DecimalLiteral()
		}

	case 23:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2043)
			p.Match(MariaDBParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2044)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2047)
			p.DecimalLiteral()
		}

	case 24:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2048)
			p.Match(MariaDBParserPACK_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2049)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2052)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 25:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2053)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2054)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2057)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2058)
			p.Match(MariaDBParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2059)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2062)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || ((int64((_la-370)) & ^0x3f) == 0 && ((int64(1)<<(_la-370))&2305843013508661253) != 0) || _la == MariaDBParserREDUNDANT || _la == MariaDBParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 27:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2063)
			p.Match(MariaDBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2064)
			p.Match(MariaDBParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2065)
			p.Match(MariaDBParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2066)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2069)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2070)
			p.Match(MariaDBParserSTATS_AUTO_RECALC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2071)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2074)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 30:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2075)
			p.Match(MariaDBParserSTATS_PERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2076)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2079)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 31:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2080)
			p.Match(MariaDBParserSTATS_SAMPLE_PAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2081)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserDEFAULT:
			{
				p.SetState(2084)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
			{
				p.SetState(2085)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 32:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2088)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2089)
			p.Uid()
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2090)
				p.TablespaceStorage()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 33:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2093)
			p.Match(MariaDBParserTABLE_TYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2094)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.TableType()
		}

	case 34:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2096)
			p.TablespaceStorage()
		}

	case 35:
		localctx = NewTableOptionTransactionalContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2097)
			p.Match(MariaDBParserTRANSACTIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2098)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2101)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 36:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2102)
			p.Match(MariaDBParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2103)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2106)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.Tables()
		}
		{
			p.SetState(2108)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MYSQL() antlr.TerminalNode
	ODBC() antlr.TerminalNode

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableType
	return p
}

func InitEmptyTableTypeContext(p *TableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableType
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (s *TableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableType() (localctx ITableTypeContext) {
	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MariaDBParserRULE_tableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2112)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserMYSQL || _la == MariaDBParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tablespaceStorage
	return p
}

func InitEmptyTablespaceStorageContext(p *TablespaceStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tablespaceStorage
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTablespaceStorage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MariaDBParserRULE_tablespaceStorage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2114)
		p.Match(MariaDBParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2115)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserDISK || _la == MariaDBParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext

	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	PartitionFunctionDefinition() IPartitionFunctionDefinitionContext
	PARTITIONS() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	count    IDecimalLiteralContext
	subCount IDecimalLiteralContext
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }

func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }

func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MariaDBParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Match(MariaDBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2118)
		p.Match(MariaDBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2119)
		p.PartitionFunctionDefinition()
	}
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITIONS {
		{
			p.SetState(2120)
			p.Match(MariaDBParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(2131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserSUBPARTITION {
		{
			p.SetState(2124)
			p.Match(MariaDBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2125)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(2129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSUBPARTITIONS {
			{
				p.SetState(2127)
				p.Match(MariaDBParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2128)

				var _x = p.DecimalLiteral()

				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(2144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2133)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2134)
			p.PartitionDefinition()
		}
		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2135)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2136)
				p.PartitionDefinition()
			}

			p.SetState(2141)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2142)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionFunctionDefinition
	return p
}

func InitEmptyPartitionFunctionDefinitionContext(p *PartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionFunctionDefinition
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyAll(ctx *PartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionFunctionKeyContext struct {
	PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTWO_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionHashContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEAR, 0)
}

func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionListContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionFunctionList(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionRangeContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionFunctionRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MariaDBParserRULE_partitionFunctionDefinition)
	var _la int

	p.SetState(2191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLINEAR {
			{
				p.SetState(2146)
				p.Match(MariaDBParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2149)
			p.Match(MariaDBParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2151)
			p.expression(0)
		}
		{
			p.SetState(2152)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLINEAR {
			{
				p.SetState(2154)
				p.Match(MariaDBParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2157)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserALGORITHM {
			{
				p.SetState(2158)
				p.Match(MariaDBParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2159)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2160)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserONE_DECIMAL || _la == MariaDBParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2163)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2164)
			p.UidList()
		}
		{
			p.SetState(2165)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2167)
			p.Match(MariaDBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserLR_BRACKET:
			{
				p.SetState(2168)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2169)
				p.expression(0)
			}
			{
				p.SetState(2170)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserCOLUMNS:
			{
				p.SetState(2172)
				p.Match(MariaDBParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2173)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2174)
				p.UidList()
			}
			{
				p.SetState(2175)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2179)
			p.Match(MariaDBParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserLR_BRACKET:
			{
				p.SetState(2180)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2181)
				p.expression(0)
			}
			{
				p.SetState(2182)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserCOLUMNS:
			{
				p.SetState(2184)
				p.Match(MariaDBParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2185)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2186)
				p.UidList()
			}
			{
				p.SetState(2187)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_subpartitionFunctionDefinition
	return p
}

func InitEmptySubpartitionFunctionDefinitionContext(p *SubpartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_subpartitionFunctionDefinition
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyAll(ctx *SubpartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubPartitionFunctionHashContext struct {
	SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEAR, 0)
}

func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubPartitionFunctionKeyContext struct {
	SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTWO_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MariaDBParserRULE_subpartitionFunctionDefinition)
	var _la int

	p.SetState(2214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLINEAR {
			{
				p.SetState(2193)
				p.Match(MariaDBParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2196)
			p.Match(MariaDBParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2197)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2198)
			p.expression(0)
		}
		{
			p.SetState(2199)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLINEAR {
			{
				p.SetState(2201)
				p.Match(MariaDBParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2204)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserALGORITHM {
			{
				p.SetState(2205)
				p.Match(MariaDBParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2206)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2207)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserONE_DECIMAL || _la == MariaDBParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2210)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2211)
			p.UidList()
		}
		{
			p.SetState(2212)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyAll(ctx *PartitionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionComparisonContext struct {
	PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionListAtomContext struct {
	PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionListAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionListVectorContext struct {
	PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionListVector(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionSimpleContext struct {
	PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionSimple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MariaDBParserRULE_partitionDefinition)
	var _la int

	p.SetState(2362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2216)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2217)
			p.Uid()
		}
		{
			p.SetState(2218)
			p.Match(MariaDBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2219)
			p.Match(MariaDBParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2220)
			p.Match(MariaDBParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2221)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2222)
			p.PartitionDefinerAtom()
		}
		p.SetState(2227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2223)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2224)
				p.PartitionDefinerAtom()
			}

			p.SetState(2229)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2230)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
			{
				p.SetState(2231)
				p.PartitionOption()
			}

			p.SetState(2236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(2237)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2238)
				p.SubpartitionDefinition()
			}
			p.SetState(2243)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(2239)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2240)
					p.SubpartitionDefinition()
				}

				p.SetState(2245)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2246)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2250)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Uid()
		}
		{
			p.SetState(2252)
			p.Match(MariaDBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2253)
			p.Match(MariaDBParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2254)
			p.Match(MariaDBParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2255)
			p.PartitionDefinerAtom()
		}
		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
			{
				p.SetState(2256)
				p.PartitionOption()
			}

			p.SetState(2261)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(2262)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2263)
				p.SubpartitionDefinition()
			}
			p.SetState(2268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(2264)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2265)
					p.SubpartitionDefinition()
				}

				p.SetState(2270)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2271)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2275)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2276)
			p.Uid()
		}
		{
			p.SetState(2277)
			p.Match(MariaDBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2278)
			p.Match(MariaDBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2279)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2280)
			p.PartitionDefinerAtom()
		}
		p.SetState(2285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2281)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2282)
				p.PartitionDefinerAtom()
			}

			p.SetState(2287)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2288)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
			{
				p.SetState(2289)
				p.PartitionOption()
			}

			p.SetState(2294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(2295)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2296)
				p.SubpartitionDefinition()
			}
			p.SetState(2301)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(2297)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2298)
					p.SubpartitionDefinition()
				}

				p.SetState(2303)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2304)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2308)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2309)
			p.Uid()
		}
		{
			p.SetState(2310)
			p.Match(MariaDBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2311)
			p.Match(MariaDBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2312)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2313)
			p.PartitionDefinerVector()
		}
		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2314)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2315)
				p.PartitionDefinerVector()
			}

			p.SetState(2320)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2321)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
			{
				p.SetState(2322)
				p.PartitionOption()
			}

			p.SetState(2327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(2328)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2329)
				p.SubpartitionDefinition()
			}
			p.SetState(2334)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(2330)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2331)
					p.SubpartitionDefinition()
				}

				p.SetState(2336)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2337)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2341)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2342)
			p.Uid()
		}
		p.SetState(2346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
			{
				p.SetState(2343)
				p.PartitionOption()
			}

			p.SetState(2348)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(2349)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2350)
				p.SubpartitionDefinition()
			}
			p.SetState(2355)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(2351)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2352)
					p.SubpartitionDefinition()
				}

				p.SetState(2357)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2358)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Expression() IExpressionContext
	MAXVALUE() antlr.TerminalNode

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinerAtom
	return p
}

func InitEmptyPartitionDefinerAtomContext(p *PartitionDefinerAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinerAtom
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionDefinerAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MariaDBParserRULE_partitionDefinerAtom)
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2364)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2365)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2366)
			p.Match(MariaDBParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinerAtom() []IPartitionDefinerAtomContext
	PartitionDefinerAtom(i int) IPartitionDefinerAtomContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinerVector
	return p
}

func InitEmptyPartitionDefinerVectorContext(p *PartitionDefinerVectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionDefinerVector
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionDefinerVector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MariaDBParserRULE_partitionDefinerVector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2370)
		p.PartitionDefinerAtom()
	}
	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MariaDBParserCOMMA {
		{
			p.SetState(2371)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2372)
			p.PartitionDefinerAtom()
		}

		p.SetState(2375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2377)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Uid() IUidContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubpartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MariaDBParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.Match(MariaDBParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2380)
		p.Uid()
	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserDEFAULT || _la == MariaDBParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&268436481) != 0) || _la == MariaDBParserSTORAGE || _la == MariaDBParserTABLESPACE {
		{
			p.SetState(2381)
			p.PartitionOption()
		}

		p.SetState(2386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyAll(ctx *PartitionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionOptionCommentContext struct {
	PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }

func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionNodeGroupContext struct {
	PartitionOptionContext
	nodegroup IUidContext
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }

func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionNodeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionIndexDirectoryContext struct {
	PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token {
	return s.indexDirectory
}

func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionMaxRowsContext struct {
	PartitionOptionContext
	maxRows IDecimalLiteralContext
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }

func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionTablespaceContext struct {
	PartitionOptionContext
	tablespace IUidContext
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }

func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionEngineContext struct {
	PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionMinRowsContext struct {
	PartitionOptionContext
	minRows IDecimalLiteralContext
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }

func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionDataDirectoryContext struct {
	PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }

func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MariaDBParserRULE_partitionOption)
	var _la int

	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserDEFAULT, MariaDBParserENGINE, MariaDBParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(2387)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTORAGE {
			{
				p.SetState(2390)
				p.Match(MariaDBParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2393)
			p.Match(MariaDBParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2394)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2397)
			p.EngineName()
		}

	case MariaDBParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2398)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2399)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2402)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2403)
			p.Match(MariaDBParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2404)
			p.Match(MariaDBParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2405)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2408)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2409)
			p.Match(MariaDBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2410)
			p.Match(MariaDBParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2411)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2414)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2415)
			p.Match(MariaDBParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2416)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2419)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}

	case MariaDBParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2420)
			p.Match(MariaDBParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2421)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2424)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}

	case MariaDBParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2425)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2426)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2429)

			var _x = p.Uid()

			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}

	case MariaDBParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2430)
			p.Match(MariaDBParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2431)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2434)

			var _x = p.Uid()

			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterDatabase
	return p
}

func InitEmptyAlterDatabaseContext(p *AlterDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterDatabase
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) CopyAll(ctx *AlterDatabaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUpgradeNameContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterUpgradeNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUpgradeNameContext {
	var p = new(AlterUpgradeNameContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterUpgradeNameContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterUpgradeNameContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterUpgradeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUpgradeNameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterUpgradeNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUpgradeNameContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPGRADE, 0)
}

func (s *AlterUpgradeNameContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *AlterUpgradeNameContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *AlterUpgradeNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNAME, 0)
}

func (s *AlterUpgradeNameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *AlterUpgradeNameContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *AlterUpgradeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterUpgradeName(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterSimpleDatabaseContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterSimpleDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSimpleDatabaseContext {
	var p = new(AlterSimpleDatabaseContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterSimpleDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterSimpleDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterSimpleDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSimpleDatabaseContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterSimpleDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *AlterSimpleDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *AlterSimpleDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterSimpleDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSimpleDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *AlterSimpleDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterSimpleDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MariaDBParserRULE_alterDatabase)
	var _la int

	p.SetState(2455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSimpleDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2437)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2438)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterSimpleDatabaseContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDATABASE || _la == MariaDBParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterSimpleDatabaseContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2440)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2439)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796428566528) != 0) || _la == MariaDBParserREAD || _la == MariaDBParserCHAR || _la == MariaDBParserENCRYPTION || _la == MariaDBParserCHARSET {
			{
				p.SetState(2442)
				p.CreateDatabaseOption()
			}

			p.SetState(2445)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUpgradeNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2447)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2448)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterUpgradeNameContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDATABASE || _la == MariaDBParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterUpgradeNameContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2449)
			p.Uid()
		}
		{
			p.SetState(2450)
			p.Match(MariaDBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2451)
			p.Match(MariaDBParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2452)
			p.Match(MariaDBParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2453)
			p.Match(MariaDBParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterEventContext is an interface to support dynamic dispatch.
type IAlterEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	OwnerStatement() IOwnerStatementContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	NOT() antlr.TerminalNode

	// IsAlterEventContext differentiates from other interfaces.
	IsAlterEventContext()
}

type AlterEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterEventContext() *AlterEventContext {
	var p = new(AlterEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterEvent
	return p
}

func InitEmptyAlterEventContext(p *AlterEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterEvent
}

func (*AlterEventContext) IsAlterEventContext() {}

func NewAlterEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterEventContext {
	var p = new(AlterEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterEvent

	return p
}

func (s *AlterEventContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterEventContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *AlterEventContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *AlterEventContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserON)
}

func (s *AlterEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, i)
}

func (s *AlterEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEDULE, 0)
}

func (s *AlterEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *AlterEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPLETION, 0)
}

func (s *AlterEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRESERVE, 0)
}

func (s *AlterEventContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *AlterEventContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *AlterEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *AlterEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *AlterEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AlterEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDO, 0)
}

func (s *AlterEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *AlterEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *AlterEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterEvent(s)
	}
}

func (s *AlterEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterEvent(s)
	}
}

func (s *AlterEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterEvent() (localctx IAlterEventContext) {
	localctx = NewAlterEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MariaDBParserRULE_alterEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2457)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(2458)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(2461)
		p.Match(MariaDBParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2462)
		p.FullId()
	}
	p.SetState(2466)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2463)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2464)
			p.Match(MariaDBParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2465)
			p.ScheduleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserON {
		{
			p.SetState(2468)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2469)
			p.Match(MariaDBParserCOMPLETION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNOT {
			{
				p.SetState(2470)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2473)
			p.Match(MariaDBParserPRESERVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2476)
			p.Match(MariaDBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2477)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2478)
			p.FullId()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDISABLE || _la == MariaDBParserENABLE {
		{
			p.SetState(2481)
			p.EnableType()
		}

	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMENT {
		{
			p.SetState(2484)
			p.Match(MariaDBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2485)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2490)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2488)
			p.Match(MariaDBParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2489)
			p.RoutineBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterFunction
	return p
}

func InitEmptyAlterFunctionContext(p *AlterFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterFunction
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *AlterFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (s *AlterFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterFunction() (localctx IAlterFunctionContext) {
	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MariaDBParserRULE_alterFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2492)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2493)
		p.Match(MariaDBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2494)
		p.FullId()
	}
	p.SetState(2498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserDETERMINISTIC || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&281474993487877) != 0) || _la == MariaDBParserCOMMENT || _la == MariaDBParserCONTAINS || _la == MariaDBParserLANGUAGE || _la == MariaDBParserNO {
		{
			p.SetState(2495)
			p.RoutineOption()
		}

		p.SetState(2500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterInstanceContext is an interface to support dynamic dispatch.
type IAlterInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsAlterInstanceContext differentiates from other interfaces.
	IsAlterInstanceContext()
}

type AlterInstanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterInstanceContext() *AlterInstanceContext {
	var p = new(AlterInstanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterInstance
	return p
}

func InitEmptyAlterInstanceContext(p *AlterInstanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterInstance
}

func (*AlterInstanceContext) IsAlterInstanceContext() {}

func NewAlterInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterInstanceContext {
	var p = new(AlterInstanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterInstance

	return p
}

func (s *AlterInstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterInstanceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterInstanceContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTANCE, 0)
}

func (s *AlterInstanceContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROTATE, 0)
}

func (s *AlterInstanceContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB, 0)
}

func (s *AlterInstanceContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *AlterInstanceContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterInstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterInstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterInstanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterInstance(s)
	}
}

func (s *AlterInstanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterInstance(s)
	}
}

func (s *AlterInstanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterInstance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterInstance() (localctx IAlterInstanceContext) {
	localctx = NewAlterInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MariaDBParserRULE_alterInstance)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2501)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.Match(MariaDBParserINSTANCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2503)
		p.Match(MariaDBParserROTATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2504)
		p.Match(MariaDBParserINNODB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2505)
		p.Match(MariaDBParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2506)
		p.Match(MariaDBParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLogfileGroupContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	INITIAL_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsAlterLogfileGroupContext differentiates from other interfaces.
	IsAlterLogfileGroupContext()
}

type AlterLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupContext() *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterLogfileGroup
	return p
}

func InitEmptyAlterLogfileGroupContext(p *AlterLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterLogfileGroup
}

func (*AlterLogfileGroupContext) IsAlterLogfileGroupContext() {}

func NewAlterLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterLogfileGroup

	return p
}

func (s *AlterLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGFILE, 0)
}

func (s *AlterLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *AlterLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDOFILE, 0)
}

func (s *AlterLogfileGroupContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AlterLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *AlterLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINITIAL_SIZE, 0)
}

func (s *AlterLogfileGroupContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *AlterLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *AlterLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *AlterLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterLogfileGroup() (localctx IAlterLogfileGroupContext) {
	localctx = NewAlterLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MariaDBParserRULE_alterLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2508)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2509)
		p.Match(MariaDBParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2510)
		p.Match(MariaDBParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2511)
		p.Uid()
	}
	{
		p.SetState(2512)
		p.Match(MariaDBParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2513)
		p.Match(MariaDBParserUNDOFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2514)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINITIAL_SIZE {
		{
			p.SetState(2515)
			p.Match(MariaDBParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2516)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2519)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWAIT {
		{
			p.SetState(2522)
			p.Match(MariaDBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2525)
		p.Match(MariaDBParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEQUAL_SYMBOL {
		{
			p.SetState(2526)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2529)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterProcedureContext is an interface to support dynamic dispatch.
type IAlterProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterProcedureContext differentiates from other interfaces.
	IsAlterProcedureContext()
}

type AlterProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProcedureContext() *AlterProcedureContext {
	var p = new(AlterProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterProcedure
	return p
}

func InitEmptyAlterProcedureContext(p *AlterProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterProcedure
}

func (*AlterProcedureContext) IsAlterProcedureContext() {}

func NewAlterProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProcedureContext {
	var p = new(AlterProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterProcedure

	return p
}

func (s *AlterProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *AlterProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterProcedure() (localctx IAlterProcedureContext) {
	localctx = NewAlterProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MariaDBParserRULE_alterProcedure)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2531)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2532)
		p.Match(MariaDBParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2533)
		p.FullId()
	}
	p.SetState(2537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserDETERMINISTIC || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&281474993487877) != 0) || _la == MariaDBParserCOMMENT || _la == MariaDBParserCONTAINS || _la == MariaDBParserLANGUAGE || _la == MariaDBParserNO {
		{
			p.SetState(2534)
			p.RoutineOption()
		}

		p.SetState(2539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterServerContext is an interface to support dynamic dispatch.
type IAlterServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterServerContext differentiates from other interfaces.
	IsAlterServerContext()
}

type AlterServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServerContext() *AlterServerContext {
	var p = new(AlterServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterServer
	return p
}

func InitEmptyAlterServerContext(p *AlterServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterServer
}

func (*AlterServerContext) IsAlterServerContext() {}

func NewAlterServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServerContext {
	var p = new(AlterServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterServer

	return p
}

func (s *AlterServerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERVER, 0)
}

func (s *AlterServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONS, 0)
}

func (s *AlterServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *AlterServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterServer(s)
	}
}

func (s *AlterServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterServer(s)
	}
}

func (s *AlterServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterServer() (localctx IAlterServerContext) {
	localctx = NewAlterServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MariaDBParserRULE_alterServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2540)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2541)
		p.Match(MariaDBParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2542)
		p.Uid()
	}
	{
		p.SetState(2543)
		p.Match(MariaDBParserOPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2544)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2545)
		p.ServerOption()
	}
	p.SetState(2550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(2546)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2547)
			p.ServerOption()
		}

		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2553)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IGNORE() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	AllAlterSpecification() []IAlterSpecificationContext
	AlterSpecification(i int) IAlterSpecificationContext
	PartitionDefinitions() IPartitionDefinitionsContext
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *AlterTableContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *AlterTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *AlterTableContext) AllAlterSpecification() []IAlterSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IAlterSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterSpecificationContext); ok {
			tst[i] = t.(IAlterSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterSpecification(i int) IAlterSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSpecificationContext)
}

func (s *AlterTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *AlterTableContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLINE, 0)
}

func (s *AlterTableContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFLINE, 0)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MariaDBParserRULE_alterTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOFFLINE || _la == MariaDBParserONLINE {
		{
			p.SetState(2556)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterTableContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserOFFLINE || _la == MariaDBParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterTableContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(2559)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2562)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2563)
		p.TableName()
	}
	p.SetState(2565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(2564)
			p.WaitNowaitClause()
		}

	}
	p.SetState(2575)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2567)
			p.AlterSpecification()
		}
		p.SetState(2572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2568)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2569)
				p.AlterSpecification()
			}

			p.SetState(2574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(2577)
			p.PartitionDefinitions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTablespaceContext is an interface to support dynamic dispatch.
type IAlterTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObjectAction returns the objectAction token.
	GetObjectAction() antlr.Token

	// SetObjectAction sets the objectAction token.
	SetObjectAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode

	// IsAlterTablespaceContext differentiates from other interfaces.
	IsAlterTablespaceContext()
}

type AlterTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	objectAction antlr.Token
}

func NewEmptyAlterTablespaceContext() *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterTablespace
	return p
}

func InitEmptyAlterTablespaceContext(p *AlterTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterTablespace
}

func (*AlterTablespaceContext) IsAlterTablespaceContext() {}

func NewAlterTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterTablespace

	return p
}

func (s *AlterTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceContext) GetObjectAction() antlr.Token { return s.objectAction }

func (s *AlterTablespaceContext) SetObjectAction(v antlr.Token) { s.objectAction = v }

func (s *AlterTablespaceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *AlterTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterTablespaceContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATAFILE, 0)
}

func (s *AlterTablespaceContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AlterTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *AlterTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterTablespaceContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterTablespaceContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINITIAL_SIZE, 0)
}

func (s *AlterTablespaceContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *AlterTablespaceContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *AlterTablespaceContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterTablespaceContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *AlterTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterTablespace() (localctx IAlterTablespaceContext) {
	localctx = NewAlterTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MariaDBParserRULE_alterTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2580)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2581)
		p.Match(MariaDBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2582)
		p.Uid()
	}
	{
		p.SetState(2583)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AlterTablespaceContext).objectAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserADD || _la == MariaDBParserDROP) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AlterTablespaceContext).objectAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2584)
		p.Match(MariaDBParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2585)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINITIAL_SIZE {
		{
			p.SetState(2586)
			p.Match(MariaDBParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2587)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2588)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWAIT {
		{
			p.SetState(2591)
			p.Match(MariaDBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2594)
		p.Match(MariaDBParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEQUAL_SYMBOL {
		{
			p.SetState(2595)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2598)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOpt returns the checkOpt token.
	GetCheckOpt() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOpt sets the checkOpt token.
	SetCheckOpt(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	algType    antlr.Token
	secContext antlr.Token
	checkOpt   antlr.Token
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterView
	return p
}

func InitEmptyAlterViewContext(p *AlterViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterView
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *AlterViewContext) GetCheckOpt() antlr.Token { return s.checkOpt }

func (s *AlterViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *AlterViewContext) SetCheckOpt(v antlr.Token) { s.checkOpt = v }

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *AlterViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *AlterViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AlterViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *AlterViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *AlterViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL, 0)
}

func (s *AlterViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECURITY, 0)
}

func (s *AlterViewContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterViewContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *AlterViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *AlterViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, 0)
}

func (s *AlterViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDEFINED, 0)
}

func (s *AlterViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMERGE, 0)
}

func (s *AlterViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPTABLE, 0)
}

func (s *AlterViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFINER, 0)
}

func (s *AlterViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKER, 0)
}

func (s *AlterViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADED, 0)
}

func (s *AlterViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterView() (localctx IAlterViewContext) {
	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MariaDBParserRULE_alterView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2600)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserALGORITHM {
		{
			p.SetState(2601)
			p.Match(MariaDBParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2602)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2603)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserMERGE || _la == MariaDBParserTEMPTABLE || _la == MariaDBParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFINER {
		{
			p.SetState(2606)
			p.OwnerStatement()
		}

	}
	p.SetState(2612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserSQL {
		{
			p.SetState(2609)
			p.Match(MariaDBParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2610)
			p.Match(MariaDBParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2611)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFINER || _la == MariaDBParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2614)
		p.Match(MariaDBParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2615)
		p.FullId()
	}
	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLR_BRACKET {
		{
			p.SetState(2616)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2617)
			p.UidList()
		}
		{
			p.SetState(2618)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2622)
		p.Match(MariaDBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.SelectStatement()
	}
	p.SetState(2630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWITH {
		{
			p.SetState(2624)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCASCADED || _la == MariaDBParserLOCAL {
			{
				p.SetState(2625)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterViewContext).checkOpt = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserCASCADED || _la == MariaDBParserLOCAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterViewContext).checkOpt = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2628)
			p.Match(MariaDBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2629)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSequenceContext is an interface to support dynamic dispatch.
type IAlterSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext
	AllSequenceSpec() []ISequenceSpecContext
	SequenceSpec(i int) ISequenceSpecContext

	// IsAlterSequenceContext differentiates from other interfaces.
	IsAlterSequenceContext()
}

type AlterSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSequenceContext() *AlterSequenceContext {
	var p = new(AlterSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterSequence
	return p
}

func InitEmptyAlterSequenceContext(p *AlterSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterSequence
}

func (*AlterSequenceContext) IsAlterSequenceContext() {}

func NewAlterSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSequenceContext {
	var p = new(AlterSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterSequence

	return p
}

func (s *AlterSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSequenceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEQUENCE, 0)
}

func (s *AlterSequenceContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterSequenceContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterSequenceContext) AllSequenceSpec() []ISequenceSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceSpecContext); ok {
			len++
		}
	}

	tst := make([]ISequenceSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceSpecContext); ok {
			tst[i] = t.(ISequenceSpecContext)
			i++
		}
	}

	return tst
}

func (s *AlterSequenceContext) SequenceSpec(i int) ISequenceSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceSpecContext)
}

func (s *AlterSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterSequence(s)
	}
}

func (s *AlterSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterSequence(s)
	}
}

func (s *AlterSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterSequence() (localctx IAlterSequenceContext) {
	localctx = NewAlterSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MariaDBParserRULE_alterSequence)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2632)
		p.Match(MariaDBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2633)
		p.Match(MariaDBParserSEQUENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2635)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2634)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2637)
		p.FullId()
	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2638)
				p.SequenceSpec()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2641)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSpecificationContext is an interface to support dynamic dispatch.
type IAlterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSpecificationContext differentiates from other interfaces.
	IsAlterSpecificationContext()
}

type AlterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSpecificationContext() *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterSpecification
	return p
}

func InitEmptyAlterSpecificationContext(p *AlterSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterSpecification
}

func (*AlterSpecificationContext) IsAlterSpecificationContext() {}

func NewAlterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterSpecification

	return p
}

func (s *AlterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSpecificationContext) CopyAll(ctx *AlterSpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterByDisableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByDisableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDisableKeysContext {
	var p = new(AlterByDisableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDisableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDisableKeysContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISABLE, 0)
}

func (s *AlterByDisableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEYS, 0)
}

func (s *AlterByDisableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDisableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDefaultCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByDefaultCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDefaultCharsetContext {
	var p = new(AlterByDefaultCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDefaultCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *AlterByDefaultCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *AlterByDefaultCharsetContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *AlterByDefaultCharsetContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *AlterByDefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByDefaultCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *AlterByDefaultCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *AlterByDefaultCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByDefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDefaultCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameColumnContext struct {
	AlterSpecificationContext
	oldColumn IUidContext
	newColumn IUidContext
}

func NewAlterByRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameColumnContext {
	var p = new(AlterByRenameColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByRenameColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByRenameColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByRenameColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByRenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *AlterByRenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByRenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *AlterByRenameColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRenameColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByConvertCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByConvertCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByConvertCharsetContext {
	var p = new(AlterByConvertCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByConvertCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByConvertCharsetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONVERT, 0)
}

func (s *AlterByConvertCharsetContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *AlterByConvertCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *AlterByConvertCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *AlterByConvertCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByConvertCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *AlterByConvertCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByConvertCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByConvertCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByAddPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPartitionContext {
	var p = new(AlterByAddPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPartitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByAddPartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByAddPartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddPartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterByAddPartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterByAddPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddForeignKeyContext struct {
	AlterSpecificationContext
	name      IUidContext
	indexName IUidContext
}

func NewAlterByAddForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddForeignKeyContext {
	var p = new(AlterByAddForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddForeignKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddForeignKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddForeignKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddForeignKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddForeignKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOREIGN, 0)
}

func (s *AlterByAddForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByAddForeignKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddForeignKeyContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *AlterByAddForeignKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *AlterByAddForeignKeyContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddForeignKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddForeignKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByRenameIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameIndexContext {
	var p = new(AlterByRenameIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByRenameIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByRenameIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameIndexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *AlterByRenameIndexContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameIndexContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameIndexContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *AlterByRenameIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByRenameIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByRenameIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRenameIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRemovePartitioningContext struct {
	AlterSpecificationContext
}

func NewAlterByRemovePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRemovePartitioningContext {
	var p = new(AlterByRemovePartitioningContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRemovePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRemovePartitioningContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREMOVE, 0)
}

func (s *AlterByRemovePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONING, 0)
}

func (s *AlterByRemovePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRemovePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameContext struct {
	AlterSpecificationContext
	renameFormat antlr.Token
}

func NewAlterByRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameContext {
	var p = new(AlterByRenameContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameContext) GetRenameFormat() antlr.Token { return s.renameFormat }

func (s *AlterByRenameContext) SetRenameFormat(v antlr.Token) { s.renameFormat = v }

func (s *AlterByRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *AlterByRenameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterByRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *AlterByRenameContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *AlterByRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRename(s)
	}
}

func (s *AlterByRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRename(s)
	}
}

func (s *AlterByRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRename(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByOptimizePartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByOptimizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOptimizePartitionContext {
	var p = new(AlterByOptimizePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOptimizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOptimizePartitionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIMIZE, 0)
}

func (s *AlterByOptimizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByOptimizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOptimizePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByOptimizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByOptimizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByImportTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByImportTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportTablespaceContext {
	var p = new(AlterByImportTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportTablespaceContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIMPORT, 0)
}

func (s *AlterByImportTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *AlterByImportTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByImportTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddDefinitionsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddDefinitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddDefinitionsContext {
	var p = new(AlterByAddDefinitionsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddDefinitionsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *AlterByAddDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByAddDefinitionsContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterByAddDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterByAddDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByCoalescePartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByCoalescePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCoalescePartitionContext {
	var p = new(AlterByCoalescePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByCoalescePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCoalescePartitionContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOALESCE, 0)
}

func (s *AlterByCoalescePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByCoalescePartitionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AlterByCoalescePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByCoalescePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropConstraintCheckContext struct {
	AlterSpecificationContext
}

func NewAlterByDropConstraintCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropConstraintCheckContext {
	var p = new(AlterByDropConstraintCheckContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropConstraintCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropConstraintCheckContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropConstraintCheckContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropConstraintCheckContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *AlterByDropConstraintCheckContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *AlterByDropConstraintCheckContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByDropConstraintCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropConstraintCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddColumnsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnsContext {
	var p = new(AlterByAddColumnsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddColumnsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnsContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByAddColumnsContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddColumnsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterByAddColumnsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterByAddColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAlterIndexVisibilityContext struct {
	AlterSpecificationContext
}

func NewAlterByAlterIndexVisibilityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterIndexVisibilityContext {
	var p = new(AlterByAlterIndexVisibilityContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterIndexVisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterIndexVisibilityContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByAlterIndexVisibilityContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterIndexVisibilityContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAlterIndexVisibility(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropForeignKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropForeignKeyContext {
	var p = new(AlterByDropForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropForeignKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOREIGN, 0)
}

func (s *AlterByDropForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByDropForeignKeyContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropForeignKeyContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByDropForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddCheckTableConstraintContext struct {
	AlterSpecificationContext
	name IUidContext
}

func NewAlterByAddCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddCheckTableConstraintContext {
	var p = new(AlterByAddCheckTableConstraintContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddCheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *AlterByAddCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddCheckTableConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *AlterByAddCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAddCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRebuildPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByRebuildPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRebuildPartitionContext {
	var p = new(AlterByRebuildPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRebuildPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRebuildPartitionContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREBUILD, 0)
}

func (s *AlterByRebuildPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByRebuildPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRebuildPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByRebuildPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRebuildPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByUpgradePartitioningContext struct {
	AlterSpecificationContext
}

func NewAlterByUpgradePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByUpgradePartitioningContext {
	var p = new(AlterByUpgradePartitioningContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByUpgradePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByUpgradePartitioningContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPGRADE, 0)
}

func (s *AlterByUpgradePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONING, 0)
}

func (s *AlterByUpgradePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByUpgradePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRepairPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByRepairPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRepairPartitionContext {
	var p = new(AlterByRepairPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRepairPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRepairPartitionContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPAIR, 0)
}

func (s *AlterByRepairPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByRepairPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRepairPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByRepairPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByRepairPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByExchangePartitionContext struct {
	AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByExchangePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByExchangePartitionContext {
	var p = new(AlterByExchangePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByExchangePartitionContext) GetValidationFormat() antlr.Token {
	return s.validationFormat
}

func (s *AlterByExchangePartitionContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByExchangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByExchangePartitionContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCHANGE, 0)
}

func (s *AlterByExchangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByExchangePartitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByExchangePartitionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserWITH)
}

func (s *AlterByExchangePartitionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, i)
}

func (s *AlterByExchangePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *AlterByExchangePartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterByExchangePartitionContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALIDATION, 0)
}

func (s *AlterByExchangePartitionContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITHOUT, 0)
}

func (s *AlterByExchangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByExchangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddIndexContext {
	var p = new(AlterByAddIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByAddIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByAddIndexContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropColumnContext {
	var p = new(AlterByDropColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropColumnContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByDropColumnContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByDropColumnContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTRICT, 0)
}

func (s *AlterByDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByImportPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByImportPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportPartitionContext {
	var p = new(AlterByImportPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportPartitionContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIMPORT, 0)
}

func (s *AlterByImportPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByImportPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *AlterByImportPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByImportPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByImportPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByImportPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByChangeDefaultContext struct {
	AlterSpecificationContext
}

func NewAlterByChangeDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeDefaultContext {
	var p = new(AlterByChangeDefaultContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterByChangeDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *AlterByChangeDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *AlterByChangeDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AlterByChangeDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByChangeDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByChangeDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByChangeDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByForceContext struct {
	AlterSpecificationContext
}

func NewAlterByForceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByForceContext {
	var p = new(AlterByForceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByForceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByForceContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFORCE, 0)
}

func (s *AlterByForceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByForce(s)
	}
}

func (s *AlterByForceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByForce(s)
	}
}

func (s *AlterByForceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByForce(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPartitionContext {
	var p = new(AlterByDropPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByDropPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDropPartitionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddSpecialIndexContext struct {
	AlterSpecificationContext
	keyType     antlr.Token
	indexFormat antlr.Token
}

func NewAlterByAddSpecialIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddSpecialIndexContext {
	var p = new(AlterByAddSpecialIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddSpecialIndexContext) GetKeyType() antlr.Token { return s.keyType }

func (s *AlterByAddSpecialIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddSpecialIndexContext) SetKeyType(v antlr.Token) { s.keyType = v }

func (s *AlterByAddSpecialIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddSpecialIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddSpecialIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddSpecialIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddSpecialIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULLTEXT, 0)
}

func (s *AlterByAddSpecialIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSPATIAL, 0)
}

func (s *AlterByAddSpecialIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddSpecialIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddSpecialIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddSpecialIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByAddSpecialIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByAddSpecialIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddSpecialIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByModifyColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByModifyColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByModifyColumnContext {
	var p = new(AlterByModifyColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByModifyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByModifyColumnContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODIFY, 0)
}

func (s *AlterByModifyColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByModifyColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByModifyColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByModifyColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByModifyColumnContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByModifyColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *AlterByModifyColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAFTER, 0)
}

func (s *AlterByModifyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByModifyColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByTableOptionContext struct {
	AlterSpecificationContext
}

func NewAlterByTableOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTableOptionContext {
	var p = new(AlterByTableOptionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTableOptionContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByTableOptionContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *AlterByTableOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterByTableOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterByTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropPrimaryKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPrimaryKeyContext {
	var p = new(AlterByDropPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPrimaryKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIMARY, 0)
}

func (s *AlterByDropPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByDropPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByLockContext struct {
	AlterSpecificationContext
	lockType antlr.Token
}

func NewAlterByLockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByLockContext {
	var p = new(AlterByLockContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByLockContext) GetLockType() antlr.Token { return s.lockType }

func (s *AlterByLockContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *AlterByLockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByLockContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *AlterByLockContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *AlterByLockContext) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *AlterByLockContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARED, 0)
}

func (s *AlterByLockContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLUSIVE, 0)
}

func (s *AlterByLockContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *AlterByLockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByLock(s)
	}
}

func (s *AlterByLockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByLock(s)
	}
}

func (s *AlterByLockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByLock(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDiscardPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByDiscardPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardPartitionContext {
	var p = new(AlterByDiscardPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardPartitionContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISCARD, 0)
}

func (s *AlterByDiscardPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByDiscardPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *AlterByDiscardPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDiscardPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByDiscardPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDiscardPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDiscardTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByDiscardTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardTablespaceContext {
	var p = new(AlterByDiscardTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardTablespaceContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISCARD, 0)
}

func (s *AlterByDiscardTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *AlterByDiscardTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDiscardTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByValidateContext struct {
	AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByValidateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByValidateContext {
	var p = new(AlterByValidateContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByValidateContext) GetValidationFormat() antlr.Token { return s.validationFormat }

func (s *AlterByValidateContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByValidateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByValidateContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALIDATION, 0)
}

func (s *AlterByValidateContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITHOUT, 0)
}

func (s *AlterByValidateContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *AlterByValidateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByValidate(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddPrimaryKeyContext struct {
	AlterSpecificationContext
	name  IUidContext
	index IUidContext
}

func NewAlterByAddPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPrimaryKeyContext {
	var p = new(AlterByAddPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddPrimaryKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddPrimaryKeyContext) GetIndex() IUidContext { return s.index }

func (s *AlterByAddPrimaryKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddPrimaryKeyContext) SetIndex(v IUidContext) { s.index = v }

func (s *AlterByAddPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPrimaryKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIMARY, 0)
}

func (s *AlterByAddPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddPrimaryKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddPrimaryKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddPrimaryKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByCheckPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByCheckPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCheckPartitionContext {
	var p = new(AlterByCheckPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByCheckPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCheckPartitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *AlterByCheckPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByCheckPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByCheckPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByCheckPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByCheckPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByEnableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByEnableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByEnableKeysContext {
	var p = new(AlterByEnableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByEnableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByEnableKeysContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENABLE, 0)
}

func (s *AlterByEnableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEYS, 0)
}

func (s *AlterByEnableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByEnableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByReorganizePartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByReorganizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByReorganizePartitionContext {
	var p = new(AlterByReorganizePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByReorganizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByReorganizePartitionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREORGANIZE, 0)
}

func (s *AlterByReorganizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByReorganizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByReorganizePartitionContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *AlterByReorganizePartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByReorganizePartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByReorganizePartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterByReorganizePartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterByReorganizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByReorganizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterBySetAlgorithmContext struct {
	AlterSpecificationContext
	algType antlr.Token
}

func NewAlterBySetAlgorithmContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterBySetAlgorithmContext {
	var p = new(AlterBySetAlgorithmContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterBySetAlgorithmContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterBySetAlgorithmContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterBySetAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterBySetAlgorithmContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *AlterBySetAlgorithmContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *AlterBySetAlgorithmContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTANT, 0)
}

func (s *AlterBySetAlgorithmContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINPLACE, 0)
}

func (s *AlterBySetAlgorithmContext) COPY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOPY, 0)
}

func (s *AlterBySetAlgorithmContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *AlterBySetAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterBySetAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAnalyzePartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByAnalyzePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAnalyzePartitionContext {
	var p = new(AlterByAnalyzePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAnalyzePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAnalyzePartitionContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserANALYZE, 0)
}

func (s *AlterByAnalyzePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByAnalyzePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByAnalyzePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByAnalyzePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAnalyzePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByChangeColumnContext struct {
	AlterSpecificationContext
	oldColumn   IUidContext
	newColumn   IUidContext
	afterColumn IUidContext
}

func NewAlterByChangeColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeColumnContext {
	var p = new(AlterByChangeColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByChangeColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByChangeColumnContext) GetAfterColumn() IUidContext { return s.afterColumn }

func (s *AlterByChangeColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByChangeColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByChangeColumnContext) SetAfterColumn(v IUidContext) { s.afterColumn = v }

func (s *AlterByChangeColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANGE, 0)
}

func (s *AlterByChangeColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByChangeColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByChangeColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByChangeColumnContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByChangeColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *AlterByChangeColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAFTER, 0)
}

func (s *AlterByChangeColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByChangeColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddUniqueKeyContext struct {
	AlterSpecificationContext
	name        IUidContext
	indexFormat antlr.Token
	indexName   IUidContext
}

func NewAlterByAddUniqueKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddUniqueKeyContext {
	var p = new(AlterByAddUniqueKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddUniqueKeyContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddUniqueKeyContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddUniqueKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddUniqueKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddUniqueKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddUniqueKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddUniqueKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddUniqueKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddUniqueKeyContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNIQUE, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddUniqueKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT, 0)
}

func (s *AlterByAddUniqueKeyContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddUniqueKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddUniqueKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddUniqueKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddUniqueKeyContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByAddUniqueKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByAddUniqueKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddUniqueKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByTruncatePartitionContext struct {
	AlterSpecificationContext
}

func NewAlterByTruncatePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTruncatePartitionContext {
	var p = new(AlterByTruncatePartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTruncatePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTruncatePartitionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRUNCATE, 0)
}

func (s *AlterByTruncatePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AlterByTruncatePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByTruncatePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AlterByTruncatePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByTruncatePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropIndexContext {
	var p = new(AlterByDropIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByDropIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AlterByDropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *AlterByDropIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *AlterByDropIndexContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterByDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnContext {
	var p = new(AlterByAddColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADD, 0)
}

func (s *AlterByAddColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN, 0)
}

func (s *AlterByAddColumnContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *AlterByAddColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *AlterByAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAFTER, 0)
}

func (s *AlterByAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByAddColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByOrderContext struct {
	AlterSpecificationContext
}

func NewAlterByOrderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOrderContext {
	var p = new(AlterByOrderContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDER, 0)
}

func (s *AlterByOrderContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *AlterByOrderContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterByOrder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterSpecification() (localctx IAlterSpecificationContext) {
	localctx = NewAlterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MariaDBParserRULE_alterSpecification)
	var _la int

	var _alt int

	p.SetState(3066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 402, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterByTableOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2643)
			p.TableOption()
		}
		p.SetState(2650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2645)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserCOMMA {
					{
						p.SetState(2644)
						p.Match(MariaDBParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(2647)
					p.TableOption()
				}

			}
			p.SetState(2652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAlterByAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2653)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2654)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2658)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2657)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2660)
			p.Uid()
		}
		{
			p.SetState(2661)
			p.ColumnDefinition()
		}
		p.SetState(2665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserFIRST:
			{
				p.SetState(2662)
				p.Match(MariaDBParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserAFTER:
			{
				p.SetState(2663)
				p.Match(MariaDBParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2664)
				p.Uid()
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPARTITION, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserCOMMA, MariaDBParserSEMI:

		default:
		}

	case 3:
		localctx = NewAlterByAddColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2667)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2668)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIF {
			{
				p.SetState(2671)
				p.IfNotExists()
			}

		}
		{
			p.SetState(2674)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2675)
			p.Uid()
		}
		{
			p.SetState(2676)
			p.ColumnDefinition()
		}
		p.SetState(2683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2677)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2678)
				p.Uid()
			}
			{
				p.SetState(2679)
				p.ColumnDefinition()
			}

			p.SetState(2685)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2686)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAlterByAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2688)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2689)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2690)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(2693)
				p.Uid()
			}

		}
		p.SetState(2697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(2696)
				p.IndexType()
			}

		}
		{
			p.SetState(2699)
			p.IndexColumnNames()
		}
		p.SetState(2703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(2700)
				p.IndexOption()
			}

			p.SetState(2705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		localctx = NewAlterByAddPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2706)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(2707)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2709)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2708)

					var _x = p.Uid()

					localctx.(*AlterByAddPrimaryKeyContext).name = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(2713)
			p.Match(MariaDBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2714)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(2715)

				var _x = p.Uid()

				localctx.(*AlterByAddPrimaryKeyContext).index = _x
			}

		}
		p.SetState(2719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(2718)
				p.IndexType()
			}

		}
		{
			p.SetState(2721)
			p.IndexColumnNames()
		}
		p.SetState(2725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(2722)
				p.IndexOption()
			}

			p.SetState(2727)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 6:
		localctx = NewAlterByAddUniqueKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2728)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(2729)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(2730)

					var _x = p.Uid()

					localctx.(*AlterByAddUniqueKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2735)
			p.Match(MariaDBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2737)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2736)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(2739)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddUniqueKeyContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddUniqueKeyContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(2742)

				var _x = p.Uid()

				localctx.(*AlterByAddUniqueKeyContext).indexName = _x
			}

		}
		p.SetState(2746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(2745)
				p.IndexType()
			}

		}
		{
			p.SetState(2748)
			p.IndexColumnNames()
		}
		p.SetState(2752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(2749)
				p.IndexOption()
			}

			p.SetState(2754)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 7:
		localctx = NewAlterByAddSpecialIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2755)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2756)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddSpecialIndexContext).keyType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFULLTEXT || _la == MariaDBParserSPATIAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddSpecialIndexContext).keyType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(2757)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddSpecialIndexContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddSpecialIndexContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(2760)
				p.Uid()
			}

		}
		{
			p.SetState(2763)
			p.IndexColumnNames()
		}
		p.SetState(2767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserIGNORED || _la == MariaDBParserNOT || _la == MariaDBParserUSING || _la == MariaDBParserWITH || _la == MariaDBParserCLUSTERING || _la == MariaDBParserCOMMENT || _la == MariaDBParserINVISIBLE || _la == MariaDBParserKEY_BLOCK_SIZE || _la == MariaDBParserVISIBLE || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(2764)
				p.IndexOption()
			}

			p.SetState(2769)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 8:
		localctx = NewAlterByAddForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2770)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(2771)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2773)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(2772)

					var _x = p.Uid()

					localctx.(*AlterByAddForeignKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2777)
			p.Match(MariaDBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2778)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2780)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2779)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(2782)

				var _x = p.Uid()

				localctx.(*AlterByAddForeignKeyContext).indexName = _x
			}

		}
		{
			p.SetState(2785)
			p.IndexColumnNames()
		}
		{
			p.SetState(2786)
			p.ReferenceDefinition()
		}

	case 9:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2788)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCONSTRAINT {
			{
				p.SetState(2789)
				p.Match(MariaDBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2791)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
				{
					p.SetState(2790)

					var _x = p.Uid()

					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2795)
			p.Match(MariaDBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2796)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2797)
			p.expression(0)
		}
		{
			p.SetState(2798)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewAlterBySetAlgorithmContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2800)
			p.Match(MariaDBParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2801)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2804)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterBySetAlgorithmContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserCOPY || _la == MariaDBParserINPLACE || _la == MariaDBParserINSTANT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterBySetAlgorithmContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewAlterByChangeDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2805)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2806)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2809)
			p.Uid()
		}
		p.SetState(2815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserSET:
			{
				p.SetState(2810)
				p.Match(MariaDBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2811)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2812)
				p.DefaultValue()
			}

		case MariaDBParserDROP:
			{
				p.SetState(2813)
				p.Match(MariaDBParserDROP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2814)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 12:
		localctx = NewAlterByChangeColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2817)
			p.Match(MariaDBParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2818)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2822)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2821)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2824)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).oldColumn = _x
		}
		{
			p.SetState(2825)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).newColumn = _x
		}
		{
			p.SetState(2826)
			p.ColumnDefinition()
		}
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserFIRST:
			{
				p.SetState(2827)
				p.Match(MariaDBParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserAFTER:
			{
				p.SetState(2828)
				p.Match(MariaDBParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2829)

				var _x = p.Uid()

				localctx.(*AlterByChangeColumnContext).afterColumn = _x
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPARTITION, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserCOMMA, MariaDBParserSEMI:

		default:
		}

	case 13:
		localctx = NewAlterByRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2832)
			p.Match(MariaDBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2833)
			p.Match(MariaDBParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2834)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).oldColumn = _x
		}
		{
			p.SetState(2835)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2836)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).newColumn = _x
		}

	case 14:
		localctx = NewAlterByLockContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2838)
			p.Match(MariaDBParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(2839)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2842)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByLockContext).lockType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserEXCLUSIVE || _la == MariaDBParserNONE || _la == MariaDBParserSHARED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByLockContext).lockType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 15:
		localctx = NewAlterByModifyColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2843)
			p.Match(MariaDBParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2844)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2848)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 373, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2847)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2850)
			p.Uid()
		}
		{
			p.SetState(2851)
			p.ColumnDefinition()
		}
		p.SetState(2855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserFIRST:
			{
				p.SetState(2852)
				p.Match(MariaDBParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserAFTER:
			{
				p.SetState(2853)
				p.Match(MariaDBParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2854)
				p.Uid()
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPARTITION, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserCOMMA, MariaDBParserSEMI:

		default:
		}

	case 16:
		localctx = NewAlterByDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2857)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(2858)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2862)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2861)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2864)
			p.Uid()
		}
		p.SetState(2866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserRESTRICT {
			{
				p.SetState(2865)
				p.Match(MariaDBParserRESTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 17:
		localctx = NewAlterByDropConstraintCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2868)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2869)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCHECK || _la == MariaDBParserCONSTRAINT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2870)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2873)
			p.Uid()
		}

	case 18:
		localctx = NewAlterByDropPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2874)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2875)
			p.Match(MariaDBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2876)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewAlterByDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2877)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2878)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByDropIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByDropIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2880)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2879)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2882)
			p.Uid()
		}

	case 20:
		localctx = NewAlterByRenameIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2883)
			p.Match(MariaDBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2884)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByRenameIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByRenameIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2885)
			p.Uid()
		}
		{
			p.SetState(2886)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2887)
			p.Uid()
		}

	case 21:
		localctx = NewAlterByAlterIndexVisibilityContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2889)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2890)
			p.Match(MariaDBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2891)
			p.Uid()
		}
		{
			p.SetState(2892)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINVISIBLE || _la == MariaDBParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 22:
		localctx = NewAlterByDropForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2894)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2895)
			p.Match(MariaDBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2896)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2898)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2897)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2900)
			p.Uid()
		}

	case 23:
		localctx = NewAlterByDisableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2901)
			p.Match(MariaDBParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2902)
			p.Match(MariaDBParserKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewAlterByEnableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2903)
			p.Match(MariaDBParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.Match(MariaDBParserKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewAlterByRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2905)
			p.Match(MariaDBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS || _la == MariaDBParserTO {
			{
				p.SetState(2906)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByRenameContext).renameFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserAS || _la == MariaDBParserTO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByRenameContext).renameFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2909)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2910)
				p.FullId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 26:
		localctx = NewAlterByOrderContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2913)
			p.Match(MariaDBParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2914)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2915)
			p.UidList()
		}

	case 27:
		localctx = NewAlterByConvertCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2916)
			p.Match(MariaDBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2917)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2918)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2919)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2920)
			p.CharsetName()
		}
		p.SetState(2923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLLATE {
			{
				p.SetState(2921)
				p.Match(MariaDBParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2922)
				p.CollationName()
			}

		}

	case 28:
		localctx = NewAlterByDefaultCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		p.SetState(2926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT {
			{
				p.SetState(2925)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2928)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2929)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2930)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2931)
			p.CharsetName()
		}
		p.SetState(2935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLLATE {
			{
				p.SetState(2932)
				p.Match(MariaDBParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2933)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2934)
				p.CollationName()
			}

		}

	case 29:
		localctx = NewAlterByDiscardTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2937)
			p.Match(MariaDBParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2938)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		localctx = NewAlterByImportTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2939)
			p.Match(MariaDBParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2940)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		localctx = NewAlterByForceContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2941)
			p.Match(MariaDBParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		localctx = NewAlterByValidateContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2942)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByValidateContext).validationFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserWITH || _la == MariaDBParserWITHOUT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByValidateContext).validationFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2943)
			p.Match(MariaDBParserVALIDATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewAlterByAddPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2944)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2945)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIF {
			{
				p.SetState(2946)
				p.IfNotExists()
			}

		}
		{
			p.SetState(2949)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2950)
			p.PartitionDefinition()
		}
		p.SetState(2955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2951)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2952)
				p.PartitionDefinition()
			}

			p.SetState(2957)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2958)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewAlterByDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2960)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2963)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2962)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2965)
			p.UidList()
		}

	case 35:
		localctx = NewAlterByDiscardPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2966)
			p.Match(MariaDBParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2967)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(2968)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(2969)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2972)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewAlterByImportPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2973)
			p.Match(MariaDBParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(2975)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(2976)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2979)
			p.Match(MariaDBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		localctx = NewAlterByTruncatePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2980)
			p.Match(MariaDBParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(2982)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(2983)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 38:
		localctx = NewAlterByCoalescePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2986)
			p.Match(MariaDBParserCOALESCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2987)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2988)
			p.DecimalLiteral()
		}

	case 39:
		localctx = NewAlterByReorganizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2989)
			p.Match(MariaDBParserREORGANIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2990)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2991)
			p.UidList()
		}
		{
			p.SetState(2992)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2993)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2994)
			p.PartitionDefinition()
		}
		p.SetState(2999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(2995)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2996)
				p.PartitionDefinition()
			}

			p.SetState(3001)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3002)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		localctx = NewAlterByExchangePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(3004)
			p.Match(MariaDBParserEXCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3005)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3006)
			p.Uid()
		}
		{
			p.SetState(3007)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3008)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3009)
			p.TableName()
		}
		p.SetState(3012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH || _la == MariaDBParserWITHOUT {
			{
				p.SetState(3010)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByExchangePartitionContext).validationFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserWITH || _la == MariaDBParserWITHOUT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByExchangePartitionContext).validationFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3011)
				p.Match(MariaDBParserVALIDATION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 41:
		localctx = NewAlterByAnalyzePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(3014)
			p.Match(MariaDBParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3015)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(3016)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(3017)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 42:
		localctx = NewAlterByCheckPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(3020)
			p.Match(MariaDBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(3022)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(3023)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 43:
		localctx = NewAlterByOptimizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(3026)
			p.Match(MariaDBParserOPTIMIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3027)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(3028)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(3029)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 44:
		localctx = NewAlterByRebuildPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(3032)
			p.Match(MariaDBParserREBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3033)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(3034)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(3035)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 45:
		localctx = NewAlterByRepairPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(3038)
			p.Match(MariaDBParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3039)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(3040)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(3041)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 46:
		localctx = NewAlterByRemovePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(3044)
			p.Match(MariaDBParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3045)
			p.Match(MariaDBParserPARTITIONING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		localctx = NewAlterByUpgradePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(3046)
			p.Match(MariaDBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3047)
			p.Match(MariaDBParserPARTITIONING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		localctx = NewAlterByAddDefinitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(3048)
			p.Match(MariaDBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOLUMN {
			{
				p.SetState(3049)
				p.Match(MariaDBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIF {
			{
				p.SetState(3052)
				p.IfNotExists()
			}

		}
		{
			p.SetState(3055)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3056)
			p.CreateDefinition()
		}
		p.SetState(3061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3057)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3058)
				p.CreateDefinition()
			}

			p.SetState(3063)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3064)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropDatabase
	return p
}

func InitEmptyDropDatabaseContext(p *DropDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropDatabase
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *DropDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropDatabase() (localctx IDropDatabaseContext) {
	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MariaDBParserRULE_dropDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3068)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3069)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDATABASE || _la == MariaDBParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 403, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3070)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3073)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropEventContext is an interface to support dynamic dispatch.
type IDropEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropEventContext differentiates from other interfaces.
	IsDropEventContext()
}

type DropEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropEventContext() *DropEventContext {
	var p = new(DropEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropEvent
	return p
}

func InitEmptyDropEventContext(p *DropEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropEvent
}

func (*DropEventContext) IsDropEventContext() {}

func NewDropEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropEventContext {
	var p = new(DropEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropEvent

	return p
}

func (s *DropEventContext) GetParser() antlr.Parser { return s.parser }

func (s *DropEventContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *DropEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropEventContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropEvent(s)
	}
}

func (s *DropEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropEvent(s)
	}
}

func (s *DropEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropEvent() (localctx IDropEventContext) {
	localctx = NewDropEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MariaDBParserRULE_dropEvent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3075)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3076)
		p.Match(MariaDBParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 404, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3077)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3080)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	IfExists() IIfExistsContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
	algType      antlr.Token
	lockType     antlr.Token
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *DropIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *DropIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *DropIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *DropIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *DropIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *DropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *DropIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropIndexContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserALGORITHM)
}

func (s *DropIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, i)
}

func (s *DropIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLOCK)
}

func (s *DropIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, i)
}

func (s *DropIndexContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *DropIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLINE, 0)
}

func (s *DropIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFLINE, 0)
}

func (s *DropIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserDEFAULT)
}

func (s *DropIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, i)
}

func (s *DropIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserINPLACE)
}

func (s *DropIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserINPLACE, i)
}

func (s *DropIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOPY)
}

func (s *DropIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOPY, i)
}

func (s *DropIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNONE)
}

func (s *DropIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, i)
}

func (s *DropIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSHARED)
}

func (s *DropIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARED, i)
}

func (s *DropIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEXCLUSIVE)
}

func (s *DropIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLUSIVE, i)
}

func (s *DropIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *DropIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MariaDBParserRULE_dropIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3082)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3083)
		p.Match(MariaDBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3085)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3084)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3087)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserOFFLINE || _la == MariaDBParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3090)
		p.Uid()
	}
	{
		p.SetState(3091)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3092)
		p.TableName()
	}
	p.SetState(3105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3103)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserALGORITHM:
				{
					p.SetState(3093)
					p.Match(MariaDBParserALGORITHM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3095)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserEQUAL_SYMBOL {
					{
						p.SetState(3094)
						p.Match(MariaDBParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3097)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserCOPY || _la == MariaDBParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MariaDBParserLOCK:
				{
					p.SetState(3098)
					p.Match(MariaDBParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3100)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserEQUAL_SYMBOL {
					{
						p.SetState(3099)
						p.Match(MariaDBParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3102)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserEXCLUSIVE || _la == MariaDBParserNONE || _la == MariaDBParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(3108)
			p.WaitNowaitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropLogfileGroupContext is an interface to support dynamic dispatch.
type IDropLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EngineName() IEngineNameContext

	// IsDropLogfileGroupContext differentiates from other interfaces.
	IsDropLogfileGroupContext()
}

type DropLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupContext() *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropLogfileGroup
	return p
}

func InitEmptyDropLogfileGroupContext(p *DropLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropLogfileGroup
}

func (*DropLogfileGroupContext) IsDropLogfileGroupContext() {}

func NewDropLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropLogfileGroup

	return p
}

func (s *DropLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGFILE, 0)
}

func (s *DropLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *DropLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *DropLogfileGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropLogfileGroup() (localctx IDropLogfileGroupContext) {
	localctx = NewDropLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MariaDBParserRULE_dropLogfileGroup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3111)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3112)
		p.Match(MariaDBParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3113)
		p.Match(MariaDBParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3114)
		p.Uid()
	}
	{
		p.SetState(3115)
		p.Match(MariaDBParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3116)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3117)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropProcedure
	return p
}

func InitEmptyDropProcedureContext(p *DropProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropProcedure
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *DropProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropProcedureContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropProcedure() (localctx IDropProcedureContext) {
	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MariaDBParserRULE_dropProcedure)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3119)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3120)
		p.Match(MariaDBParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3122)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3121)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3124)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *DropFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MariaDBParserRULE_dropFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3126)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3127)
		p.Match(MariaDBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3129)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3128)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3131)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropServerContext is an interface to support dynamic dispatch.
type IDropServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	IfExists() IIfExistsContext

	// IsDropServerContext differentiates from other interfaces.
	IsDropServerContext()
}

type DropServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServerContext() *DropServerContext {
	var p = new(DropServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropServer
	return p
}

func InitEmptyDropServerContext(p *DropServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropServer
}

func (*DropServerContext) IsDropServerContext() {}

func NewDropServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServerContext {
	var p = new(DropServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropServer

	return p
}

func (s *DropServerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERVER, 0)
}

func (s *DropServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropServerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropServer(s)
	}
}

func (s *DropServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropServer(s)
	}
}

func (s *DropServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropServer() (localctx IDropServerContext) {
	localctx = NewDropServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MariaDBParserRULE_dropServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3133)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3134)
		p.Match(MariaDBParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3135)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3138)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext
	WaitNowaitClause() IWaitNowaitClauseContext
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropTableContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *DropTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DropTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *DropTableContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTRICT, 0)
}

func (s *DropTableContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADE, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MariaDBParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3140)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserTEMPORARY {
		{
			p.SetState(3141)
			p.Match(MariaDBParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3144)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3146)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3145)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3148)
		p.Tables()
	}
	p.SetState(3150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(3149)
			p.WaitNowaitClause()
		}

	}
	p.SetState(3153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCASCADE || _la == MariaDBParserRESTRICT {
		{
			p.SetState(3152)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropTableContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCASCADE || _la == MariaDBParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropTableContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTablespaceContext is an interface to support dynamic dispatch.
type IDropTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	EQUAL_SYMBOL() antlr.TerminalNode

	// IsDropTablespaceContext differentiates from other interfaces.
	IsDropTablespaceContext()
}

type DropTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTablespaceContext() *DropTablespaceContext {
	var p = new(DropTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTablespace
	return p
}

func InitEmptyDropTablespaceContext(p *DropTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTablespace
}

func (*DropTablespaceContext) IsDropTablespaceContext() {}

func NewDropTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTablespaceContext {
	var p = new(DropTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropTablespace

	return p
}

func (s *DropTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *DropTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *DropTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *DropTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropTablespace(s)
	}
}

func (s *DropTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropTablespace(s)
	}
}

func (s *DropTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropTablespace() (localctx IDropTablespaceContext) {
	localctx = NewDropTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MariaDBParserRULE_dropTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3156)
		p.Match(MariaDBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3157)
		p.Uid()
	}
	p.SetState(3163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserENGINE {
		{
			p.SetState(3158)
			p.Match(MariaDBParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEQUAL_SYMBOL {
			{
				p.SetState(3159)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3162)
			p.EngineName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGER, 0)
}

func (s *DropTriggerContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropTriggerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (s *DropTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MariaDBParserRULE_dropTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3165)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3166)
		p.Match(MariaDBParserTRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3167)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3170)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropView
	return p
}

func InitEmptyDropViewContext(p *DropViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropView
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropViewContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *DropViewContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *DropViewContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DropViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DropViewContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTRICT, 0)
}

func (s *DropViewContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADE, 0)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropView() (localctx IDropViewContext) {
	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MariaDBParserRULE_dropView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3172)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3173)
		p.Match(MariaDBParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3175)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3174)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3177)
		p.FullId()
	}
	p.SetState(3182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3178)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3179)
			p.FullId()
		}

		p.SetState(3184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCASCADE || _la == MariaDBParserRESTRICT {
		{
			p.SetState(3185)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropViewContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCASCADE || _la == MariaDBParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropViewContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *DropRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *DropRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *DropRoleContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DropRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MariaDBParserRULE_dropRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3189)
		p.Match(MariaDBParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3191)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3190)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3193)
		p.RoleName()
	}
	p.SetState(3198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3194)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3195)
			p.RoleName()
		}

		p.SetState(3200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RoleOption() IRoleOptionContext

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetRoleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *SetRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *SetRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *SetRoleContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetRoleContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SetRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SetRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SetRoleContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MariaDBParserRULE_setRole)
	var _la int

	p.SetState(3234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3201)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3202)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3203)
			p.Match(MariaDBParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3214)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3204)
				p.Match(MariaDBParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3205)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(3206)
				p.RoleName()
			}
			p.SetState(3211)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(3207)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3208)
					p.RoleName()
				}

				p.SetState(3213)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3216)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 429, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3217)
				p.UserName()
			}

		case 2:
			{
				p.SetState(3218)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3221)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3224)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3222)
					p.UserName()
				}

			case 2:
				{
					p.SetState(3223)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(3230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3231)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3232)
			p.Match(MariaDBParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3233)
			p.RoleOption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSequenceContext is an interface to support dynamic dispatch.
type IDropSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext
	COMMENT_INPUT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropSequenceContext differentiates from other interfaces.
	IsDropSequenceContext()
}

type DropSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSequenceContext() *DropSequenceContext {
	var p = new(DropSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropSequence
	return p
}

func InitEmptyDropSequenceContext(p *DropSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropSequence
}

func (*DropSequenceContext) IsDropSequenceContext() {}

func NewDropSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSequenceContext {
	var p = new(DropSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropSequence

	return p
}

func (s *DropSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSequenceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEQUENCE, 0)
}

func (s *DropSequenceContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *DropSequenceContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropSequenceContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *DropSequenceContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropSequenceContext) COMMENT_INPUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT_INPUT, 0)
}

func (s *DropSequenceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DropSequenceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DropSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropSequence(s)
	}
}

func (s *DropSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropSequence(s)
	}
}

func (s *DropSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropSequence() (localctx IDropSequenceContext) {
	localctx = NewDropSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MariaDBParserRULE_dropSequence)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3236)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserTEMPORARY {
		{
			p.SetState(3237)
			p.Match(MariaDBParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3240)
		p.Match(MariaDBParserSEQUENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3242)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3241)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMENT_INPUT {
		{
			p.SetState(3244)
			p.Match(MariaDBParserCOMMENT_INPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3247)
		p.FullId()
	}
	p.SetState(3252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3248)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3249)
			p.FullId()
		}

		p.SetState(3254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTableContext is an interface to support dynamic dispatch.
type IRenameTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllRenameTableClause() []IRenameTableClauseContext
	RenameTableClause(i int) IRenameTableClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameTableContext differentiates from other interfaces.
	IsRenameTableContext()
}

type RenameTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableContext() *RenameTableContext {
	var p = new(RenameTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameTable
	return p
}

func InitEmptyRenameTableContext(p *RenameTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameTable
}

func (*RenameTableContext) IsRenameTableContext() {}

func NewRenameTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableContext {
	var p = new(RenameTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_renameTable

	return p
}

func (s *RenameTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *RenameTableContext) AllRenameTableClause() []IRenameTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameTableClauseContext); ok {
			tst[i] = t.(IRenameTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) RenameTableClause(i int) IRenameTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableClauseContext)
}

func (s *RenameTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RenameTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (s *RenameTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRenameTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RenameTable() (localctx IRenameTableContext) {
	localctx = NewRenameTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MariaDBParserRULE_renameTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3255)
		p.Match(MariaDBParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3256)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3257)
		p.RenameTableClause()
	}
	p.SetState(3262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3258)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3259)
			p.RenameTableClause()
		}

		p.SetState(3264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTableClauseContext is an interface to support dynamic dispatch.
type IRenameTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	TO() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsRenameTableClauseContext differentiates from other interfaces.
	IsRenameTableClauseContext()
}

type RenameTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableClauseContext() *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameTableClause
	return p
}

func InitEmptyRenameTableClauseContext(p *RenameTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameTableClause
}

func (*RenameTableClauseContext) IsRenameTableClauseContext() {}

func NewRenameTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_renameTableClause

	return p
}

func (s *RenameTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableClauseContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableClauseContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *RenameTableClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *RenameTableClauseContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *RenameTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRenameTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RenameTableClause() (localctx IRenameTableClauseContext) {
	localctx = NewRenameTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MariaDBParserRULE_renameTableClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3265)
		p.TableName()
	}
	p.SetState(3267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(3266)
			p.WaitNowaitClause()
		}

	}
	{
		p.SetState(3269)
		p.Match(MariaDBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3270)
		p.TableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableContext is an interface to support dynamic dispatch.
type ITruncateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableName() ITableNameContext
	TABLE() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsTruncateTableContext differentiates from other interfaces.
	IsTruncateTableContext()
}

type TruncateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableContext() *TruncateTableContext {
	var p = new(TruncateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_truncateTable
	return p
}

func InitEmptyTruncateTableContext(p *TruncateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_truncateTable
}

func (*TruncateTableContext) IsTruncateTableContext() {}

func NewTruncateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableContext {
	var p = new(TruncateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_truncateTable

	return p
}

func (s *TruncateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *TruncateTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TruncateTable() (localctx ITruncateTableContext) {
	localctx = NewTruncateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MariaDBParserRULE_truncateTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3272)
		p.Match(MariaDBParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserTABLE {
		{
			p.SetState(3273)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3276)
		p.TableName()
	}
	p.SetState(3278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(3277)
			p.WaitNowaitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	Expressions() IExpressionsContext

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_callStatement
	return p
}

func InitEmptyCallStatementContext(p *CallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_callStatement
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCALL, 0)
}

func (s *CallStatementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CallStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CallStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CallStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *CallStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MariaDBParserRULE_callStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3280)
		p.Match(MariaDBParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3281)
		p.FullId()
	}
	p.SetState(3288)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3282)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3283)
				p.Constants()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3284)
				p.Expressions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3287)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleDeleteStatement() ISingleDeleteStatementContext
	MultipleDeleteStatement() IMultipleDeleteStatementContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) SingleDeleteStatement() ISingleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleDeleteStatementContext)
}

func (s *DeleteStatementContext) MultipleDeleteStatement() IMultipleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleDeleteStatementContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MariaDBParserRULE_deleteStatement)
	p.SetState(3292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3290)
			p.SingleDeleteStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3291)
			p.MultipleDeleteStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_doStatement
	return p
}

func InitEmptyDoStatementContext(p *DoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_doStatement
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDO, 0)
}

func (s *DoStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MariaDBParserRULE_doStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3294)
		p.Match(MariaDBParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3295)
		p.Expressions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HandlerOpenStatement() IHandlerOpenStatementContext
	HandlerReadIndexStatement() IHandlerReadIndexStatementContext
	HandlerReadStatement() IHandlerReadStatementContext
	HandlerCloseStatement() IHandlerCloseStatementContext

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerStatement
	return p
}

func InitEmptyHandlerStatementContext(p *HandlerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerStatement
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) HandlerOpenStatement() IHandlerOpenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerOpenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerOpenStatementContext)
}

func (s *HandlerStatementContext) HandlerReadIndexStatement() IHandlerReadIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadIndexStatementContext)
}

func (s *HandlerStatementContext) HandlerReadStatement() IHandlerReadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadStatementContext)
}

func (s *HandlerStatementContext) HandlerCloseStatement() IHandlerCloseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerCloseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerCloseStatementContext)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerStatement() (localctx IHandlerStatementContext) {
	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MariaDBParserRULE_handlerStatement)
	p.SetState(3301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3297)
			p.HandlerOpenStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3298)
			p.HandlerReadIndexStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3299)
			p.HandlerReadStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3300)
			p.HandlerCloseStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IUidListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// GetDuplicatedFirst returns the duplicatedFirst rule contexts.
	GetDuplicatedFirst() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IUidListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// SetDuplicatedFirst sets the duplicatedFirst rule contexts.
	SetDuplicatedFirst(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// GetDuplicatedElements returns the duplicatedElements rule context list.
	GetDuplicatedElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// SetDuplicatedElements sets the duplicatedElements rule context list.
	SetDuplicatedElements([]IUpdatedElementContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	priority           antlr.Token
	partitions         IUidListContext
	columns            IUidListContext
	setFirst           IUpdatedElementContext
	_updatedElement    IUpdatedElementContext
	setElements        []IUpdatedElementContext
	duplicatedFirst    IUpdatedElementContext
	duplicatedElements []IUpdatedElementContext
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *InsertStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *InsertStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *InsertStatementContext) GetColumns() IUidListContext { return s.columns }

func (s *InsertStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *InsertStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *InsertStatementContext) GetDuplicatedFirst() IUpdatedElementContext {
	return s.duplicatedFirst
}

func (s *InsertStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *InsertStatementContext) SetColumns(v IUidListContext) { s.columns = v }

func (s *InsertStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *InsertStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *InsertStatementContext) SetDuplicatedFirst(v IUpdatedElementContext) { s.duplicatedFirst = v }

func (s *InsertStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *InsertStatementContext) GetDuplicatedElements() []IUpdatedElementContext {
	return s.duplicatedElements
}

func (s *InsertStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *InsertStatementContext) SetDuplicatedElements(v []IUpdatedElementContext) {
	s.duplicatedElements = v
}

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT, 0)
}

func (s *InsertStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *InsertStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *InsertStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *InsertStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *InsertStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *InsertStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *InsertStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *InsertStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *InsertStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *InsertStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *InsertStatementContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDUPLICATE, 0)
}

func (s *InsertStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *InsertStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *InsertStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *InsertStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELAYED, 0)
}

func (s *InsertStatementContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHIGH_PRIORITY, 0)
}

func (s *InsertStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *InsertStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *InsertStatementContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MariaDBParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3303)
		p.Match(MariaDBParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&4611686020574871553) != 0 {
		{
			p.SetState(3304)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&4611686020574871553) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3307)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINTO {
		{
			p.SetState(3310)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3313)
		p.TableName()
	}
	p.SetState(3320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(3314)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3315)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(3316)

				var _x = p.UidList()

				localctx.(*InsertStatementContext).partitions = _x
			}

		}
		{
			p.SetState(3319)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSELECT, MariaDBParserVALUES, MariaDBParserVALUE, MariaDBParserLR_BRACKET:
		p.SetState(3326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3322)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3323)

				var _x = p.UidList()

				localctx.(*InsertStatementContext).columns = _x
			}
			{
				p.SetState(3324)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3328)
			p.InsertStatementValue()
		}

	case MariaDBParserSET:
		{
			p.SetState(3329)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3330)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).setFirst = _x
		}
		p.SetState(3335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3331)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3332)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).setElements = append(localctx.(*InsertStatementContext).setElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3337)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserON {
		{
			p.SetState(3340)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3341)
			p.Match(MariaDBParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3342)
			p.Match(MariaDBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3343)
			p.Match(MariaDBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3344)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).duplicatedFirst = _x
		}
		p.SetState(3349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3345)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3346)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).duplicatedElements = append(localctx.(*InsertStatementContext).duplicatedElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadDataStatementContext is an interface to support dynamic dispatch.
type ILoadDataStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetFieldsFormat returns the fieldsFormat token.
	GetFieldsFormat() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetFieldsFormat sets the fieldsFormat token.
	SetFieldsFormat(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	STRING_LITERAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	UidList() IUidListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllLINES() []antlr.TerminalNode
	LINES(i int) antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	AllSelectFieldsInto() []ISelectFieldsIntoContext
	SelectFieldsInto(i int) ISelectFieldsIntoContext
	AllSelectLinesInto() []ISelectLinesIntoContext
	SelectLinesInto(i int) ISelectLinesIntoContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadDataStatementContext differentiates from other interfaces.
	IsLoadDataStatementContext()
}

type LoadDataStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	priority     antlr.Token
	filename     antlr.Token
	violation    antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
	linesFormat  antlr.Token
}

func NewEmptyLoadDataStatementContext() *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadDataStatement
	return p
}

func InitEmptyLoadDataStatementContext(p *LoadDataStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadDataStatement
}

func (*LoadDataStatementContext) IsLoadDataStatementContext() {}

func NewLoadDataStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_loadDataStatement

	return p
}

func (s *LoadDataStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadDataStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadDataStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadDataStatementContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *LoadDataStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadDataStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadDataStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadDataStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadDataStatementContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *LoadDataStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadDataStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadDataStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadDataStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOAD, 0)
}

func (s *LoadDataStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *LoadDataStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINFILE, 0)
}

func (s *LoadDataStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *LoadDataStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *LoadDataStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadDataStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *LoadDataStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *LoadDataStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *LoadDataStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *LoadDataStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *LoadDataStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadDataStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *LoadDataStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *LoadDataStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *LoadDataStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSET)
}

func (s *LoadDataStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, i)
}

func (s *LoadDataStatementContext) AllLINES() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLINES)
}

func (s *LoadDataStatementContext) LINES(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINES, i)
}

func (s *LoadDataStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserIGNORE)
}

func (s *LoadDataStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, i)
}

func (s *LoadDataStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadDataStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadDataStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadDataStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadDataStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *LoadDataStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONCURRENT, 0)
}

func (s *LoadDataStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *LoadDataStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIELDS, 0)
}

func (s *LoadDataStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *LoadDataStatementContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROWS, 0)
}

func (s *LoadDataStatementContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *LoadDataStatementContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *LoadDataStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *LoadDataStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *LoadDataStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadDataStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLoadDataStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LoadDataStatement() (localctx ILoadDataStatementContext) {
	localctx = NewLoadDataStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MariaDBParserRULE_loadDataStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3354)
		p.Match(MariaDBParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3355)
		p.Match(MariaDBParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY || _la == MariaDBParserCONCURRENT {
		{
			p.SetState(3356)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLOW_PRIORITY || _la == MariaDBParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOCAL {
		{
			p.SetState(3359)
			p.Match(MariaDBParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3362)
		p.Match(MariaDBParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3363)

		var _m = p.Match(MariaDBParserSTRING_LITERAL)

		localctx.(*LoadDataStatementContext).filename = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE {
		{
			p.SetState(3364)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3367)
		p.Match(MariaDBParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3368)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3369)
		p.TableName()
	}
	p.SetState(3375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(3370)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3371)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3372)
			p.UidList()
		}
		{
			p.SetState(3373)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCHARACTER {
		{
			p.SetState(3377)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3378)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3379)

			var _x = p.CharsetName()

			localctx.(*LoadDataStatementContext).charset = _x
		}

	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOLUMNS || _la == MariaDBParserFIELDS {
		{
			p.SetState(3382)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).fieldsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCOLUMNS || _la == MariaDBParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).fieldsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserENCLOSED || _la == MariaDBParserESCAPED || _la == MariaDBParserOPTIONALLY || _la == MariaDBParserTERMINATED {
			{
				p.SetState(3383)
				p.SelectFieldsInto()
			}

			p.SetState(3386)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLINES {
		{
			p.SetState(3390)
			p.Match(MariaDBParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserSTARTING || _la == MariaDBParserTERMINATED {
			{
				p.SetState(3391)
				p.SelectLinesInto()
			}

			p.SetState(3394)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3398)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3399)
			p.DecimalLiteral()
		}
		{
			p.SetState(3400)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLINES || _la == MariaDBParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3404)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3405)
			p.AssignmentField()
		}
		p.SetState(3410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3406)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3407)
				p.AssignmentField()
			}

			p.SetState(3412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3413)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3417)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3418)
			p.UpdatedElement()
		}
		p.SetState(3423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3419)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3420)
				p.UpdatedElement()
			}

			p.SetState(3425)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadXmlStatementContext is an interface to support dynamic dispatch.
type ILoadXmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	XML() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	LR_BRACKET() antlr.TerminalNode
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	RR_BRACKET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadXmlStatementContext differentiates from other interfaces.
	IsLoadXmlStatementContext()
}

type LoadXmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	priority    antlr.Token
	filename    antlr.Token
	violation   antlr.Token
	charset     ICharsetNameContext
	tag         antlr.Token
	linesFormat antlr.Token
}

func NewEmptyLoadXmlStatementContext() *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadXmlStatement
	return p
}

func InitEmptyLoadXmlStatementContext(p *LoadXmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadXmlStatement
}

func (*LoadXmlStatementContext) IsLoadXmlStatementContext() {}

func NewLoadXmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_loadXmlStatement

	return p
}

func (s *LoadXmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadXmlStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadXmlStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadXmlStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadXmlStatementContext) GetTag() antlr.Token { return s.tag }

func (s *LoadXmlStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadXmlStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadXmlStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadXmlStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadXmlStatementContext) SetTag(v antlr.Token) { s.tag = v }

func (s *LoadXmlStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadXmlStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadXmlStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadXmlStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOAD, 0)
}

func (s *LoadXmlStatementContext) XML() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXML, 0)
}

func (s *LoadXmlStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINFILE, 0)
}

func (s *LoadXmlStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *LoadXmlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *LoadXmlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadXmlStatementContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *LoadXmlStatementContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *LoadXmlStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *LoadXmlStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *LoadXmlStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSET)
}

func (s *LoadXmlStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, i)
}

func (s *LoadXmlStatementContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserROWS)
}

func (s *LoadXmlStatementContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserROWS, i)
}

func (s *LoadXmlStatementContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIDENTIFIED, 0)
}

func (s *LoadXmlStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *LoadXmlStatementContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLESS_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREATER_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserIGNORE)
}

func (s *LoadXmlStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, i)
}

func (s *LoadXmlStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadXmlStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadXmlStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadXmlStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadXmlStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *LoadXmlStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONCURRENT, 0)
}

func (s *LoadXmlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *LoadXmlStatementContext) LINES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINES, 0)
}

func (s *LoadXmlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *LoadXmlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *LoadXmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadXmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadXmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLoadXmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LoadXmlStatement() (localctx ILoadXmlStatementContext) {
	localctx = NewLoadXmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MariaDBParserRULE_loadXmlStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3428)
		p.Match(MariaDBParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3429)
		p.Match(MariaDBParserXML)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY || _la == MariaDBParserCONCURRENT {
		{
			p.SetState(3430)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLOW_PRIORITY || _la == MariaDBParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOCAL {
		{
			p.SetState(3433)
			p.Match(MariaDBParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3436)
		p.Match(MariaDBParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3437)

		var _m = p.Match(MariaDBParserSTRING_LITERAL)

		localctx.(*LoadXmlStatementContext).filename = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE {
		{
			p.SetState(3438)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserIGNORE || _la == MariaDBParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3441)
		p.Match(MariaDBParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3442)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3443)
		p.TableName()
	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCHARACTER {
		{
			p.SetState(3444)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3445)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3446)

			var _x = p.CharsetName()

			localctx.(*LoadXmlStatementContext).charset = _x
		}

	}
	p.SetState(3455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserROWS {
		{
			p.SetState(3449)
			p.Match(MariaDBParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3450)
			p.Match(MariaDBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3452)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3453)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*LoadXmlStatementContext).tag = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3454)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3457)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3458)
			p.DecimalLiteral()
		}
		{
			p.SetState(3459)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLINES || _la == MariaDBParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3463)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3464)
			p.AssignmentField()
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3465)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3466)
				p.AssignmentField()
			}

			p.SetState(3471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3472)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3485)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3476)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3477)
			p.UpdatedElement()
		}
		p.SetState(3482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3478)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3479)
				p.UpdatedElement()
			}

			p.SetState(3484)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceStatementContext is an interface to support dynamic dispatch.
type IReplaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IUidListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IUidListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplaceStatementContext differentiates from other interfaces.
	IsReplaceStatementContext()
}

type ReplaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	priority        antlr.Token
	partitions      IUidListContext
	columns         IUidListContext
	setFirst        IUpdatedElementContext
	_updatedElement IUpdatedElementContext
	setElements     []IUpdatedElementContext
}

func NewEmptyReplaceStatementContext() *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replaceStatement
	return p
}

func InitEmptyReplaceStatementContext(p *ReplaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replaceStatement
}

func (*ReplaceStatementContext) IsReplaceStatementContext() {}

func NewReplaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_replaceStatement

	return p
}

func (s *ReplaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *ReplaceStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *ReplaceStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *ReplaceStatementContext) GetColumns() IUidListContext { return s.columns }

func (s *ReplaceStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *ReplaceStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *ReplaceStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *ReplaceStatementContext) SetColumns(v IUidListContext) { s.columns = v }

func (s *ReplaceStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *ReplaceStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *ReplaceStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *ReplaceStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *ReplaceStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *ReplaceStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReplaceStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *ReplaceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *ReplaceStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *ReplaceStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *ReplaceStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *ReplaceStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *ReplaceStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *ReplaceStatementContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *ReplaceStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *ReplaceStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELAYED, 0)
}

func (s *ReplaceStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ReplaceStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ReplaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReplaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReplaceStatement() (localctx IReplaceStatementContext) {
	localctx = NewReplaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MariaDBParserRULE_replaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3487)
		p.Match(MariaDBParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDELAYED || _la == MariaDBParserLOW_PRIORITY {
		{
			p.SetState(3488)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReplaceStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDELAYED || _la == MariaDBParserLOW_PRIORITY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReplaceStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINTO {
		{
			p.SetState(3491)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3494)
		p.TableName()
	}
	p.SetState(3500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(3495)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3496)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3497)

			var _x = p.UidList()

			localctx.(*ReplaceStatementContext).partitions = _x
		}
		{
			p.SetState(3498)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSELECT, MariaDBParserVALUES, MariaDBParserVALUE, MariaDBParserLR_BRACKET:
		p.SetState(3506)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3502)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3503)

				var _x = p.UidList()

				localctx.(*ReplaceStatementContext).columns = _x
			}
			{
				p.SetState(3504)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3508)
			p.InsertStatementValue()
		}

	case MariaDBParserSET:
		{
			p.SetState(3509)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3510)

			var _x = p.UpdatedElement()

			localctx.(*ReplaceStatementContext).setFirst = _x
		}
		p.SetState(3515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3511)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3512)

				var _x = p.UpdatedElement()

				localctx.(*ReplaceStatementContext)._updatedElement = _x
			}
			localctx.(*ReplaceStatementContext).setElements = append(localctx.(*ReplaceStatementContext).setElements, localctx.(*ReplaceStatementContext)._updatedElement)

			p.SetState(3517)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyAll(ctx *SelectStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnionSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionSelectContext {
	var p = new(UnionSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionSelectContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionSelectContext) AllUnionStatement() []IUnionStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionStatementContext); ok {
			len++
		}
	}

	tst := make([]IUnionStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionStatementContext); ok {
			tst[i] = t.(IUnionStatementContext)
			i++
		}
	}

	return tst
}

func (s *UnionSelectContext) UnionStatement(i int) IUnionStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *UnionSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNION, 0)
}

func (s *UnionSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *UnionSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *UnionSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *UnionSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnionSelect(s)
	}
}

func (s *UnionSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnionSelect(s)
	}
}

func (s *UnionSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnionSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnionParenthesisSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionParenthesisSelectContext {
	var p = new(UnionParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionParenthesisSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisSelectContext) AllUnionParenthesis() []IUnionParenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			len++
		}
	}

	tst := make([]IUnionParenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionParenthesisContext); ok {
			tst[i] = t.(IUnionParenthesisContext)
			i++
		}
	}

	return tst
}

func (s *UnionParenthesisSelectContext) UnionParenthesis(i int) IUnionParenthesisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParenthesisContext)
}

func (s *UnionParenthesisSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNION, 0)
}

func (s *UnionParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionParenthesisSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionParenthesisSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionParenthesisSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *UnionParenthesisSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *UnionParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnionParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleSelectContext struct {
	SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisSelectContext struct {
	SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext {
	var p = new(ParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *ParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type WithLateralStatementContext struct {
	SelectStatementContext
}

func NewWithLateralStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithLateralStatementContext {
	var p = new(WithLateralStatementContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *WithLateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithLateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *WithLateralStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *WithLateralStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *WithLateralStatementContext) AllLateralStatement() []ILateralStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralStatementContext); ok {
			len++
		}
	}

	tst := make([]ILateralStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralStatementContext); ok {
			tst[i] = t.(ILateralStatementContext)
			i++
		}
	}

	return tst
}

func (s *WithLateralStatementContext) LateralStatement(i int) ILateralStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralStatementContext)
}

func (s *WithLateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWithLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MariaDBParserRULE_selectStatement)
	var _la int

	var _alt int

	p.SetState(3582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 501, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3520)
			p.QuerySpecification()
		}
		p.SetState(3522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3521)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3524)
			p.QueryExpression()
		}
		p.SetState(3526)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3525)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewUnionSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3528)
			p.QuerySpecificationNointo()
		}
		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3529)
					p.UnionStatement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3532)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUNION {
			{
				p.SetState(3534)
				p.Match(MariaDBParserUNION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3536)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserALL || _la == MariaDBParserDISTINCT {
				{
					p.SetState(3535)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserALL || _la == MariaDBParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(3540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserSELECT:
				{
					p.SetState(3538)
					p.QuerySpecification()
				}

			case MariaDBParserLR_BRACKET:
				{
					p.SetState(3539)
					p.QueryExpression()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3545)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3544)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(3547)
				p.LimitClause()
			}

		}
		p.SetState(3551)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3550)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewUnionParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3553)
			p.QueryExpressionNointo()
		}
		p.SetState(3555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3554)
					p.UnionParenthesis()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3557)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 494, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUNION {
			{
				p.SetState(3559)
				p.Match(MariaDBParserUNION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3561)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserALL || _la == MariaDBParserDISTINCT {
				{
					p.SetState(3560)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionParenthesisSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserALL || _la == MariaDBParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionParenthesisSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(3563)
				p.QueryExpression()
			}

		}
		p.SetState(3567)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3566)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(3569)
				p.LimitClause()
			}

		}
		p.SetState(3573)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 499, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3572)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewWithLateralStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3575)
			p.QuerySpecificationNointo()
		}
		p.SetState(3578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserCOMMA {
			{
				p.SetState(3576)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3577)
				p.LateralStatement()
			}

			p.SetState(3580)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleUpdateStatement() ISingleUpdateStatementContext
	MultipleUpdateStatement() IMultipleUpdateStatementContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) SingleUpdateStatement() ISingleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleUpdateStatementContext)
}

func (s *UpdateStatementContext) MultipleUpdateStatement() IMultipleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleUpdateStatementContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MariaDBParserRULE_updateStatement)
	p.SetState(3586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3584)
			p.SingleUpdateStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3585)
			p.MultipleUpdateStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesStatementContext is an interface to support dynamic dispatch.
type IValuesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesStatementContext differentiates from other interfaces.
	IsValuesStatementContext()
}

type ValuesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesStatementContext() *ValuesStatementContext {
	var p = new(ValuesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_valuesStatement
	return p
}

func InitEmptyValuesStatementContext(p *ValuesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_valuesStatement
}

func (*ValuesStatementContext) IsValuesStatementContext() {}

func NewValuesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesStatementContext {
	var p = new(ValuesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_valuesStatement

	return p
}

func (s *ValuesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *ValuesStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *ValuesStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *ValuesStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *ValuesStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *ValuesStatementContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *ValuesStatementContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *ValuesStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ValuesStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ValuesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterValuesStatement(s)
	}
}

func (s *ValuesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitValuesStatement(s)
	}
}

func (s *ValuesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitValuesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ValuesStatement() (localctx IValuesStatementContext) {
	localctx = NewValuesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MariaDBParserRULE_valuesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3588)
		p.Match(MariaDBParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3589)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3591)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3590)
			p.ExpressionsWithDefaults()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3593)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3594)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3595)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3597)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3596)
				p.ExpressionsWithDefaults()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3599)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementValueContext is an interface to support dynamic dispatch.
type IInsertStatementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInsertFormat returns the insertFormat token.
	GetInsertFormat() antlr.Token

	// SetInsertFormat sets the insertFormat token.
	SetInsertFormat(antlr.Token)

	// Getter signatures
	SelectStatement() ISelectStatementContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsertStatementValueContext differentiates from other interfaces.
	IsInsertStatementValueContext()
}

type InsertStatementValueContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	insertFormat antlr.Token
}

func NewEmptyInsertStatementValueContext() *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_insertStatementValue
	return p
}

func InitEmptyInsertStatementValueContext(p *InsertStatementValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_insertStatementValue
}

func (*InsertStatementValueContext) IsInsertStatementValueContext() {}

func NewInsertStatementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_insertStatementValue

	return p
}

func (s *InsertStatementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementValueContext) GetInsertFormat() antlr.Token { return s.insertFormat }

func (s *InsertStatementValueContext) SetInsertFormat(v antlr.Token) { s.insertFormat = v }

func (s *InsertStatementValueContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InsertStatementValueContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *InsertStatementValueContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *InsertStatementValueContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *InsertStatementValueContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *InsertStatementValueContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *InsertStatementValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *InsertStatementValueContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementValueContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *InsertStatementValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *InsertStatementValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *InsertStatementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInsertStatementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) InsertStatementValue() (localctx IInsertStatementValueContext) {
	localctx = NewInsertStatementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MariaDBParserRULE_insertStatementValue)
	var _la int

	p.SetState(3623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSELECT, MariaDBParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3605)
			p.SelectStatement()
		}

	case MariaDBParserVALUES, MariaDBParserVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3606)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementValueContext).insertFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserVALUES || _la == MariaDBParserVALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementValueContext).insertFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3607)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3608)
				p.ExpressionsWithDefaults()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3611)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3612)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3613)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3615)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3614)
					p.ExpressionsWithDefaults()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3617)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3622)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdatedElementContext is an interface to support dynamic dispatch.
type IUpdatedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdatedElementContext differentiates from other interfaces.
	IsUpdatedElementContext()
}

type UpdatedElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatedElementContext() *UpdatedElementContext {
	var p = new(UpdatedElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_updatedElement
	return p
}

func InitEmptyUpdatedElementContext(p *UpdatedElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_updatedElement
}

func (*UpdatedElementContext) IsUpdatedElementContext() {}

func NewUpdatedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatedElementContext {
	var p = new(UpdatedElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_updatedElement

	return p
}

func (s *UpdatedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatedElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *UpdatedElementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *UpdatedElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdatedElementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *UpdatedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUpdatedElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UpdatedElement() (localctx IUpdatedElementContext) {
	localctx = NewUpdatedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MariaDBParserRULE_updatedElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3625)
		p.FullColumnName()
	}
	{
		p.SetState(3626)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 510, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3627)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(3628)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentFieldContext is an interface to support dynamic dispatch.
type IAssignmentFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	LOCAL_ID() antlr.TerminalNode

	// IsAssignmentFieldContext differentiates from other interfaces.
	IsAssignmentFieldContext()
}

type AssignmentFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentFieldContext() *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_assignmentField
	return p
}

func InitEmptyAssignmentFieldContext(p *AssignmentFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_assignmentField
}

func (*AssignmentFieldContext) IsAssignmentFieldContext() {}

func NewAssignmentFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_assignmentField

	return p
}

func (s *AssignmentFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentFieldContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AssignmentFieldContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *AssignmentFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAssignmentField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AssignmentField() (localctx IAssignmentFieldContext) {
	localctx = NewAssignmentFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MariaDBParserRULE_assignmentField)
	p.SetState(3633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3631)
			p.Uid()
		}

	case MariaDBParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3632)
			p.Match(MariaDBParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	IN() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	MODE() antlr.TerminalNode
	LockOption() ILockOptionContext

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockClause
	return p
}

func InitEmptyLockClauseContext(p *LockClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockClause
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODE, 0)
}

func (s *LockClauseContext) LockOption() ILockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockOptionContext)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLockClause(s)
	}
}

func (s *LockClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLockClause(s)
	}
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LockClause() (localctx ILockClauseContext) {
	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MariaDBParserRULE_lockClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserFOR:
		{
			p.SetState(3635)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3636)
			p.Match(MariaDBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLOCK:
		{
			p.SetState(3637)
			p.Match(MariaDBParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3638)
			p.Match(MariaDBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3639)
			p.Match(MariaDBParserSHARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3640)
			p.Match(MariaDBParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3643)
			p.LockOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleDeleteStatementContext is an interface to support dynamic dispatch.
type ISingleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TableName() ITableNameContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	LOW_PRIORITY() antlr.TerminalNode

	// IsSingleDeleteStatementContext differentiates from other interfaces.
	IsSingleDeleteStatementContext()
}

type SingleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleDeleteStatementContext() *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_singleDeleteStatement
	return p
}

func InitEmptySingleDeleteStatementContext(p *SingleDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_singleDeleteStatement
}

func (*SingleDeleteStatementContext) IsSingleDeleteStatementContext() {}

func NewSingleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_singleDeleteStatement

	return p
}

func (s *SingleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELETE, 0)
}

func (s *SingleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *SingleDeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *SingleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *SingleDeleteStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *SingleDeleteStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SingleDeleteStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *SingleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleDeleteStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleDeleteStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIMIT, 0)
}

func (s *SingleDeleteStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *SingleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *SingleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSingleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SingleDeleteStatement() (localctx ISingleDeleteStatementContext) {
	localctx = NewSingleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MariaDBParserRULE_singleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3646)
		p.Match(MariaDBParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY {
		{
			p.SetState(3647)

			var _m = p.Match(MariaDBParserLOW_PRIORITY)

			localctx.(*SingleDeleteStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserQUICK {
		{
			p.SetState(3650)
			p.Match(MariaDBParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3653)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3656)
		p.Match(MariaDBParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3657)
		p.TableName()
	}
	p.SetState(3663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(3658)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3659)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3660)
			p.UidList()
		}
		{
			p.SetState(3661)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3665)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3666)
			p.expression(0)
		}

	}
	p.SetState(3670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserORDER {
		{
			p.SetState(3669)
			p.OrderByClause()
		}

	}
	p.SetState(3674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLIMIT {
		{
			p.SetState(3672)
			p.Match(MariaDBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3673)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipleDeleteStatementContext is an interface to support dynamic dispatch.
type IMultipleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	USING() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipleDeleteStatementContext differentiates from other interfaces.
	IsMultipleDeleteStatementContext()
}

type MultipleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleDeleteStatementContext() *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_multipleDeleteStatement
	return p
}

func InitEmptyMultipleDeleteStatementContext(p *MultipleDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_multipleDeleteStatement
}

func (*MultipleDeleteStatementContext) IsMultipleDeleteStatementContext() {}

func NewMultipleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_multipleDeleteStatement

	return p
}

func (s *MultipleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELETE, 0)
}

func (s *MultipleDeleteStatementContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleDeleteStatementContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MultipleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *MultipleDeleteStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleDeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *MultipleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *MultipleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *MultipleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *MultipleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *MultipleDeleteStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserDOT)
}

func (s *MultipleDeleteStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, i)
}

func (s *MultipleDeleteStatementContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTAR)
}

func (s *MultipleDeleteStatementContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, i)
}

func (s *MultipleDeleteStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *MultipleDeleteStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *MultipleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMultipleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) MultipleDeleteStatement() (localctx IMultipleDeleteStatementContext) {
	localctx = NewMultipleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MariaDBParserRULE_multipleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3676)
		p.Match(MariaDBParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY {
		{
			p.SetState(3677)

			var _m = p.Match(MariaDBParserLOW_PRIORITY)

			localctx.(*MultipleDeleteStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3681)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 522, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3680)
			p.Match(MariaDBParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3683)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		{
			p.SetState(3686)
			p.TableName()
		}
		p.SetState(3689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDOT {
			{
				p.SetState(3687)
				p.Match(MariaDBParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3688)
				p.Match(MariaDBParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3691)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3692)
				p.TableName()
			}
			p.SetState(3695)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserDOT {
				{
					p.SetState(3693)
					p.Match(MariaDBParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3694)
					p.Match(MariaDBParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

			p.SetState(3701)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3702)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3703)
			p.TableSources()
		}

	case MariaDBParserFROM:
		{
			p.SetState(3705)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3706)
			p.TableName()
		}
		p.SetState(3709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDOT {
			{
				p.SetState(3707)
				p.Match(MariaDBParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3708)
				p.Match(MariaDBParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(3711)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3712)
				p.TableName()
			}
			p.SetState(3715)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserDOT {
				{
					p.SetState(3713)
					p.Match(MariaDBParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3714)
					p.Match(MariaDBParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

			p.SetState(3721)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3722)
			p.Match(MariaDBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3723)
			p.TableSources()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3727)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3728)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerOpenStatementContext is an interface to support dynamic dispatch.
type IHandlerOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	OPEN() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsHandlerOpenStatementContext differentiates from other interfaces.
	IsHandlerOpenStatementContext()
}

type HandlerOpenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerOpenStatementContext() *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerOpenStatement
	return p
}

func InitEmptyHandlerOpenStatementContext(p *HandlerOpenStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerOpenStatement
}

func (*HandlerOpenStatementContext) IsHandlerOpenStatementContext() {}

func NewHandlerOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerOpenStatement

	return p
}

func (s *HandlerOpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerOpenStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *HandlerOpenStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerOpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPEN, 0)
}

func (s *HandlerOpenStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerOpenStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *HandlerOpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerOpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerOpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerOpenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerOpenStatement() (localctx IHandlerOpenStatementContext) {
	localctx = NewHandlerOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MariaDBParserRULE_handlerOpenStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3731)
		p.Match(MariaDBParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3732)
		p.TableName()
	}
	{
		p.SetState(3733)
		p.Match(MariaDBParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3738)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
		p.SetState(3735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(3734)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3737)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerReadIndexStatementContext is an interface to support dynamic dispatch.
type IHandlerReadIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// GetIndex returns the index rule contexts.
	GetIndex() IUidContext

	// SetIndex sets the index rule contexts.
	SetIndex(IUidContext)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	Uid() IUidContext
	ComparisonOperator() IComparisonOperatorContext
	LR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	PREV() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsHandlerReadIndexStatementContext differentiates from other interfaces.
	IsHandlerReadIndexStatementContext()
}

type HandlerReadIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	index     IUidContext
	moveOrder antlr.Token
}

func NewEmptyHandlerReadIndexStatementContext() *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerReadIndexStatement
	return p
}

func InitEmptyHandlerReadIndexStatementContext(p *HandlerReadIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerReadIndexStatement
}

func (*HandlerReadIndexStatementContext) IsHandlerReadIndexStatementContext() {}

func NewHandlerReadIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerReadIndexStatement

	return p
}

func (s *HandlerReadIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadIndexStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadIndexStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadIndexStatementContext) GetIndex() IUidContext { return s.index }

func (s *HandlerReadIndexStatementContext) SetIndex(v IUidContext) { s.index = v }

func (s *HandlerReadIndexStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *HandlerReadIndexStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadIndexStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *HandlerReadIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerReadIndexStatementContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *HandlerReadIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *HandlerReadIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *HandlerReadIndexStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadIndexStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIMIT, 0)
}

func (s *HandlerReadIndexStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadIndexStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *HandlerReadIndexStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXT, 0)
}

func (s *HandlerReadIndexStatementContext) PREV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREV, 0)
}

func (s *HandlerReadIndexStatementContext) LAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST, 0)
}

func (s *HandlerReadIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerReadIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerReadIndexStatement() (localctx IHandlerReadIndexStatementContext) {
	localctx = NewHandlerReadIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MariaDBParserRULE_handlerReadIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3740)
		p.Match(MariaDBParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3741)
		p.TableName()
	}
	{
		p.SetState(3742)
		p.Match(MariaDBParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3743)

		var _x = p.Uid()

		localctx.(*HandlerReadIndexStatementContext).index = _x
	}
	p.SetState(3750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserEQUAL_SYMBOL, MariaDBParserGREATER_SYMBOL, MariaDBParserLESS_SYMBOL, MariaDBParserEXCLAMATION_SYMBOL:
		{
			p.SetState(3744)
			p.ComparisonOperator()
		}
		{
			p.SetState(3745)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3746)
			p.Constants()
		}
		{
			p.SetState(3747)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFIRST, MariaDBParserLAST, MariaDBParserNEXT, MariaDBParserPREV:
		{
			p.SetState(3749)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*HandlerReadIndexStatementContext).moveOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFIRST || _la == MariaDBParserLAST || _la == MariaDBParserNEXT || _la == MariaDBParserPREV) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*HandlerReadIndexStatementContext).moveOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3752)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3753)
			p.expression(0)
		}

	}
	p.SetState(3758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLIMIT {
		{
			p.SetState(3756)
			p.Match(MariaDBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3757)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerReadStatementContext is an interface to support dynamic dispatch.
type IHandlerReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext

	// IsHandlerReadStatementContext differentiates from other interfaces.
	IsHandlerReadStatementContext()
}

type HandlerReadStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	moveOrder antlr.Token
}

func NewEmptyHandlerReadStatementContext() *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerReadStatement
	return p
}

func InitEmptyHandlerReadStatementContext(p *HandlerReadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerReadStatement
}

func (*HandlerReadStatementContext) IsHandlerReadStatementContext() {}

func NewHandlerReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerReadStatement

	return p
}

func (s *HandlerReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *HandlerReadStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *HandlerReadStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *HandlerReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXT, 0)
}

func (s *HandlerReadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *HandlerReadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIMIT, 0)
}

func (s *HandlerReadStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerReadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerReadStatement() (localctx IHandlerReadStatementContext) {
	localctx = NewHandlerReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MariaDBParserRULE_handlerReadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3760)
		p.Match(MariaDBParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3761)
		p.TableName()
	}
	{
		p.SetState(3762)
		p.Match(MariaDBParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3763)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*HandlerReadStatementContext).moveOrder = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserFIRST || _la == MariaDBParserNEXT) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*HandlerReadStatementContext).moveOrder = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3764)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3765)
			p.expression(0)
		}

	}
	p.SetState(3770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLIMIT {
		{
			p.SetState(3768)
			p.Match(MariaDBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3769)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerCloseStatementContext is an interface to support dynamic dispatch.
type IHandlerCloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	CLOSE() antlr.TerminalNode

	// IsHandlerCloseStatementContext differentiates from other interfaces.
	IsHandlerCloseStatementContext()
}

type HandlerCloseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerCloseStatementContext() *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerCloseStatement
	return p
}

func InitEmptyHandlerCloseStatementContext(p *HandlerCloseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerCloseStatement
}

func (*HandlerCloseStatementContext) IsHandlerCloseStatementContext() {}

func NewHandlerCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerCloseStatement

	return p
}

func (s *HandlerCloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerCloseStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *HandlerCloseStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerCloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLOSE, 0)
}

func (s *HandlerCloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerCloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerCloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerCloseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerCloseStatement() (localctx IHandlerCloseStatementContext) {
	localctx = NewHandlerCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MariaDBParserRULE_handlerCloseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3772)
		p.Match(MariaDBParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3773)
		p.TableName()
	}
	{
		p.SetState(3774)
		p.Match(MariaDBParserCLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleUpdateStatementContext is an interface to support dynamic dispatch.
type ISingleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleUpdateStatementContext differentiates from other interfaces.
	IsSingleUpdateStatementContext()
}

type SingleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleUpdateStatementContext() *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_singleUpdateStatement
	return p
}

func InitEmptySingleUpdateStatementContext(p *SingleUpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_singleUpdateStatement
}

func (*SingleUpdateStatementContext) IsSingleUpdateStatementContext() {}

func NewSingleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_singleUpdateStatement

	return p
}

func (s *SingleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *SingleUpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SingleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *SingleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *SingleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *SingleUpdateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SingleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SingleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *SingleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleUpdateStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleUpdateStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SingleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *SingleUpdateStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *SingleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSingleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SingleUpdateStatement() (localctx ISingleUpdateStatementContext) {
	localctx = NewSingleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MariaDBParserRULE_singleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3776)
		p.Match(MariaDBParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY {
		{
			p.SetState(3777)

			var _m = p.Match(MariaDBParserLOW_PRIORITY)

			localctx.(*SingleUpdateStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3780)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3783)
		p.TableName()
	}
	p.SetState(3788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010177536) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		p.SetState(3785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(3784)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3787)
			p.Uid()
		}

	}
	{
		p.SetState(3790)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3791)
		p.UpdatedElement()
	}
	p.SetState(3796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3792)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3793)
			p.UpdatedElement()
		}

		p.SetState(3798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3799)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3800)
			p.expression(0)
		}

	}
	p.SetState(3804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserORDER {
		{
			p.SetState(3803)
			p.OrderByClause()
		}

	}
	p.SetState(3807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLIMIT {
		{
			p.SetState(3806)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipleUpdateStatementContext is an interface to support dynamic dispatch.
type IMultipleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableSources() ITableSourcesContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	IGNORE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode

	// IsMultipleUpdateStatementContext differentiates from other interfaces.
	IsMultipleUpdateStatementContext()
}

type MultipleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleUpdateStatementContext() *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_multipleUpdateStatement
	return p
}

func InitEmptyMultipleUpdateStatementContext(p *MultipleUpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_multipleUpdateStatement
}

func (*MultipleUpdateStatementContext) IsMultipleUpdateStatementContext() {}

func NewMultipleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_multipleUpdateStatement

	return p
}

func (s *MultipleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *MultipleUpdateStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *MultipleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *MultipleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *MultipleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *MultipleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *MultipleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *MultipleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *MultipleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *MultipleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMultipleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) MultipleUpdateStatement() (localctx IMultipleUpdateStatementContext) {
	localctx = NewMultipleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MariaDBParserRULE_multipleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3809)
		p.Match(MariaDBParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLOW_PRIORITY {
		{
			p.SetState(3810)

			var _m = p.Match(MariaDBParserLOW_PRIORITY)

			localctx.(*MultipleUpdateStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(3813)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3816)
		p.TableSources()
	}
	{
		p.SetState(3817)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3818)
		p.UpdatedElement()
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(3819)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3820)
			p.UpdatedElement()
		}

		p.SetState(3825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(3826)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3827)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MariaDBParserRULE_orderByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3830)
		p.Match(MariaDBParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3831)
		p.Match(MariaDBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3832)
		p.OrderByExpression()
	}
	p.SetState(3837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 551, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3833)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3834)
				p.OrderByExpression()
			}

		}
		p.SetState(3839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 551, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderByExpressionContext differentiates from other interfaces.
	IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orderByExpression
	return p
}

func InitEmptyOrderByExpressionContext(p *OrderByExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orderByExpression
}

func (*OrderByExpressionContext) IsOrderByExpressionContext() {}

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_orderByExpression

	return p
}

func (s *OrderByExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByExpressionContext) GetOrder() antlr.Token { return s.order }

func (s *OrderByExpressionContext) SetOrder(v antlr.Token) { s.order = v }

func (s *OrderByExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASC, 0)
}

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOrderByExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OrderByExpression() (localctx IOrderByExpressionContext) {
	localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MariaDBParserRULE_orderByExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3840)
		p.expression(0)
	}
	p.SetState(3842)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3841)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderByExpressionContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserASC || _la == MariaDBParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderByExpressionContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableSource() []ITableSourceContext
	TableSource(i int) ITableSourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSources
	return p
}

func InitEmptyTableSourcesContext(p *TableSourcesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSources
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableSources(s)
	}
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableSources(s)
	}
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableSources() (localctx ITableSourcesContext) {
	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MariaDBParserRULE_tableSources)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3844)
		p.TableSource()
	}
	p.SetState(3849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3845)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3846)
				p.TableSource()
			}

		}
		p.SetState(3851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSource
	return p
}

func InitEmptyTableSourceContext(p *TableSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSource
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyAll(ctx *TableSourceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableJsonContext struct {
	TableSourceContext
}

func NewTableJsonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableJsonContext {
	var p = new(TableJsonContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableJsonContext) JsonTable() IJsonTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonTableContext)
}

func (s *TableJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableJson(s)
	}
}

func (s *TableJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableJson(s)
	}
}

func (s *TableJsonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableJson(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourceNestedContext struct {
	TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext {
	var p = new(TableSourceNestedContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableSourceNested(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourceBaseContext struct {
	TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableSource() (localctx ITableSourceContext) {
	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MariaDBParserRULE_tableSource)
	var _la int

	var _alt int

	p.SetState(3870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 556, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableSourceBaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3852)
			p.TableSourceItem()
		}
		p.SetState(3856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 554, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3853)
					p.JoinPart()
				}

			}
			p.SetState(3858)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 554, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewTableSourceNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3859)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3860)
			p.TableSourceItem()
		}
		p.SetState(3864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-35)) & ^0x3f) == 0 && ((int64(1)<<(_la-35))&4647996290423062529) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&288230444871188481) != 0) {
			{
				p.SetState(3861)
				p.JoinPart()
			}

			p.SetState(3866)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3867)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableJsonContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3869)
			p.JsonTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceItemContext differentiates from other interfaces.
	IsTableSourceItemContext()
}

type TableSourceItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext {
	var p = new(TableSourceItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSourceItem
	return p
}

func InitEmptyTableSourceItemContext(p *TableSourceItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableSourceItem
}

func (*TableSourceItemContext) IsTableSourceItemContext() {}

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext {
	var p = new(TableSourceItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableSourceItem

	return p
}

func (s *TableSourceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceItemContext) CopyAll(ctx *TableSourceItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryTableItemContext struct {
	TableSourceItemContext
	parenthesisSubquery ISelectStatementContext
	alias               IUidContext
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext {
	var p = new(SubqueryTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext {
	return s.parenthesisSubquery
}

func (s *SubqueryTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) {
	s.parenthesisSubquery = v
}

func (s *SubqueryTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubqueryTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtomTableItemContext struct {
	TableSourceItemContext
	alias IUidContext
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext {
	var p = new(AtomTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *AtomTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *AtomTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTableItemContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AtomTableItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *AtomTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AtomTableItemContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AtomTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AtomTableItemContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *AtomTableItemContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *AtomTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AtomTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *AtomTableItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AtomTableItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAtomTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourcesItemContext struct {
	TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext {
	var p = new(TableSourcesItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableSourcesItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableSourceItem() (localctx ITableSourceItemContext) {
	localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MariaDBParserRULE_tableSourceItem)
	var _la int

	var _alt int

	p.SetState(3912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 564, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAtomTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3872)
			p.TableName()
		}
		p.SetState(3878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPARTITION {
			{
				p.SetState(3873)
				p.Match(MariaDBParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3874)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3875)
				p.UidList()
			}
			{
				p.SetState(3876)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3884)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 559, p.GetParserRuleContext()) == 1 {
			p.SetState(3881)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAS {
				{
					p.SetState(3880)
					p.Match(MariaDBParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3883)

				var _x = p.Uid()

				localctx.(*AtomTableItemContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3886)
				p.IndexHint()
			}
			p.SetState(3891)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3887)
						p.Match(MariaDBParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3888)
						p.IndexHint()
					}

				}
				p.SetState(3893)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSubqueryTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 562, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3896)
				p.SelectStatement()
			}

		case 2:
			{
				p.SetState(3897)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3898)

				var _x = p.SelectStatement()

				localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
			}
			{
				p.SetState(3899)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(3903)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3906)

			var _x = p.Uid()

			localctx.(*SubqueryTableItemContext).alias = _x
		}

	case 3:
		localctx = NewTableSourcesItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3908)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3909)
			p.TableSources()
		}
		{
			p.SetState(3910)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexHintAction returns the indexHintAction token.
	GetIndexHintAction() antlr.Token

	// GetKeyFormat returns the keyFormat token.
	GetKeyFormat() antlr.Token

	// SetIndexHintAction sets the indexHintAction token.
	SetIndexHintAction(antlr.Token)

	// SetKeyFormat sets the keyFormat token.
	SetKeyFormat(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	USE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	IndexHintType() IIndexHintTypeContext

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	indexHintAction antlr.Token
	keyFormat       antlr.Token
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexHint
	return p
}

func InitEmptyIndexHintContext(p *IndexHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexHint
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) GetIndexHintAction() antlr.Token { return s.indexHintAction }

func (s *IndexHintContext) GetKeyFormat() antlr.Token { return s.keyFormat }

func (s *IndexHintContext) SetIndexHintAction(v antlr.Token) { s.indexHintAction = v }

func (s *IndexHintContext) SetKeyFormat(v antlr.Token) { s.keyFormat = v }

func (s *IndexHintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *IndexHintContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IndexHintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *IndexHintContext) USE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSE, 0)
}

func (s *IndexHintContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *IndexHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFORCE, 0)
}

func (s *IndexHintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *IndexHintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *IndexHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MariaDBParserRULE_indexHint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3914)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).indexHintAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserFORCE || _la == MariaDBParserIGNORE || _la == MariaDBParserUSE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).indexHintAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3915)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).keyFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).keyFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFOR {
		{
			p.SetState(3916)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3917)
			p.IndexHintType()
		}

	}
	{
		p.SetState(3920)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3921)
		p.UidList()
	}
	{
		p.SetState(3922)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	GROUP() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexHintType
	return p
}

func InitEmptyIndexHintTypeContext(p *IndexHintTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexHintType
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJOIN, 0)
}

func (s *IndexHintTypeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDER, 0)
}

func (s *IndexHintTypeContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *IndexHintTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MariaDBParserRULE_indexHintType)
	p.SetState(3929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3924)
			p.Match(MariaDBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3925)
			p.Match(MariaDBParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3927)
			p.Match(MariaDBParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3928)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_joinPart
	return p
}

func InitEmptyJoinPartContext(p *JoinPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_joinPart
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) CopyAll(ctx *JoinPartContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJOIN, 0)
}

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *InnerJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATERAL, 0)
}

func (s *InnerJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *InnerJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InnerJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *InnerJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *InnerJoinContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InnerJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNER, 0)
}

func (s *InnerJoinContext) CROSS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCROSS, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

func (s *InnerJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInnerJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type NaturalJoinContext struct {
	JoinPartContext
}

func NewNaturalJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NaturalJoinContext {
	var p = new(NaturalJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *NaturalJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNATURAL, 0)
}

func (s *NaturalJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJOIN, 0)
}

func (s *NaturalJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *NaturalJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEFT, 0)
}

func (s *NaturalJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRIGHT, 0)
}

func (s *NaturalJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOUTER, 0)
}

func (s *NaturalJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNaturalJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type OuterJoinContext struct {
	JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJOIN, 0)
}

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEFT, 0)
}

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRIGHT, 0)
}

func (s *OuterJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *OuterJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OuterJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *OuterJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *OuterJoinContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *OuterJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOUTER, 0)
}

func (s *OuterJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATERAL, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (s *OuterJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOuterJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type StraightJoinContext struct {
	JoinPartContext
}

func NewStraightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StraightJoinContext {
	var p = new(StraightJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *StraightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StraightJoinContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRAIGHT_JOIN, 0)
}

func (s *StraightJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *StraightJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *StraightJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StraightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStraightJoin(s)
	}
}

func (s *StraightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStraightJoin(s)
	}
}

func (s *StraightJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStraightJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JoinPart() (localctx IJoinPartContext) {
	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MariaDBParserRULE_joinPart)
	var _la int

	p.SetState(3981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCROSS, MariaDBParserINNER, MariaDBParserJOIN:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCROSS || _la == MariaDBParserINNER {
			{
				p.SetState(3931)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserCROSS || _la == MariaDBParserINNER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3934)
			p.Match(MariaDBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3936)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3935)
				p.Match(MariaDBParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3938)
			p.TableSourceItem()
		}
		p.SetState(3946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3939)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3940)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3941)
				p.Match(MariaDBParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3942)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3943)
				p.UidList()
			}
			{
				p.SetState(3944)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserSTRAIGHT_JOIN:
		localctx = NewStraightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3948)
			p.Match(MariaDBParserSTRAIGHT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3949)
			p.TableSourceItem()
		}
		p.SetState(3952)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 570, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3950)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3951)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserLEFT, MariaDBParserRIGHT:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3954)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLEFT || _la == MariaDBParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserOUTER {
			{
				p.SetState(3955)
				p.Match(MariaDBParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3958)
			p.Match(MariaDBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 572, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3959)
				p.Match(MariaDBParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3962)
			p.TableSourceItem()
		}
		p.SetState(3970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserON:
			{
				p.SetState(3963)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3964)
				p.expression(0)
			}

		case MariaDBParserUSING:
			{
				p.SetState(3965)
				p.Match(MariaDBParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3966)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3967)
				p.UidList()
			}
			{
				p.SetState(3968)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MariaDBParserNATURAL:
		localctx = NewNaturalJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3972)
			p.Match(MariaDBParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLEFT || _la == MariaDBParserRIGHT {
			{
				p.SetState(3973)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserLEFT || _la == MariaDBParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(3975)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserOUTER {
				{
					p.SetState(3974)
					p.Match(MariaDBParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(3979)
			p.Match(MariaDBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3980)
			p.TableSourceItem()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecification() IQuerySpecificationContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MariaDBParserRULE_queryExpression)
	p.SetState(3991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 577, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3983)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3984)
			p.QuerySpecification()
		}
		{
			p.SetState(3985)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3987)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3988)
			p.QueryExpression()
		}
		{
			p.SetState(3989)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionNointoContext is an interface to support dynamic dispatch.
type IQueryExpressionNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext

	// IsQueryExpressionNointoContext differentiates from other interfaces.
	IsQueryExpressionNointoContext()
}

type QueryExpressionNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionNointoContext() *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_queryExpressionNointo
	return p
}

func InitEmptyQueryExpressionNointoContext(p *QueryExpressionNointoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_queryExpressionNointo
}

func (*QueryExpressionNointoContext) IsQueryExpressionNointoContext() {}

func NewQueryExpressionNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_queryExpressionNointo

	return p
}

func (s *QueryExpressionNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionNointoContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *QueryExpressionNointoContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *QueryExpressionNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitQueryExpressionNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) QueryExpressionNointo() (localctx IQueryExpressionNointoContext) {
	localctx = NewQueryExpressionNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MariaDBParserRULE_queryExpressionNointo)
	p.SetState(4001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3993)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3994)
			p.QuerySpecificationNointo()
		}
		{
			p.SetState(3995)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3997)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3998)
			p.QueryExpressionNointo()
		}
		{
			p.SetState(3999)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	SelectIntoExpression() ISelectIntoExpressionContext
	FromClause() IFromClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) SelectIntoExpression() ISelectIntoExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectIntoExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MariaDBParserRULE_querySpecification)
	var _la int

	var _alt int

	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4003)
			p.Match(MariaDBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4007)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4004)
					p.SelectSpec()
				}

			}
			p.SetState(4009)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.SelectElements()
		}
		p.SetState(4012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINTO {
			{
				p.SetState(4011)
				p.SelectIntoExpression()
			}

		}
		p.SetState(4015)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4014)
				p.FromClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4018)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 582, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4017)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserHAVING {
			{
				p.SetState(4020)
				p.HavingClause()
			}

		}
		p.SetState(4024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWINDOW {
			{
				p.SetState(4023)
				p.WindowClause()
			}

		}
		p.SetState(4027)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4026)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4030)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4029)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4032)
			p.Match(MariaDBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 587, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4033)
					p.SelectSpec()
				}

			}
			p.SetState(4038)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 587, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(4039)
			p.SelectElements()
		}
		p.SetState(4041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 588, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4040)
				p.FromClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4044)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 589, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4043)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserHAVING {
			{
				p.SetState(4046)
				p.HavingClause()
			}

		}
		p.SetState(4050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWINDOW {
			{
				p.SetState(4049)
				p.WindowClause()
			}

		}
		p.SetState(4053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4052)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 593, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4055)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINTO {
			{
				p.SetState(4058)
				p.SelectIntoExpression()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationNointoContext is an interface to support dynamic dispatch.
type IQuerySpecificationNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	FromClause() IFromClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationNointoContext differentiates from other interfaces.
	IsQuerySpecificationNointoContext()
}

type QuerySpecificationNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationNointoContext() *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_querySpecificationNointo
	return p
}

func InitEmptyQuerySpecificationNointoContext(p *QuerySpecificationNointoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_querySpecificationNointo
}

func (*QuerySpecificationNointoContext) IsQuerySpecificationNointoContext() {}

func NewQuerySpecificationNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_querySpecificationNointo

	return p
}

func (s *QuerySpecificationNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationNointoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSELECT, 0)
}

func (s *QuerySpecificationNointoContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationNointoContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationNointoContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationNointoContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationNointoContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationNointoContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationNointoContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationNointoContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationNointoContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitQuerySpecificationNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) QuerySpecificationNointo() (localctx IQuerySpecificationNointoContext) {
	localctx = NewQuerySpecificationNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MariaDBParserRULE_querySpecificationNointo)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4063)
		p.Match(MariaDBParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4064)
				p.SelectSpec()
			}

		}
		p.SetState(4069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4070)
		p.SelectElements()
	}
	p.SetState(4072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 597, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4071)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 598, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4074)
			p.GroupByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserHAVING {
		{
			p.SetState(4077)
			p.HavingClause()
		}

	}
	p.SetState(4081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWINDOW {
		{
			p.SetState(4080)
			p.WindowClause()
		}

	}
	p.SetState(4084)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 601, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4083)
			p.OrderByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 602, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4086)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionParenthesisContext is an interface to support dynamic dispatch.
type IUnionParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionParenthesisContext differentiates from other interfaces.
	IsUnionParenthesisContext()
}

type UnionParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionParenthesisContext() *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unionParenthesis
	return p
}

func InitEmptyUnionParenthesisContext(p *UnionParenthesisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unionParenthesis
}

func (*UnionParenthesisContext) IsUnionParenthesisContext() {}

func NewUnionParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_unionParenthesis

	return p
}

func (s *UnionParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParenthesisContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisContext) UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNION, 0)
}

func (s *UnionParenthesisContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *UnionParenthesisContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *UnionParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnionParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UnionParenthesis() (localctx IUnionParenthesisContext) {
	localctx = NewUnionParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MariaDBParserRULE_unionParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4089)
		p.Match(MariaDBParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserALL || _la == MariaDBParserDISTINCT {
		{
			p.SetState(4090)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionParenthesisContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserALL || _la == MariaDBParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionParenthesisContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4093)
		p.QueryExpressionNointo()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionStatementContext is an interface to support dynamic dispatch.
type IUnionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionStatementContext differentiates from other interfaces.
	IsUnionStatementContext()
}

type UnionStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatementContext() *UnionStatementContext {
	var p = new(UnionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unionStatement
	return p
}

func InitEmptyUnionStatementContext(p *UnionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unionStatement
}

func (*UnionStatementContext) IsUnionStatementContext() {}

func NewUnionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatementContext {
	var p = new(UnionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_unionStatement

	return p
}

func (s *UnionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatementContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionStatementContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionStatementContext) UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNION, 0)
}

func (s *UnionStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *UnionStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *UnionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnionStatement(s)
	}
}

func (s *UnionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnionStatement(s)
	}
}

func (s *UnionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UnionStatement() (localctx IUnionStatementContext) {
	localctx = NewUnionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MariaDBParserRULE_unionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4095)
		p.Match(MariaDBParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserALL || _la == MariaDBParserDISTINCT {
		{
			p.SetState(4096)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatementContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserALL || _la == MariaDBParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatementContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSELECT:
		{
			p.SetState(4099)
			p.QuerySpecificationNointo()
		}

	case MariaDBParserLR_BRACKET:
		{
			p.SetState(4100)
			p.QueryExpressionNointo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralStatementContext is an interface to support dynamic dispatch.
type ILateralStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LATERAL() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLateralStatementContext differentiates from other interfaces.
	IsLateralStatementContext()
}

type LateralStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLateralStatementContext() *LateralStatementContext {
	var p = new(LateralStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lateralStatement
	return p
}

func InitEmptyLateralStatementContext(p *LateralStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lateralStatement
}

func (*LateralStatementContext) IsLateralStatementContext() {}

func NewLateralStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralStatementContext {
	var p = new(LateralStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lateralStatement

	return p
}

func (s *LateralStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralStatementContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATERAL, 0)
}

func (s *LateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *LateralStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *LateralStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *LateralStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *LateralStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LateralStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *LateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLateralStatement(s)
	}
}

func (s *LateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLateralStatement(s)
	}
}

func (s *LateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LateralStatement() (localctx ILateralStatementContext) {
	localctx = NewLateralStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MariaDBParserRULE_lateralStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4103)
		p.Match(MariaDBParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4104)
			p.QuerySpecificationNointo()
		}

	case 2:
		{
			p.SetState(4105)
			p.QueryExpressionNointo()
		}

	case 3:
		{
			p.SetState(4106)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserSELECT:
			{
				p.SetState(4107)
				p.QuerySpecificationNointo()
			}

		case MariaDBParserLR_BRACKET:
			{
				p.SetState(4108)
				p.QueryExpressionNointo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4111)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4116)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			p.SetState(4113)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAS {
				{
					p.SetState(4112)
					p.Match(MariaDBParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4115)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonTableContext is an interface to support dynamic dispatch.
type IJsonTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsJsonTableContext differentiates from other interfaces.
	IsJsonTableContext()
}

type JsonTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonTableContext() *JsonTableContext {
	var p = new(JsonTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonTable
	return p
}

func InitEmptyJsonTableContext(p *JsonTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonTable
}

func (*JsonTableContext) IsJsonTableContext() {}

func NewJsonTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonTableContext {
	var p = new(JsonTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonTable

	return p
}

func (s *JsonTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonTableContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_TABLE, 0)
}

func (s *JsonTableContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *JsonTableContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *JsonTableContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *JsonTableContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *JsonTableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *JsonTableContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *JsonTableContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonTableContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *JsonTableContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *JsonTableContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *JsonTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *JsonTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonTable(s)
	}
}

func (s *JsonTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonTable(s)
	}
}

func (s *JsonTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonTable() (localctx IJsonTableContext) {
	localctx = NewJsonTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MariaDBParserRULE_jsonTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4120)
		p.Match(MariaDBParserJSON_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4121)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4122)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4123)
		p.Match(MariaDBParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4124)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4125)
		p.Match(MariaDBParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4126)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4127)
		p.JsonColumnList()
	}
	{
		p.SetState(4128)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4129)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4134)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 1 {
		p.SetState(4131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(4130)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4133)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonColumnListContext is an interface to support dynamic dispatch.
type IJsonColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJsonColumn() []IJsonColumnContext
	JsonColumn(i int) IJsonColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJsonColumnListContext differentiates from other interfaces.
	IsJsonColumnListContext()
}

type JsonColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnListContext() *JsonColumnListContext {
	var p = new(JsonColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonColumnList
	return p
}

func InitEmptyJsonColumnListContext(p *JsonColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonColumnList
}

func (*JsonColumnListContext) IsJsonColumnListContext() {}

func NewJsonColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnListContext {
	var p = new(JsonColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonColumnList

	return p
}

func (s *JsonColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnListContext) AllJsonColumn() []IJsonColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonColumnContext); ok {
			len++
		}
	}

	tst := make([]IJsonColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonColumnContext); ok {
			tst[i] = t.(IJsonColumnContext)
			i++
		}
	}

	return tst
}

func (s *JsonColumnListContext) JsonColumn(i int) IJsonColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnContext)
}

func (s *JsonColumnListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *JsonColumnListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *JsonColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonColumnList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonColumnList() (localctx IJsonColumnListContext) {
	localctx = NewJsonColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MariaDBParserRULE_jsonColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4136)
		p.JsonColumn()
	}
	p.SetState(4141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(4137)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4138)
			p.JsonColumn()
		}

		p.SetState(4143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonColumnContext is an interface to support dynamic dispatch.
type IJsonColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	FOR() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	JsonOnEmpty() IJsonOnEmptyContext
	JsonOnError() IJsonOnErrorContext
	NESTED() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJsonColumnContext differentiates from other interfaces.
	IsJsonColumnContext()
}

type JsonColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnContext() *JsonColumnContext {
	var p = new(JsonColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonColumn
	return p
}

func InitEmptyJsonColumnContext(p *JsonColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonColumn
}

func (*JsonColumnContext) IsJsonColumnContext() {}

func NewJsonColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnContext {
	var p = new(JsonColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonColumn

	return p
}

func (s *JsonColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *JsonColumnContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *JsonColumnContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDINALITY, 0)
}

func (s *JsonColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JsonColumnContext) PATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPATH, 0)
}

func (s *JsonColumnContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *JsonColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXISTS, 0)
}

func (s *JsonColumnContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonColumnContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonColumnContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNESTED, 0)
}

func (s *JsonColumnContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *JsonColumnContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *JsonColumnContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonColumnContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *JsonColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonColumn(s)
	}
}

func (s *JsonColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonColumn(s)
	}
}

func (s *JsonColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonColumn() (localctx IJsonColumnContext) {
	localctx = NewJsonColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MariaDBParserRULE_jsonColumn)
	var _la int

	p.SetState(4173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4144)
			p.FullColumnName()
		}
		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserFOR:
			{
				p.SetState(4145)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4146)
				p.Match(MariaDBParserORDINALITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserCHARACTER, MariaDBParserSET, MariaDBParserTINYINT, MariaDBParserSMALLINT, MariaDBParserMEDIUMINT, MariaDBParserMIDDLEINT, MariaDBParserINT, MariaDBParserINT1, MariaDBParserINT2, MariaDBParserINT3, MariaDBParserINT4, MariaDBParserINT8, MariaDBParserINTEGER, MariaDBParserBIGINT, MariaDBParserREAL, MariaDBParserDOUBLE, MariaDBParserFLOAT, MariaDBParserFLOAT4, MariaDBParserFLOAT8, MariaDBParserDECIMAL, MariaDBParserDEC, MariaDBParserNUMERIC, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserCHAR, MariaDBParserVARCHAR, MariaDBParserNVARCHAR, MariaDBParserNATIONAL, MariaDBParserBINARY, MariaDBParserVARBINARY, MariaDBParserTINYBLOB, MariaDBParserBLOB, MariaDBParserMEDIUMBLOB, MariaDBParserLONG, MariaDBParserLONGBLOB, MariaDBParserTINYTEXT, MariaDBParserTEXT, MariaDBParserMEDIUMTEXT, MariaDBParserLONGTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserBIT, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserFIXED, MariaDBParserJSON, MariaDBParserNCHAR, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserGEOMCOLLECTION, MariaDBParserGEOMETRY, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON:
			{
				p.SetState(4147)
				p.DataType()
			}
			p.SetState(4159)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserPATH:
				{
					p.SetState(4148)
					p.Match(MariaDBParserPATH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4149)
					p.Match(MariaDBParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4151)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 613, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4150)
						p.JsonOnEmpty()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(4154)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserDEFAULT || _la == MariaDBParserNULL_LITERAL || _la == MariaDBParserERROR {
					{
						p.SetState(4153)
						p.JsonOnError()
					}

				}

			case MariaDBParserEXISTS:
				{
					p.SetState(4156)
					p.Match(MariaDBParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4157)
					p.Match(MariaDBParserPATH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4158)
					p.Match(MariaDBParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4163)
			p.Match(MariaDBParserNESTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPATH {
			{
				p.SetState(4164)
				p.Match(MariaDBParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4167)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4168)
			p.Match(MariaDBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4169)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4170)
			p.JsonColumnList()
		}
		{
			p.SetState(4171)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOnEmptyContext is an interface to support dynamic dispatch.
type IJsonOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnEmptyContext differentiates from other interfaces.
	IsJsonOnEmptyContext()
}

type JsonOnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnEmptyContext() *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOnEmpty
	return p
}

func InitEmptyJsonOnEmptyContext(p *JsonOnEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOnEmpty
}

func (*JsonOnEmptyContext) IsJsonOnEmptyContext() {}

func NewJsonOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonOnEmpty

	return p
}

func (s *JsonOnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnEmptyContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *JsonOnEmptyContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEMPTY, 0)
}

func (s *JsonOnEmptyContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *JsonOnEmptyContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERROR, 0)
}

func (s *JsonOnEmptyContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *JsonOnEmptyContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonOnEmpty() (localctx IJsonOnEmptyContext) {
	localctx = NewJsonOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MariaDBParserRULE_jsonOnEmpty)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserNULL_LITERAL:
		{
			p.SetState(4175)
			p.Match(MariaDBParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserERROR:
		{
			p.SetState(4176)
			p.Match(MariaDBParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDEFAULT:
		{
			p.SetState(4177)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4178)
			p.DefaultValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4181)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4182)
		p.Match(MariaDBParserEMPTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOnErrorContext is an interface to support dynamic dispatch.
type IJsonOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnErrorContext differentiates from other interfaces.
	IsJsonOnErrorContext()
}

type JsonOnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnErrorContext() *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOnError
	return p
}

func InitEmptyJsonOnErrorContext(p *JsonOnErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOnError
}

func (*JsonOnErrorContext) IsJsonOnErrorContext() {}

func NewJsonOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonOnError

	return p
}

func (s *JsonOnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnErrorContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *JsonOnErrorContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserERROR)
}

func (s *JsonOnErrorContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserERROR, i)
}

func (s *JsonOnErrorContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *JsonOnErrorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *JsonOnErrorContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonOnError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonOnError() (localctx IJsonOnErrorContext) {
	localctx = NewJsonOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MariaDBParserRULE_jsonOnError)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserNULL_LITERAL:
		{
			p.SetState(4184)
			p.Match(MariaDBParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserERROR:
		{
			p.SetState(4185)
			p.Match(MariaDBParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDEFAULT:
		{
			p.SetState(4186)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4187)
			p.DefaultValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4190)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4191)
		p.Match(MariaDBParserERROR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTINCTROW() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	STRAIGHT_JOIN() antlr.TerminalNode
	SQL_SMALL_RESULT() antlr.TerminalNode
	SQL_BIG_RESULT() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS() antlr.TerminalNode

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectSpec
	return p
}

func InitEmptySelectSpecContext(p *SelectSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectSpec
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectSpec(s)
	}
}

func (s *SelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectSpec(s)
	}
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectSpec() (localctx ISelectSpecContext) {
	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MariaDBParserRULE_selectSpec)
	var _la int

	p.SetState(4201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserALL, MariaDBParserDISTINCT, MariaDBParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4193)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3377699720527936) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4194)
			p.Match(MariaDBParserHIGH_PRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4195)
			p.Match(MariaDBParserSTRAIGHT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4196)
			p.Match(MariaDBParserSQL_SMALL_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4197)
			p.Match(MariaDBParserSQL_BIG_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4198)
			p.Match(MariaDBParserSQL_BUFFER_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4199)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSQL_CACHE || _la == MariaDBParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4200)
			p.Match(MariaDBParserSQL_CALC_FOUND_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MariaDBParserRULE_selectElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 622, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4203)

			var _m = p.Match(MariaDBParserSTAR)

			localctx.(*SelectElementsContext).star = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4204)
			p.SelectElement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 623, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4207)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4208)
				p.SelectElement()
			}

		}
		p.SetState(4213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 623, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyAll(ctx *SelectElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectExpressionElementContext struct {
	SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext {
	var p = new(SelectExpressionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionElementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *SelectExpressionElementContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_ASSIGN, 0)
}

func (s *SelectExpressionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectExpressionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectFunctionElementContext struct {
	SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectStarElementContext struct {
	SelectElementContext
}

func NewSelectStarElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStarElementContext {
	var p = new(SelectStarElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectStarElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStarElementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SelectStarElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *SelectStarElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *SelectStarElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectStarElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectColumnElementContext struct {
	SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MariaDBParserRULE_selectElement)
	var _la int

	p.SetState(4243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 631, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectStarElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4214)
			p.FullId()
		}
		{
			p.SetState(4215)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4216)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4218)
			p.FullColumnName()
		}
		p.SetState(4223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext()) == 1 {
			p.SetState(4220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAS {
				{
					p.SetState(4219)
					p.Match(MariaDBParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4222)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4225)
			p.FunctionCall()
		}
		p.SetState(4230)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext()) == 1 {
			p.SetState(4227)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAS {
				{
					p.SetState(4226)
					p.Match(MariaDBParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4229)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewSelectExpressionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4234)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4232)
				p.Match(MariaDBParserLOCAL_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4233)
				p.Match(MariaDBParserVAR_ASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4236)
			p.expression(0)
		}
		p.SetState(4241)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) == 1 {
			p.SetState(4238)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAS {
				{
					p.SetState(4237)
					p.Match(MariaDBParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4240)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectIntoExpressionContext is an interface to support dynamic dispatch.
type ISelectIntoExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectIntoExpressionContext differentiates from other interfaces.
	IsSelectIntoExpressionContext()
}

type SelectIntoExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectIntoExpressionContext() *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectIntoExpression
	return p
}

func InitEmptySelectIntoExpressionContext(p *SelectIntoExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectIntoExpression
}

func (*SelectIntoExpressionContext) IsSelectIntoExpressionContext() {}

func NewSelectIntoExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectIntoExpression

	return p
}

func (s *SelectIntoExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectIntoExpressionContext) CopyAll(ctx *SelectIntoExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectIntoExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectIntoVariablesContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoVariablesContext {
	var p = new(SelectIntoVariablesContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoVariablesContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *SelectIntoVariablesContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoVariablesContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *SelectIntoVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SelectIntoVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SelectIntoVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectIntoVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoTextFileContext struct {
	SelectIntoExpressionContext
	filename     antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
}

func NewSelectIntoTextFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoTextFileContext {
	var p = new(SelectIntoTextFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoTextFileContext) GetFilename() antlr.Token { return s.filename }

func (s *SelectIntoTextFileContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *SelectIntoTextFileContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *SelectIntoTextFileContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *SelectIntoTextFileContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *SelectIntoTextFileContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *SelectIntoTextFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoTextFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *SelectIntoTextFileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOUTFILE, 0)
}

func (s *SelectIntoTextFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SelectIntoTextFileContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *SelectIntoTextFileContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SelectIntoTextFileContext) LINES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINES, 0)
}

func (s *SelectIntoTextFileContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SelectIntoTextFileContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIELDS, 0)
}

func (s *SelectIntoTextFileContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *SelectIntoTextFileContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *SelectIntoTextFileContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *SelectIntoTextFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectIntoTextFile(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoDumpFileContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoDumpFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoDumpFileContext {
	var p = new(SelectIntoDumpFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoDumpFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoDumpFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *SelectIntoDumpFileContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDUMPFILE, 0)
}

func (s *SelectIntoDumpFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SelectIntoDumpFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectIntoDumpFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectIntoExpression() (localctx ISelectIntoExpressionContext) {
	localctx = NewSelectIntoExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MariaDBParserRULE_selectIntoExpression)
	var _la int

	p.SetState(4281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 638, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectIntoVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4245)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4246)
			p.AssignmentField()
		}
		p.SetState(4251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4247)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4248)
				p.AssignmentField()
			}

			p.SetState(4253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSelectIntoDumpFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4254)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4255)
			p.Match(MariaDBParserDUMPFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4256)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectIntoTextFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4257)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4258)
			p.Match(MariaDBParserOUTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4259)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectIntoTextFileContext).filename = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCHARACTER {
			{
				p.SetState(4260)
				p.Match(MariaDBParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4261)
				p.Match(MariaDBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4262)

				var _x = p.CharsetName()

				localctx.(*SelectIntoTextFileContext).charset = _x
			}

		}
		p.SetState(4271)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4265)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SelectIntoTextFileContext).fieldsFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserCOLUMNS || _la == MariaDBParserFIELDS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SelectIntoTextFileContext).fieldsFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4267)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MariaDBParserENCLOSED || _la == MariaDBParserESCAPED || _la == MariaDBParserOPTIONALLY || _la == MariaDBParserTERMINATED {
				{
					p.SetState(4266)
					p.SelectFieldsInto()
				}

				p.SetState(4269)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLINES {
			{
				p.SetState(4273)
				p.Match(MariaDBParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4275)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MariaDBParserSTARTING || _la == MariaDBParserTERMINATED {
				{
					p.SetState(4274)
					p.SelectLinesInto()
				}

				p.SetState(4277)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectFieldsIntoContext is an interface to support dynamic dispatch.
type ISelectFieldsIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTerminationField returns the terminationField token.
	GetTerminationField() antlr.Token

	// GetEnclosion returns the enclosion token.
	GetEnclosion() antlr.Token

	// GetEscaping returns the escaping token.
	GetEscaping() antlr.Token

	// SetTerminationField sets the terminationField token.
	SetTerminationField(antlr.Token)

	// SetEnclosion sets the enclosion token.
	SetEnclosion(antlr.Token)

	// SetEscaping sets the escaping token.
	SetEscaping(antlr.Token)

	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENCLOSED() antlr.TerminalNode
	OPTIONALLY() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode

	// IsSelectFieldsIntoContext differentiates from other interfaces.
	IsSelectFieldsIntoContext()
}

type SelectFieldsIntoContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	terminationField antlr.Token
	enclosion        antlr.Token
	escaping         antlr.Token
}

func NewEmptySelectFieldsIntoContext() *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectFieldsInto
	return p
}

func InitEmptySelectFieldsIntoContext(p *SelectFieldsIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectFieldsInto
}

func (*SelectFieldsIntoContext) IsSelectFieldsIntoContext() {}

func NewSelectFieldsIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectFieldsInto

	return p
}

func (s *SelectFieldsIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldsIntoContext) GetTerminationField() antlr.Token { return s.terminationField }

func (s *SelectFieldsIntoContext) GetEnclosion() antlr.Token { return s.enclosion }

func (s *SelectFieldsIntoContext) GetEscaping() antlr.Token { return s.escaping }

func (s *SelectFieldsIntoContext) SetTerminationField(v antlr.Token) { s.terminationField = v }

func (s *SelectFieldsIntoContext) SetEnclosion(v antlr.Token) { s.enclosion = v }

func (s *SelectFieldsIntoContext) SetEscaping(v antlr.Token) { s.escaping = v }

func (s *SelectFieldsIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTERMINATED, 0)
}

func (s *SelectFieldsIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *SelectFieldsIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SelectFieldsIntoContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCLOSED, 0)
}

func (s *SelectFieldsIntoContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONALLY, 0)
}

func (s *SelectFieldsIntoContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserESCAPED, 0)
}

func (s *SelectFieldsIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldsIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectFieldsIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectFieldsInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectFieldsInto() (localctx ISelectFieldsIntoContext) {
	localctx = NewSelectFieldsIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MariaDBParserRULE_selectFieldsInto)
	var _la int

	p.SetState(4295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4283)
			p.Match(MariaDBParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4284)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4285)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).terminationField = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserENCLOSED, MariaDBParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserOPTIONALLY {
			{
				p.SetState(4286)
				p.Match(MariaDBParserOPTIONALLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4289)
			p.Match(MariaDBParserENCLOSED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4290)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4291)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).enclosion = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserESCAPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4292)
			p.Match(MariaDBParserESCAPED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).escaping = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectLinesIntoContext is an interface to support dynamic dispatch.
type ISelectLinesIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarting returns the starting token.
	GetStarting() antlr.Token

	// GetTerminationLine returns the terminationLine token.
	GetTerminationLine() antlr.Token

	// SetStarting sets the starting token.
	SetStarting(antlr.Token)

	// SetTerminationLine sets the terminationLine token.
	SetTerminationLine(antlr.Token)

	// Getter signatures
	STARTING() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode

	// IsSelectLinesIntoContext differentiates from other interfaces.
	IsSelectLinesIntoContext()
}

type SelectLinesIntoContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	starting        antlr.Token
	terminationLine antlr.Token
}

func NewEmptySelectLinesIntoContext() *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectLinesInto
	return p
}

func InitEmptySelectLinesIntoContext(p *SelectLinesIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_selectLinesInto
}

func (*SelectLinesIntoContext) IsSelectLinesIntoContext() {}

func NewSelectLinesIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_selectLinesInto

	return p
}

func (s *SelectLinesIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectLinesIntoContext) GetStarting() antlr.Token { return s.starting }

func (s *SelectLinesIntoContext) GetTerminationLine() antlr.Token { return s.terminationLine }

func (s *SelectLinesIntoContext) SetStarting(v antlr.Token) { s.starting = v }

func (s *SelectLinesIntoContext) SetTerminationLine(v antlr.Token) { s.terminationLine = v }

func (s *SelectLinesIntoContext) STARTING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTARTING, 0)
}

func (s *SelectLinesIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *SelectLinesIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SelectLinesIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTERMINATED, 0)
}

func (s *SelectLinesIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectLinesIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectLinesIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSelectLinesInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SelectLinesInto() (localctx ISelectLinesIntoContext) {
	localctx = NewSelectLinesIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MariaDBParserRULE_selectLinesInto)
	p.SetState(4303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSTARTING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4297)
			p.Match(MariaDBParserSTARTING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4298)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4299)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).starting = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserTERMINATED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4300)
			p.Match(MariaDBParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4301)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4302)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).terminationLine = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	whereExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MariaDBParserRULE_fromClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFROM {
		{
			p.SetState(4305)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4306)
			p.TableSources()
		}

	}
	p.SetState(4311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWHERE {
		{
			p.SetState(4309)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4310)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllGroupByItem() []IGroupByItemContext
	GroupByItem(i int) IGroupByItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *GroupByClauseContext) AllGroupByItem() []IGroupByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByItemContext); ok {
			len++
		}
	}

	tst := make([]IGroupByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByItemContext); ok {
			tst[i] = t.(IGroupByItemContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) GroupByItem(i int) IGroupByItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *GroupByClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, MariaDBParserRULE_groupByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4313)
		p.Match(MariaDBParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4314)
		p.Match(MariaDBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4315)
		p.GroupByItem()
	}
	p.SetState(4320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 644, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4316)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4317)
				p.GroupByItem()
			}

		}
		p.SetState(4322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 644, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4325)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 645, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4323)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4324)
			p.Match(MariaDBParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHavingExpr returns the havingExpr rule contexts.
	GetHavingExpr() IExpressionContext

	// SetHavingExpr sets the havingExpr rule contexts.
	SetHavingExpr(IExpressionContext)

	// Getter signatures
	HAVING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	havingExpr IExpressionContext
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) GetHavingExpr() IExpressionContext { return s.havingExpr }

func (s *HavingClauseContext) SetHavingExpr(v IExpressionContext) { s.havingExpr = v }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHAVING, 0)
}

func (s *HavingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, MariaDBParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4327)
		p.Match(MariaDBParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4328)

		var _x = p.expression(0)

		localctx.(*HavingClauseContext).havingExpr = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	AllWindowName() []IWindowNameContext
	WindowName(i int) IWindowNameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllWindowSpec() []IWindowSpecContext
	WindowSpec(i int) IWindowSpecContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWINDOW, 0)
}

func (s *WindowClauseContext) AllWindowName() []IWindowNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowNameContext); ok {
			len++
		}
	}

	tst := make([]IWindowNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowNameContext); ok {
			tst[i] = t.(IWindowNameContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowName(i int) IWindowNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowClauseContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserAS)
}

func (s *WindowClauseContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, i)
}

func (s *WindowClauseContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *WindowClauseContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *WindowClauseContext) AllWindowSpec() []IWindowSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowSpecContext); ok {
			len++
		}
	}

	tst := make([]IWindowSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowSpecContext); ok {
			tst[i] = t.(IWindowSpecContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowSpec(i int) IWindowSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowClauseContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *WindowClauseContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MariaDBParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4330)
		p.Match(MariaDBParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4331)
		p.WindowName()
	}
	{
		p.SetState(4332)
		p.Match(MariaDBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4333)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4334)
		p.WindowSpec()
	}
	{
		p.SetState(4335)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 646, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4336)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4337)
				p.WindowName()
			}
			{
				p.SetState(4338)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4339)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4340)
				p.WindowSpec()
			}
			{
				p.SetState(4341)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 646, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_groupByItem
	return p
}

func InitEmptyGroupByItemContext(p *GroupByItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_groupByItem
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) GetOrder() antlr.Token { return s.order }

func (s *GroupByItemContext) SetOrder(v antlr.Token) { s.order = v }

func (s *GroupByItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASC, 0)
}

func (s *GroupByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGroupByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) GroupByItem() (localctx IGroupByItemContext) {
	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MariaDBParserRULE_groupByItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4348)
		p.expression(0)
	}
	p.SetState(4350)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 647, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4349)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupByItemContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserASC || _la == MariaDBParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupByItemContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllLimitClauseAtom() []ILimitClauseAtomContext
	LimitClauseAtom(i int) ILimitClauseAtomContext
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MariaDBParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4352)
		p.Match(MariaDBParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 649, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4356)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 648, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4353)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(4354)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4358)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(4359)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(4360)
			p.Match(MariaDBParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4361)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_limitClauseAtom
	return p
}

func InitEmptyLimitClauseAtomContext(p *LimitClauseAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_limitClauseAtom
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *LimitClauseAtomContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MariaDBParserRULE_limitClauseAtom)
	p.SetState(4368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4365)
			p.DecimalLiteral()
		}

	case MariaDBParserLOCAL_ID, MariaDBParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4366)
			p.MysqlVariable()
		}

	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4367)
			p.SimpleId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartTransactionContext is an interface to support dynamic dispatch.
type IStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartTransactionContext differentiates from other interfaces.
	IsStartTransactionContext()
}

type StartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionContext() *StartTransactionContext {
	var p = new(StartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startTransaction
	return p
}

func InitEmptyStartTransactionContext(p *StartTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startTransaction
}

func (*StartTransactionContext) IsStartTransactionContext() {}

func NewStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionContext {
	var p = new(StartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_startTransaction

	return p
}

func (s *StartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *StartTransactionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (s *StartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StartTransaction() (localctx IStartTransactionContext) {
	localctx = NewStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MariaDBParserRULE_startTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4370)
		p.Match(MariaDBParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4371)
		p.Match(MariaDBParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserREAD || _la == MariaDBParserWITH {
		{
			p.SetState(4372)
			p.TransactionMode()
		}
		p.SetState(4377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4373)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4374)
				p.TransactionMode()
			}

			p.SetState(4379)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_beginWork
	return p
}

func InitEmptyBeginWorkContext(p *BeginWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_beginWork
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEGIN, 0)
}

func (s *BeginWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWORK, 0)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (s *BeginWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBeginWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BeginWork() (localctx IBeginWorkContext) {
	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MariaDBParserRULE_beginWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4382)
		p.Match(MariaDBParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWORK {
		{
			p.SetState(4383)
			p.Match(MariaDBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitWorkContext is an interface to support dynamic dispatch.
type ICommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitWorkContext differentiates from other interfaces.
	IsCommitWorkContext()
}

type CommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyCommitWorkContext() *CommitWorkContext {
	var p = new(CommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_commitWork
	return p
}

func InitEmptyCommitWorkContext(p *CommitWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_commitWork
}

func (*CommitWorkContext) IsCommitWorkContext() {}

func NewCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitWorkContext {
	var p = new(CommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_commitWork

	return p
}

func (s *CommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *CommitWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *CommitWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *CommitWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *CommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMIT, 0)
}

func (s *CommitWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWORK, 0)
}

func (s *CommitWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, 0)
}

func (s *CommitWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAIN, 0)
}

func (s *CommitWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELEASE, 0)
}

func (s *CommitWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNO)
}

func (s *CommitWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, i)
}

func (s *CommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCommitWork(s)
	}
}

func (s *CommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCommitWork(s)
	}
}

func (s *CommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CommitWork() (localctx ICommitWorkContext) {
	localctx = NewCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MariaDBParserRULE_commitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4386)
		p.Match(MariaDBParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWORK {
		{
			p.SetState(4387)
			p.Match(MariaDBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserAND {
		{
			p.SetState(4390)
			p.Match(MariaDBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNO {
			{
				p.SetState(4391)

				var _m = p.Match(MariaDBParserNO)

				localctx.(*CommitWorkContext).nochain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4394)
			p.Match(MariaDBParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4401)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 658, p.GetParserRuleContext()) == 1 {
		p.SetState(4398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNO {
			{
				p.SetState(4397)

				var _m = p.Match(MariaDBParserNO)

				localctx.(*CommitWorkContext).norelease = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4400)
			p.Match(MariaDBParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackWorkContext is an interface to support dynamic dispatch.
type IRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackWorkContext differentiates from other interfaces.
	IsRollbackWorkContext()
}

type RollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyRollbackWorkContext() *RollbackWorkContext {
	var p = new(RollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_rollbackWork
	return p
}

func InitEmptyRollbackWorkContext(p *RollbackWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_rollbackWork
}

func (*RollbackWorkContext) IsRollbackWorkContext() {}

func NewRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackWorkContext {
	var p = new(RollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_rollbackWork

	return p
}

func (s *RollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *RollbackWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *RollbackWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *RollbackWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *RollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLBACK, 0)
}

func (s *RollbackWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWORK, 0)
}

func (s *RollbackWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, 0)
}

func (s *RollbackWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAIN, 0)
}

func (s *RollbackWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELEASE, 0)
}

func (s *RollbackWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNO)
}

func (s *RollbackWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, i)
}

func (s *RollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRollbackWork(s)
	}
}

func (s *RollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRollbackWork(s)
	}
}

func (s *RollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RollbackWork() (localctx IRollbackWorkContext) {
	localctx = NewRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MariaDBParserRULE_rollbackWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4403)
		p.Match(MariaDBParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWORK {
		{
			p.SetState(4404)
			p.Match(MariaDBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserAND {
		{
			p.SetState(4407)
			p.Match(MariaDBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNO {
			{
				p.SetState(4408)

				var _m = p.Match(MariaDBParserNO)

				localctx.(*RollbackWorkContext).nochain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4411)
			p.Match(MariaDBParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4418)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) == 1 {
		p.SetState(4415)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNO {
			{
				p.SetState(4414)

				var _m = p.Match(MariaDBParserNO)

				localctx.(*RollbackWorkContext).norelease = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4417)
			p.Match(MariaDBParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_savepointStatement
	return p
}

func InitEmptySavepointStatementContext(p *SavepointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_savepointStatement
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSAVEPOINT, 0)
}

func (s *SavepointStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSavepointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SavepointStatement() (localctx ISavepointStatementContext) {
	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MariaDBParserRULE_savepointStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4420)
		p.Match(MariaDBParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4421)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	TO() antlr.TerminalNode
	Uid() IUidContext
	WORK() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLBACK, 0)
}

func (s *RollbackStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *RollbackStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWORK, 0)
}

func (s *RollbackStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSAVEPOINT, 0)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MariaDBParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4423)
		p.Match(MariaDBParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWORK {
		{
			p.SetState(4424)
			p.Match(MariaDBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4427)
		p.Match(MariaDBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 665, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4428)
			p.Match(MariaDBParserSAVEPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4431)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELEASE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_releaseStatement
	return p
}

func InitEmptyReleaseStatementContext(p *ReleaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_releaseStatement
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELEASE, 0)
}

func (s *ReleaseStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSAVEPOINT, 0)
}

func (s *ReleaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReleaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReleaseStatement() (localctx IReleaseStatementContext) {
	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MariaDBParserRULE_releaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4433)
		p.Match(MariaDBParserRELEASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4434)
		p.Match(MariaDBParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4435)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTablesContext is an interface to support dynamic dispatch.
type ILockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	AllLockTableElement() []ILockTableElementContext
	LockTableElement(i int) ILockTableElementContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsLockTablesContext differentiates from other interfaces.
	IsLockTablesContext()
}

type LockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTablesContext() *LockTablesContext {
	var p = new(LockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockTables
	return p
}

func InitEmptyLockTablesContext(p *LockTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockTables
}

func (*LockTablesContext) IsLockTablesContext() {}

func NewLockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTablesContext {
	var p = new(LockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lockTables

	return p
}

func (s *LockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *LockTablesContext) AllLockTableElement() []ILockTableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableElementContext); ok {
			len++
		}
	}

	tst := make([]ILockTableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableElementContext); ok {
			tst[i] = t.(ILockTableElementContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTableElement(i int) ILockTableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableElementContext)
}

func (s *LockTablesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *LockTablesContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

func (s *LockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LockTables() (localctx ILockTablesContext) {
	localctx = NewLockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MariaDBParserRULE_lockTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4437)
		p.Match(MariaDBParserLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4438)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserTABLE || _la == MariaDBParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4439)
		p.LockTableElement()
	}
	p.SetState(4444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(4440)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4441)
			p.LockTableElement()
		}

		p.SetState(4446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(4447)
			p.WaitNowaitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlockTablesContext is an interface to support dynamic dispatch.
type IUnlockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNLOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsUnlockTablesContext differentiates from other interfaces.
	IsUnlockTablesContext()
}

type UnlockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockTablesContext() *UnlockTablesContext {
	var p = new(UnlockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unlockTables
	return p
}

func InitEmptyUnlockTablesContext(p *UnlockTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unlockTables
}

func (*UnlockTablesContext) IsUnlockTablesContext() {}

func NewUnlockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_unlockTables

	return p
}

func (s *UnlockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

func (s *UnlockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnlockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UnlockTables() (localctx IUnlockTablesContext) {
	localctx = NewUnlockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MariaDBParserRULE_unlockTables)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4450)
		p.Match(MariaDBParserUNLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4451)
		p.Match(MariaDBParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetAutocommitStatementContext is an interface to support dynamic dispatch.
type ISetAutocommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutocommitValue returns the autocommitValue token.
	GetAutocommitValue() antlr.Token

	// SetAutocommitValue sets the autocommitValue token.
	SetAutocommitValue(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsSetAutocommitStatementContext differentiates from other interfaces.
	IsSetAutocommitStatementContext()
}

type SetAutocommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	autocommitValue antlr.Token
}

func NewEmptySetAutocommitStatementContext() *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setAutocommitStatement
	return p
}

func InitEmptySetAutocommitStatementContext(p *SetAutocommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setAutocommitStatement
}

func (*SetAutocommitStatementContext) IsSetAutocommitStatementContext() {}

func NewSetAutocommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setAutocommitStatement

	return p
}

func (s *SetAutocommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAutocommitStatementContext) GetAutocommitValue() antlr.Token { return s.autocommitValue }

func (s *SetAutocommitStatementContext) SetAutocommitValue(v antlr.Token) { s.autocommitValue = v }

func (s *SetAutocommitStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetAutocommitStatementContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTOCOMMIT, 0)
}

func (s *SetAutocommitStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *SetAutocommitStatementContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAutocommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetAutocommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetAutocommitStatement() (localctx ISetAutocommitStatementContext) {
	localctx = NewSetAutocommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MariaDBParserRULE_setAutocommitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4453)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4454)
		p.Match(MariaDBParserAUTOCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4455)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4456)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SetAutocommitStatementContext).autocommitValue = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SetAutocommitStatementContext).autocommitValue = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTransactionStatementContext is an interface to support dynamic dispatch.
type ISetTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTransactionContext returns the transactionContext token.
	GetTransactionContext() antlr.Token

	// SetTransactionContext sets the transactionContext token.
	SetTransactionContext(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionOption() []ITransactionOptionContext
	TransactionOption(i int) ITransactionOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsSetTransactionStatementContext differentiates from other interfaces.
	IsSetTransactionStatementContext()
}

type SetTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	transactionContext antlr.Token
}

func NewEmptySetTransactionStatementContext() *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setTransactionStatement
	return p
}

func InitEmptySetTransactionStatementContext(p *SetTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setTransactionStatement
}

func (*SetTransactionStatementContext) IsSetTransactionStatementContext() {}

func NewSetTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setTransactionStatement

	return p
}

func (s *SetTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionStatementContext) GetTransactionContext() antlr.Token {
	return s.transactionContext
}

func (s *SetTransactionStatementContext) SetTransactionContext(v antlr.Token) {
	s.transactionContext = v
}

func (s *SetTransactionStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTION, 0)
}

func (s *SetTransactionStatementContext) AllTransactionOption() []ITransactionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			len++
		}
	}

	tst := make([]ITransactionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionOptionContext); ok {
			tst[i] = t.(ITransactionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SetTransactionStatementContext) TransactionOption(i int) ITransactionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOptionContext)
}

func (s *SetTransactionStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SetTransactionStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SetTransactionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL, 0)
}

func (s *SetTransactionStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION, 0)
}

func (s *SetTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetTransactionStatement() (localctx ISetTransactionStatementContext) {
	localctx = NewSetTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MariaDBParserRULE_setTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4458)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserGLOBAL || _la == MariaDBParserSESSION {
		{
			p.SetState(4459)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SetTransactionStatementContext).transactionContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserGLOBAL || _la == MariaDBParserSESSION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SetTransactionStatementContext).transactionContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4462)
		p.Match(MariaDBParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4463)
		p.TransactionOption()
	}
	p.SetState(4468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(4464)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4465)
			p.TransactionOption()
		}

		p.SetState(4470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *TransactionModeContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSISTENT, 0)
}

func (s *TransactionModeContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSNAPSHOT, 0)
}

func (s *TransactionModeContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *TransactionModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWRITE, 0)
}

func (s *TransactionModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLY, 0)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (s *TransactionModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTransactionMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MariaDBParserRULE_transactionMode)
	p.SetState(4478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 670, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4471)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4472)
			p.Match(MariaDBParserCONSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4473)
			p.Match(MariaDBParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4474)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4475)
			p.Match(MariaDBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4476)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4477)
			p.Match(MariaDBParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTableElementContext is an interface to support dynamic dispatch.
type ILockTableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	LockAction() ILockActionContext
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLockTableElementContext differentiates from other interfaces.
	IsLockTableElementContext()
}

type LockTableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTableElementContext() *LockTableElementContext {
	var p = new(LockTableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockTableElement
	return p
}

func InitEmptyLockTableElementContext(p *LockTableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockTableElement
}

func (*LockTableElementContext) IsLockTableElementContext() {}

func NewLockTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableElementContext {
	var p = new(LockTableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lockTableElement

	return p
}

func (s *LockTableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableElementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LockTableElementContext) LockAction() ILockActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockActionContext)
}

func (s *LockTableElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LockTableElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *LockTableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLockTableElement(s)
	}
}

func (s *LockTableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLockTableElement(s)
	}
}

func (s *LockTableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLockTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LockTableElement() (localctx ILockTableElementContext) {
	localctx = NewLockTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MariaDBParserRULE_lockTableElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4480)
		p.TableName()
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010177536) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		p.SetState(4482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(4481)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4484)
			p.Uid()
		}

	}
	{
		p.SetState(4487)
		p.LockAction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockActionContext is an interface to support dynamic dispatch.
type ILockActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockActionContext differentiates from other interfaces.
	IsLockActionContext()
}

type LockActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockActionContext() *LockActionContext {
	var p = new(LockActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockAction
	return p
}

func InitEmptyLockActionContext(p *LockActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockAction
}

func (*LockActionContext) IsLockActionContext() {}

func NewLockActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockActionContext {
	var p = new(LockActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lockAction

	return p
}

func (s *LockActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockActionContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *LockActionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *LockActionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWRITE, 0)
}

func (s *LockActionContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOW_PRIORITY, 0)
}

func (s *LockActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLockAction(s)
	}
}

func (s *LockActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLockAction(s)
	}
}

func (s *LockActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLockAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LockAction() (localctx ILockActionContext) {
	localctx = NewLockActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MariaDBParserRULE_lockAction)
	var _la int

	p.SetState(4497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4489)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLOCAL {
			{
				p.SetState(4490)
				p.Match(MariaDBParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MariaDBParserLOW_PRIORITY, MariaDBParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLOW_PRIORITY {
			{
				p.SetState(4493)
				p.Match(MariaDBParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4496)
			p.Match(MariaDBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionOptionContext is an interface to support dynamic dispatch.
type ITransactionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	TransactionLevel() ITransactionLevelContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionOptionContext differentiates from other interfaces.
	IsTransactionOptionContext()
}

type TransactionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOptionContext() *TransactionOptionContext {
	var p = new(TransactionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionOption
	return p
}

func InitEmptyTransactionOptionContext(p *TransactionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionOption
}

func (*TransactionOptionContext) IsTransactionOptionContext() {}

func NewTransactionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOptionContext {
	var p = new(TransactionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_transactionOption

	return p
}

func (s *TransactionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOptionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISOLATION, 0)
}

func (s *TransactionOptionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEVEL, 0)
}

func (s *TransactionOptionContext) TransactionLevel() ITransactionLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelContext)
}

func (s *TransactionOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *TransactionOptionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWRITE, 0)
}

func (s *TransactionOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLY, 0)
}

func (s *TransactionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTransactionOption(s)
	}
}

func (s *TransactionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTransactionOption(s)
	}
}

func (s *TransactionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTransactionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TransactionOption() (localctx ITransactionOptionContext) {
	localctx = NewTransactionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MariaDBParserRULE_transactionOption)
	p.SetState(4506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4499)
			p.Match(MariaDBParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4500)
			p.Match(MariaDBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4501)
			p.TransactionLevel()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4502)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4503)
			p.Match(MariaDBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4504)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4505)
			p.Match(MariaDBParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionLevelContext is an interface to support dynamic dispatch.
type ITransactionLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	READ() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelContext differentiates from other interfaces.
	IsTransactionLevelContext()
}

type TransactionLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelContext() *TransactionLevelContext {
	var p = new(TransactionLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionLevel
	return p
}

func InitEmptyTransactionLevelContext(p *TransactionLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionLevel
}

func (*TransactionLevelContext) IsTransactionLevelContext() {}

func NewTransactionLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelContext {
	var p = new(TransactionLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_transactionLevel

	return p
}

func (s *TransactionLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPEATABLE, 0)
}

func (s *TransactionLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *TransactionLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMITTED, 0)
}

func (s *TransactionLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNCOMMITTED, 0)
}

func (s *TransactionLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERIALIZABLE, 0)
}

func (s *TransactionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTransactionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TransactionLevel() (localctx ITransactionLevelContext) {
	localctx = NewTransactionLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MariaDBParserRULE_transactionLevel)
	p.SetState(4515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4508)
			p.Match(MariaDBParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4509)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4510)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4511)
			p.Match(MariaDBParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4512)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4513)
			p.Match(MariaDBParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4514)
			p.Match(MariaDBParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_changeMaster
	return p
}

func InitEmptyChangeMasterContext(p *ChangeMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_changeMaster
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANGE, 0)
}

func (s *ChangeMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *ChangeMasterContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *ChangeMasterContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ChangeMasterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ChangeMasterContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (s *ChangeMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitChangeMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ChangeMaster() (localctx IChangeMasterContext) {
	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MariaDBParserRULE_changeMaster)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4517)
		p.Match(MariaDBParserCHANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4518)
		p.Match(MariaDBParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4519)
		p.Match(MariaDBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4520)
		p.MasterOption()
	}
	p.SetState(4525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(4521)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4522)
			p.MasterOption()
		}

		p.SetState(4527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFOR {
		{
			p.SetState(4528)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeReplicationFilterContext is an interface to support dynamic dispatch.
type IChangeReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	AllReplicationFilter() []IReplicationFilterContext
	ReplicationFilter(i int) IReplicationFilterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangeReplicationFilterContext differentiates from other interfaces.
	IsChangeReplicationFilterContext()
}

type ChangeReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationFilterContext() *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_changeReplicationFilter
	return p
}

func InitEmptyChangeReplicationFilterContext(p *ChangeReplicationFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_changeReplicationFilter
}

func (*ChangeReplicationFilterContext) IsChangeReplicationFilterContext() {}

func NewChangeReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_changeReplicationFilter

	return p
}

func (s *ChangeReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationFilterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANGE, 0)
}

func (s *ChangeReplicationFilterContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION, 0)
}

func (s *ChangeReplicationFilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILTER, 0)
}

func (s *ChangeReplicationFilterContext) AllReplicationFilter() []IReplicationFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			len++
		}
	}

	tst := make([]IReplicationFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationFilterContext); ok {
			tst[i] = t.(IReplicationFilterContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationFilterContext) ReplicationFilter(i int) IReplicationFilterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationFilterContext)
}

func (s *ChangeReplicationFilterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ChangeReplicationFilterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ChangeReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeReplicationFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitChangeReplicationFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ChangeReplicationFilter() (localctx IChangeReplicationFilterContext) {
	localctx = NewChangeReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MariaDBParserRULE_changeReplicationFilter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4531)
		p.Match(MariaDBParserCHANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4532)
		p.Match(MariaDBParserREPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4533)
		p.Match(MariaDBParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4534)
		p.ReplicationFilter()
	}
	p.SetState(4539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(4535)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4536)
			p.ReplicationFilter()
		}

		p.SetState(4541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPurgeBinaryLogsContext is an interface to support dynamic dispatch.
type IPurgeBinaryLogsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPurgeFormat returns the purgeFormat token.
	GetPurgeFormat() antlr.Token

	// GetFileName returns the fileName token.
	GetFileName() antlr.Token

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token

	// SetPurgeFormat sets the purgeFormat token.
	SetPurgeFormat(antlr.Token)

	// SetFileName sets the fileName token.
	SetFileName(antlr.Token)

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token)

	// Getter signatures
	PURGE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsPurgeBinaryLogsContext differentiates from other interfaces.
	IsPurgeBinaryLogsContext()
}

type PurgeBinaryLogsContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	purgeFormat antlr.Token
	fileName    antlr.Token
	timeValue   antlr.Token
}

func NewEmptyPurgeBinaryLogsContext() *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_purgeBinaryLogs
	return p
}

func InitEmptyPurgeBinaryLogsContext(p *PurgeBinaryLogsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_purgeBinaryLogs
}

func (*PurgeBinaryLogsContext) IsPurgeBinaryLogsContext() {}

func NewPurgeBinaryLogsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_purgeBinaryLogs

	return p
}

func (s *PurgeBinaryLogsContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeBinaryLogsContext) GetPurgeFormat() antlr.Token { return s.purgeFormat }

func (s *PurgeBinaryLogsContext) GetFileName() antlr.Token { return s.fileName }

func (s *PurgeBinaryLogsContext) GetTimeValue() antlr.Token { return s.timeValue }

func (s *PurgeBinaryLogsContext) SetPurgeFormat(v antlr.Token) { s.purgeFormat = v }

func (s *PurgeBinaryLogsContext) SetFileName(v antlr.Token) { s.fileName = v }

func (s *PurgeBinaryLogsContext) SetTimeValue(v antlr.Token) { s.timeValue = v }

func (s *PurgeBinaryLogsContext) PURGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPURGE, 0)
}

func (s *PurgeBinaryLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGS, 0)
}

func (s *PurgeBinaryLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *PurgeBinaryLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *PurgeBinaryLogsContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *PurgeBinaryLogsContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEFORE, 0)
}

func (s *PurgeBinaryLogsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PurgeBinaryLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeBinaryLogsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeBinaryLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPurgeBinaryLogs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PurgeBinaryLogs() (localctx IPurgeBinaryLogsContext) {
	localctx = NewPurgeBinaryLogsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MariaDBParserRULE_purgeBinaryLogs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4542)
		p.Match(MariaDBParserPURGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4543)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PurgeBinaryLogsContext).purgeFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserBINARY || _la == MariaDBParserMASTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PurgeBinaryLogsContext).purgeFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4544)
		p.Match(MariaDBParserLOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserTO:
		{
			p.SetState(4545)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4546)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).fileName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBEFORE:
		{
			p.SetState(4547)
			p.Match(MariaDBParserBEFORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4548)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).timeValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetMasterContext is an interface to support dynamic dispatch.
type IResetMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	MASTER() antlr.TerminalNode

	// IsResetMasterContext differentiates from other interfaces.
	IsResetMasterContext()
}

type ResetMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetMasterContext() *ResetMasterContext {
	var p = new(ResetMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetMaster
	return p
}

func InitEmptyResetMasterContext(p *ResetMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetMaster
}

func (*ResetMasterContext) IsResetMasterContext() {}

func NewResetMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetMasterContext {
	var p = new(ResetMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_resetMaster

	return p
}

func (s *ResetMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetMasterContext) RESET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESET, 0)
}

func (s *ResetMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *ResetMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterResetMaster(s)
	}
}

func (s *ResetMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitResetMaster(s)
	}
}

func (s *ResetMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitResetMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ResetMaster() (localctx IResetMasterContext) {
	localctx = NewResetMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MariaDBParserRULE_resetMaster)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4551)
		p.Match(MariaDBParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4552)
		p.Match(MariaDBParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetSlaveContext is an interface to support dynamic dispatch.
type IResetSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsResetSlaveContext differentiates from other interfaces.
	IsResetSlaveContext()
}

type ResetSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetSlaveContext() *ResetSlaveContext {
	var p = new(ResetSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetSlave
	return p
}

func InitEmptyResetSlaveContext(p *ResetSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetSlave
}

func (*ResetSlaveContext) IsResetSlaveContext() {}

func NewResetSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetSlaveContext {
	var p = new(ResetSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_resetSlave

	return p
}

func (s *ResetSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetSlaveContext) RESET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESET, 0)
}

func (s *ResetSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *ResetSlaveContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *ResetSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ResetSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterResetSlave(s)
	}
}

func (s *ResetSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitResetSlave(s)
	}
}

func (s *ResetSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitResetSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ResetSlave() (localctx IResetSlaveContext) {
	localctx = NewResetSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MariaDBParserRULE_resetSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4554)
		p.Match(MariaDBParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4555)
		p.Match(MariaDBParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserALL {
		{
			p.SetState(4556)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFOR {
		{
			p.SetState(4559)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartSlaveContext is an interface to support dynamic dispatch.
type IStartSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	UNTIL() antlr.TerminalNode
	UntilOption() IUntilOptionContext
	AllConnectionOption() []IConnectionOptionContext
	ConnectionOption(i int) IConnectionOptionContext
	ChannelOption() IChannelOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartSlaveContext differentiates from other interfaces.
	IsStartSlaveContext()
}

type StartSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartSlaveContext() *StartSlaveContext {
	var p = new(StartSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startSlave
	return p
}

func InitEmptyStartSlaveContext(p *StartSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startSlave
}

func (*StartSlaveContext) IsStartSlaveContext() {}

func NewStartSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartSlaveContext {
	var p = new(StartSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_startSlave

	return p
}

func (s *StartSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StartSlaveContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *StartSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *StartSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StartSlaveContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNTIL, 0)
}

func (s *StartSlaveContext) UntilOption() IUntilOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilOptionContext)
}

func (s *StartSlaveContext) AllConnectionOption() []IConnectionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			len++
		}
	}

	tst := make([]IConnectionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConnectionOptionContext); ok {
			tst[i] = t.(IConnectionOptionContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ConnectionOption(i int) IConnectionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectionOptionContext)
}

func (s *StartSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *StartSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *StartSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *StartSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStartSlave(s)
	}
}

func (s *StartSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStartSlave(s)
	}
}

func (s *StartSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStartSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StartSlave() (localctx IStartSlaveContext) {
	localctx = NewStartSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MariaDBParserRULE_startSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4562)
		p.Match(MariaDBParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4563)
		p.Match(MariaDBParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIO_THREAD || _la == MariaDBParserSQL_THREAD {
		{
			p.SetState(4564)
			p.ThreadType()
		}
		p.SetState(4569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4565)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4566)
				p.ThreadType()
			}

			p.SetState(4571)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserUNTIL {
		{
			p.SetState(4574)
			p.Match(MariaDBParserUNTIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4575)
			p.UntilOption()
		}

	}
	p.SetState(4581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserDEFAULT_AUTH || _la == MariaDBParserPASSWORD || _la == MariaDBParserPLUGIN_DIR || _la == MariaDBParserUSER {
		{
			p.SetState(4578)
			p.ConnectionOption()
		}

		p.SetState(4583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFOR {
		{
			p.SetState(4584)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopSlaveContext is an interface to support dynamic dispatch.
type IStopSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStopSlaveContext differentiates from other interfaces.
	IsStopSlaveContext()
}

type StopSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopSlaveContext() *StopSlaveContext {
	var p = new(StopSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stopSlave
	return p
}

func InitEmptyStopSlaveContext(p *StopSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stopSlave
}

func (*StopSlaveContext) IsStopSlaveContext() {}

func NewStopSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopSlaveContext {
	var p = new(StopSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_stopSlave

	return p
}

func (s *StopSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StopSlaveContext) STOP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTOP, 0)
}

func (s *StopSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *StopSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StopSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StopSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *StopSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *StopSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStopSlave(s)
	}
}

func (s *StopSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStopSlave(s)
	}
}

func (s *StopSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStopSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StopSlave() (localctx IStopSlaveContext) {
	localctx = NewStopSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MariaDBParserRULE_stopSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4587)
		p.Match(MariaDBParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4588)
		p.Match(MariaDBParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIO_THREAD || _la == MariaDBParserSQL_THREAD {
		{
			p.SetState(4589)
			p.ThreadType()
		}
		p.SetState(4594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4590)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4591)
				p.ThreadType()
			}

			p.SetState(4596)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartGroupReplicationContext is an interface to support dynamic dispatch.
type IStartGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStartGroupReplicationContext differentiates from other interfaces.
	IsStartGroupReplicationContext()
}

type StartGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartGroupReplicationContext() *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startGroupReplication
	return p
}

func InitEmptyStartGroupReplicationContext(p *StartGroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_startGroupReplication
}

func (*StartGroupReplicationContext) IsStartGroupReplicationContext() {}

func NewStartGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_startGroupReplication

	return p
}

func (s *StartGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StartGroupReplicationContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *StartGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_REPLICATION, 0)
}

func (s *StartGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStartGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StartGroupReplication() (localctx IStartGroupReplicationContext) {
	localctx = NewStartGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MariaDBParserRULE_startGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4599)
		p.Match(MariaDBParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4600)
		p.Match(MariaDBParserGROUP_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopGroupReplicationContext is an interface to support dynamic dispatch.
type IStopGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStopGroupReplicationContext differentiates from other interfaces.
	IsStopGroupReplicationContext()
}

type StopGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopGroupReplicationContext() *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stopGroupReplication
	return p
}

func InitEmptyStopGroupReplicationContext(p *StopGroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stopGroupReplication
}

func (*StopGroupReplicationContext) IsStopGroupReplicationContext() {}

func NewStopGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_stopGroupReplication

	return p
}

func (s *StopGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StopGroupReplicationContext) STOP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTOP, 0)
}

func (s *StopGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_REPLICATION, 0)
}

func (s *StopGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStopGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StopGroupReplication() (localctx IStopGroupReplicationContext) {
	localctx = NewStopGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MariaDBParserRULE_stopGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4602)
		p.Match(MariaDBParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4603)
		p.Match(MariaDBParserGROUP_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_masterOption
	return p
}

func InitEmptyMasterOptionContext(p *MasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_masterOption
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) CopyAll(ctx *MasterOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MasterStringOptionContext struct {
	MasterOptionContext
}

func NewMasterStringOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterStringOptionContext {
	var p = new(MasterStringOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterStringOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterStringOptionContext) StringMasterOption() IStringMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringMasterOptionContext)
}

func (s *MasterStringOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *MasterStringOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *MasterStringOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterStringOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterRealOptionContext struct {
	MasterOptionContext
}

func NewMasterRealOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterRealOptionContext {
	var p = new(MasterRealOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterRealOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterRealOptionContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *MasterRealOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *MasterRealOptionContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAL_LITERAL, 0)
}

func (s *MasterRealOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterRealOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterBoolOptionContext struct {
	MasterOptionContext
	boolVal antlr.Token
}

func NewMasterBoolOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterBoolOptionContext {
	var p = new(MasterBoolOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterBoolOptionContext) GetBoolVal() antlr.Token { return s.boolVal }

func (s *MasterBoolOptionContext) SetBoolVal(v antlr.Token) { s.boolVal = v }

func (s *MasterBoolOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterBoolOptionContext) BoolMasterOption() IBoolMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolMasterOptionContext)
}

func (s *MasterBoolOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *MasterBoolOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterBoolOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterUidListOptionContext struct {
	MasterOptionContext
}

func NewMasterUidListOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterUidListOptionContext {
	var p = new(MasterUidListOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterUidListOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterUidListOptionContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE_SERVER_IDS, 0)
}

func (s *MasterUidListOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *MasterUidListOptionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *MasterUidListOptionContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *MasterUidListOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *MasterUidListOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *MasterUidListOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterUidListOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterDecimalOptionContext struct {
	MasterOptionContext
}

func NewMasterDecimalOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterDecimalOptionContext {
	var p = new(MasterDecimalOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterDecimalOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterDecimalOptionContext) DecimalMasterOption() IDecimalMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalMasterOptionContext)
}

func (s *MasterDecimalOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *MasterDecimalOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterDecimalOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterDecimalOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) MasterOption() (localctx IMasterOptionContext) {
	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MariaDBParserRULE_masterOption)
	var _la int

	p.SetState(4634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserMASTER_BIND, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserRELAY_LOG_FILE:
		localctx = NewMasterStringOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4605)
			p.StringMasterOption()
		}
		{
			p.SetState(4606)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4607)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserRELAY_LOG_POS:
		localctx = NewMasterDecimalOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4609)
			p.DecimalMasterOption()
		}
		{
			p.SetState(4610)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4611)
			p.DecimalLiteral()
		}

	case MariaDBParserMASTER_SSL_VERIFY_SERVER_CERT, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_SSL:
		localctx = NewMasterBoolOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4613)
			p.BoolMasterOption()
		}
		{
			p.SetState(4614)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4615)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MasterBoolOptionContext).boolVal = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserZERO_DECIMAL || _la == MariaDBParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MasterBoolOptionContext).boolVal = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserMASTER_HEARTBEAT_PERIOD:
		localctx = NewMasterRealOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4617)
			p.Match(MariaDBParserMASTER_HEARTBEAT_PERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4618)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4619)
			p.Match(MariaDBParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserIGNORE_SERVER_IDS:
		localctx = NewMasterUidListOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4620)
			p.Match(MariaDBParserIGNORE_SERVER_IDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4621)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4622)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
			{
				p.SetState(4623)
				p.Uid()
			}
			p.SetState(4628)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(4624)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4625)
					p.Uid()
				}

				p.SetState(4630)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4633)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringMasterOptionContext is an interface to support dynamic dispatch.
type IStringMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_BIND() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode

	// IsStringMasterOptionContext differentiates from other interfaces.
	IsStringMasterOptionContext()
}

type StringMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringMasterOptionContext() *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stringMasterOption
	return p
}

func InitEmptyStringMasterOptionContext(p *StringMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stringMasterOption
}

func (*StringMasterOptionContext) IsStringMasterOptionContext() {}

func NewStringMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_stringMasterOption

	return p
}

func (s *StringMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringMasterOptionContext) MASTER_BIND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_BIND, 0)
}

func (s *StringMasterOptionContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_HOST, 0)
}

func (s *StringMasterOptionContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_USER, 0)
}

func (s *StringMasterOptionContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_PASSWORD, 0)
}

func (s *StringMasterOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CA, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CAPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CERT, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CRL, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CRLPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_KEY, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CIPHER, 0)
}

func (s *StringMasterOptionContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_TLS_VERSION, 0)
}

func (s *StringMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStringMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StringMasterOption() (localctx IStringMasterOptionContext) {
	localctx = NewStringMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MariaDBParserRULE_stringMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4636)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserMASTER_BIND || ((int64((_la-483)) & ^0x3f) == 0 && ((int64(1)<<(_la-483))&65419) != 0) || _la == MariaDBParserRELAY_LOG_FILE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalMasterOptionContext is an interface to support dynamic dispatch.
type IDecimalMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_PORT() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode

	// IsDecimalMasterOptionContext differentiates from other interfaces.
	IsDecimalMasterOptionContext()
}

type DecimalMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalMasterOptionContext() *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_decimalMasterOption
	return p
}

func InitEmptyDecimalMasterOptionContext(p *DecimalMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_decimalMasterOption
}

func (*DecimalMasterOptionContext) IsDecimalMasterOptionContext() {}

func NewDecimalMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_decimalMasterOption

	return p
}

func (s *DecimalMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalMasterOptionContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_PORT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_CONNECT_RETRY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_RETRY_COUNT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_DELAY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDecimalMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DecimalMasterOption() (localctx IDecimalMasterOptionContext) {
	localctx = NewDecimalMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MariaDBParserRULE_decimalMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-480)) & ^0x3f) == 0 && ((int64(1)<<(_la-480))&419) != 0) || _la == MariaDBParserRELAY_LOG_POS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolMasterOptionContext is an interface to support dynamic dispatch.
type IBoolMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode

	// IsBoolMasterOptionContext differentiates from other interfaces.
	IsBoolMasterOptionContext()
}

type BoolMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolMasterOptionContext() *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_boolMasterOption
	return p
}

func InitEmptyBoolMasterOptionContext(p *BoolMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_boolMasterOption
}

func (*BoolMasterOptionContext) IsBoolMasterOptionContext() {}

func NewBoolMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_boolMasterOption

	return p
}

func (s *BoolMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolMasterOptionContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_AUTO_POSITION, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_VERIFY_SERVER_CERT, 0)
}

func (s *BoolMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBoolMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BoolMasterOption() (localctx IBoolMasterOptionContext) {
	localctx = NewBoolMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MariaDBParserRULE_boolMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4640)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserMASTER_SSL_VERIFY_SERVER_CERT || _la == MariaDBParserMASTER_AUTO_POSITION || _la == MariaDBParserMASTER_SSL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelOptionContext is an interface to support dynamic dispatch.
type IChannelOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsChannelOptionContext differentiates from other interfaces.
	IsChannelOptionContext()
}

type ChannelOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelOptionContext() *ChannelOptionContext {
	var p = new(ChannelOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_channelOption
	return p
}

func InitEmptyChannelOptionContext(p *ChannelOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_channelOption
}

func (*ChannelOptionContext) IsChannelOptionContext() {}

func NewChannelOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelOptionContext {
	var p = new(ChannelOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_channelOption

	return p
}

func (s *ChannelOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ChannelOptionContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANNEL, 0)
}

func (s *ChannelOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ChannelOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterChannelOption(s)
	}
}

func (s *ChannelOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitChannelOption(s)
	}
}

func (s *ChannelOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitChannelOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ChannelOption() (localctx IChannelOptionContext) {
	localctx = NewChannelOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MariaDBParserRULE_channelOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4642)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4643)
		p.Match(MariaDBParserCHANNEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4644)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationFilterContext is an interface to support dynamic dispatch.
type IReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReplicationFilterContext differentiates from other interfaces.
	IsReplicationFilterContext()
}

type ReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationFilterContext() *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replicationFilter
	return p
}

func InitEmptyReplicationFilterContext(p *ReplicationFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_replicationFilter
}

func (*ReplicationFilterContext) IsReplicationFilterContext() {}

func NewReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_replicationFilter

	return p
}

func (s *ReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationFilterContext) CopyAll(ctx *ReplicationFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WildIgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildIgnoreTableReplicationContext {
	var p = new(WildIgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildIgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildIgnoreTableReplicationContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *WildIgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *WildIgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildIgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWildIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoTableReplicationContext {
	var p = new(DoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoTableReplicationContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_DO_TABLE, 0)
}

func (s *DoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *DoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *DoTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *DoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type IgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreTableReplicationContext {
	var p = new(IgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreTableReplicationContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *IgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *IgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type RewriteDbReplicationContext struct {
	ReplicationFilterContext
}

func NewRewriteDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RewriteDbReplicationContext {
	var p = new(RewriteDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *RewriteDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteDbReplicationContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_REWRITE_DB, 0)
}

func (s *RewriteDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *RewriteDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllTablePair() []ITablePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePairContext); ok {
			len++
		}
	}

	tst := make([]ITablePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePairContext); ok {
			tst[i] = t.(ITablePairContext)
			i++
		}
	}

	return tst
}

func (s *RewriteDbReplicationContext) TablePair(i int) ITablePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePairContext)
}

func (s *RewriteDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RewriteDbReplicationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RewriteDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRewriteDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoDbReplicationContext struct {
	ReplicationFilterContext
}

func NewDoDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoDbReplicationContext {
	var p = new(DoDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoDbReplicationContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_DO_DB, 0)
}

func (s *DoDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *DoDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *DoDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DoDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *DoDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDoDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type IgnoreDbReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreDbReplicationContext {
	var p = new(IgnoreDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreDbReplicationContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_IGNORE_DB, 0)
}

func (s *IgnoreDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IgnoreDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIgnoreDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type WildDoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildDoTableReplicationContext {
	var p = new(WildDoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildDoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildDoTableReplicationContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *WildDoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *WildDoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildDoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWildDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReplicationFilter() (localctx IReplicationFilterContext) {
	localctx = NewReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MariaDBParserRULE_replicationFilter)
	var _la int

	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserREPLICATE_DO_DB:
		localctx = NewDoDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4646)
			p.Match(MariaDBParserREPLICATE_DO_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4647)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4648)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4649)
			p.UidList()
		}
		{
			p.SetState(4650)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_IGNORE_DB:
		localctx = NewIgnoreDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4652)
			p.Match(MariaDBParserREPLICATE_IGNORE_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4653)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4654)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4655)
			p.UidList()
		}
		{
			p.SetState(4656)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_DO_TABLE:
		localctx = NewDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4658)
			p.Match(MariaDBParserREPLICATE_DO_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4659)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4661)
			p.Tables()
		}
		{
			p.SetState(4662)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_IGNORE_TABLE:
		localctx = NewIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4664)
			p.Match(MariaDBParserREPLICATE_IGNORE_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4665)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4666)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4667)
			p.Tables()
		}
		{
			p.SetState(4668)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_WILD_DO_TABLE:
		localctx = NewWildDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4670)
			p.Match(MariaDBParserREPLICATE_WILD_DO_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4672)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4673)
			p.SimpleStrings()
		}
		{
			p.SetState(4674)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_WILD_IGNORE_TABLE:
		localctx = NewWildIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4676)
			p.Match(MariaDBParserREPLICATE_WILD_IGNORE_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4677)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4678)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4679)
			p.SimpleStrings()
		}
		{
			p.SetState(4680)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLICATE_REWRITE_DB:
		localctx = NewRewriteDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4682)
			p.Match(MariaDBParserREPLICATE_REWRITE_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4683)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4684)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4685)
			p.TablePair()
		}
		p.SetState(4690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4686)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4687)
				p.TablePair()
			}

			p.SetState(4692)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4693)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePairContext is an interface to support dynamic dispatch.
type ITablePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirstTable returns the firstTable rule contexts.
	GetFirstTable() ITableNameContext

	// GetSecondTable returns the secondTable rule contexts.
	GetSecondTable() ITableNameContext

	// SetFirstTable sets the firstTable rule contexts.
	SetFirstTable(ITableNameContext)

	// SetSecondTable sets the secondTable rule contexts.
	SetSecondTable(ITableNameContext)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext

	// IsTablePairContext differentiates from other interfaces.
	IsTablePairContext()
}

type TablePairContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	firstTable  ITableNameContext
	secondTable ITableNameContext
}

func NewEmptyTablePairContext() *TablePairContext {
	var p = new(TablePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tablePair
	return p
}

func InitEmptyTablePairContext(p *TablePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tablePair
}

func (*TablePairContext) IsTablePairContext() {}

func NewTablePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePairContext {
	var p = new(TablePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tablePair

	return p
}

func (s *TablePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePairContext) GetFirstTable() ITableNameContext { return s.firstTable }

func (s *TablePairContext) GetSecondTable() ITableNameContext { return s.secondTable }

func (s *TablePairContext) SetFirstTable(v ITableNameContext) { s.firstTable = v }

func (s *TablePairContext) SetSecondTable(v ITableNameContext) { s.secondTable = v }

func (s *TablePairContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TablePairContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *TablePairContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TablePairContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablePairContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTablePair(s)
	}
}

func (s *TablePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTablePair(s)
	}
}

func (s *TablePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTablePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TablePair() (localctx ITablePairContext) {
	localctx = NewTablePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MariaDBParserRULE_tablePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4697)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4698)

		var _x = p.TableName()

		localctx.(*TablePairContext).firstTable = _x
	}
	{
		p.SetState(4699)
		p.Match(MariaDBParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4700)

		var _x = p.TableName()

		localctx.(*TablePairContext).secondTable = _x
	}
	{
		p.SetState(4701)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThreadTypeContext is an interface to support dynamic dispatch.
type IThreadTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IO_THREAD() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode

	// IsThreadTypeContext differentiates from other interfaces.
	IsThreadTypeContext()
}

type ThreadTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadTypeContext() *ThreadTypeContext {
	var p = new(ThreadTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_threadType
	return p
}

func InitEmptyThreadTypeContext(p *ThreadTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_threadType
}

func (*ThreadTypeContext) IsThreadTypeContext() {}

func NewThreadTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadTypeContext {
	var p = new(ThreadTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_threadType

	return p
}

func (s *ThreadTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadTypeContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIO_THREAD, 0)
}

func (s *ThreadTypeContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_THREAD, 0)
}

func (s *ThreadTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThreadTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterThreadType(s)
	}
}

func (s *ThreadTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitThreadType(s)
	}
}

func (s *ThreadTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitThreadType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ThreadType() (localctx IThreadTypeContext) {
	localctx = NewThreadTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MariaDBParserRULE_threadType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4703)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserIO_THREAD || _la == MariaDBParserSQL_THREAD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUntilOptionContext is an interface to support dynamic dispatch.
type IUntilOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUntilOptionContext differentiates from other interfaces.
	IsUntilOptionContext()
}

type UntilOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilOptionContext() *UntilOptionContext {
	var p = new(UntilOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_untilOption
	return p
}

func InitEmptyUntilOptionContext(p *UntilOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_untilOption
}

func (*UntilOptionContext) IsUntilOptionContext() {}

func NewUntilOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilOptionContext {
	var p = new(UntilOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_untilOption

	return p
}

func (s *UntilOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilOptionContext) CopyAll(ctx *UntilOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GtidsUntilOptionContext struct {
	UntilOptionContext
	gtids antlr.Token
}

func NewGtidsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GtidsUntilOptionContext {
	var p = new(GtidsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *GtidsUntilOptionContext) GetGtids() antlr.Token { return s.gtids }

func (s *GtidsUntilOptionContext) SetGtids(v antlr.Token) { s.gtids = v }

func (s *GtidsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtidsUntilOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *GtidsUntilOptionContext) GtuidSet() IGtuidSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGtuidSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGtuidSetContext)
}

func (s *GtidsUntilOptionContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_BEFORE_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_AFTER_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGtidsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type SqlGapsUntilOptionContext struct {
	UntilOptionContext
}

func NewSqlGapsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SqlGapsUntilOptionContext {
	var p = new(SqlGapsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *SqlGapsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlGapsUntilOptionContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *SqlGapsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSqlGapsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterLogUntilOptionContext struct {
	UntilOptionContext
}

func NewMasterLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterLogUntilOptionContext {
	var p = new(MasterLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *MasterLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_FILE, 0)
}

func (s *MasterLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *MasterLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *MasterLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *MasterLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_POS, 0)
}

func (s *MasterLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMasterLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelayLogUntilOptionContext struct {
	UntilOptionContext
}

func NewRelayLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelayLogUntilOptionContext {
	var p = new(RelayLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *RelayLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_FILE, 0)
}

func (s *RelayLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *RelayLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *RelayLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *RelayLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_POS, 0)
}

func (s *RelayLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *RelayLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRelayLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UntilOption() (localctx IUntilOptionContext) {
	localctx = NewUntilOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MariaDBParserRULE_untilOption)
	var _la int

	p.SetState(4723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_BEFORE_GTIDS:
		localctx = NewGtidsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4705)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GtidsUntilOptionContext).gtids = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSQL_AFTER_GTIDS || _la == MariaDBParserSQL_BEFORE_GTIDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GtidsUntilOptionContext).gtids = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4706)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4707)
			p.GtuidSet()
		}

	case MariaDBParserMASTER_LOG_FILE:
		localctx = NewMasterLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4708)
			p.Match(MariaDBParserMASTER_LOG_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4709)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4710)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4711)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4712)
			p.Match(MariaDBParserMASTER_LOG_POS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4713)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4714)
			p.DecimalLiteral()
		}

	case MariaDBParserRELAY_LOG_FILE:
		localctx = NewRelayLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4715)
			p.Match(MariaDBParserRELAY_LOG_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4716)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4717)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4718)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4719)
			p.Match(MariaDBParserRELAY_LOG_POS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4720)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4721)
			p.DecimalLiteral()
		}

	case MariaDBParserSQL_AFTER_MTS_GAPS:
		localctx = NewSqlGapsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4722)
			p.Match(MariaDBParserSQL_AFTER_MTS_GAPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectionOptionContext is an interface to support dynamic dispatch.
type IConnectionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConnectionOptionContext differentiates from other interfaces.
	IsConnectionOptionContext()
}

type ConnectionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectionOptionContext() *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_connectionOption
	return p
}

func InitEmptyConnectionOptionContext(p *ConnectionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_connectionOption
}

func (*ConnectionOptionContext) IsConnectionOptionContext() {}

func NewConnectionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_connectionOption

	return p
}

func (s *ConnectionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectionOptionContext) CopyAll(ctx *ConnectionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PluginDirConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPluginDir antlr.Token
}

func NewPluginDirConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PluginDirConnectionOptionContext {
	var p = new(PluginDirConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PluginDirConnectionOptionContext) GetConOptPluginDir() antlr.Token { return s.conOptPluginDir }

func (s *PluginDirConnectionOptionContext) SetConOptPluginDir(v antlr.Token) { s.conOptPluginDir = v }

func (s *PluginDirConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginDirConnectionOptionContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGIN_DIR, 0)
}

func (s *PluginDirConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PluginDirConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PluginDirConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPluginDirConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserConnectionOptionContext struct {
	ConnectionOptionContext
	conOptUser antlr.Token
}

func NewUserConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserConnectionOptionContext {
	var p = new(UserConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *UserConnectionOptionContext) GetConOptUser() antlr.Token { return s.conOptUser }

func (s *UserConnectionOptionContext) SetConOptUser(v antlr.Token) { s.conOptUser = v }

func (s *UserConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserConnectionOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *UserConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *UserConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *UserConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefaultAuthConnectionOptionContext struct {
	ConnectionOptionContext
	conOptDefAuth antlr.Token
}

func NewDefaultAuthConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultAuthConnectionOptionContext {
	var p = new(DefaultAuthConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *DefaultAuthConnectionOptionContext) GetConOptDefAuth() antlr.Token { return s.conOptDefAuth }

func (s *DefaultAuthConnectionOptionContext) SetConOptDefAuth(v antlr.Token) { s.conOptDefAuth = v }

func (s *DefaultAuthConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultAuthConnectionOptionContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT_AUTH, 0)
}

func (s *DefaultAuthConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *DefaultAuthConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *DefaultAuthConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefaultAuthConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type PasswordConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPassword antlr.Token
}

func NewPasswordConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordConnectionOptionContext {
	var p = new(PasswordConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PasswordConnectionOptionContext) GetConOptPassword() antlr.Token { return s.conOptPassword }

func (s *PasswordConnectionOptionContext) SetConOptPassword(v antlr.Token) { s.conOptPassword = v }

func (s *PasswordConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordConnectionOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *PasswordConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *PasswordConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PasswordConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPasswordConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ConnectionOption() (localctx IConnectionOptionContext) {
	localctx = NewConnectionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MariaDBParserRULE_connectionOption)
	p.SetState(4737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserUSER:
		localctx = NewUserConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4725)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4726)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4727)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*UserConnectionOptionContext).conOptUser = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPASSWORD:
		localctx = NewPasswordConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4728)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4729)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4730)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PasswordConnectionOptionContext).conOptPassword = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDEFAULT_AUTH:
		localctx = NewDefaultAuthConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4731)
			p.Match(MariaDBParserDEFAULT_AUTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4732)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4733)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*DefaultAuthConnectionOptionContext).conOptDefAuth = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPLUGIN_DIR:
		localctx = NewPluginDirConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4734)
			p.Match(MariaDBParserPLUGIN_DIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4735)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4736)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PluginDirConnectionOptionContext).conOptPluginDir = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGtuidSetContext is an interface to support dynamic dispatch.
type IGtuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUuidSet() []IUuidSetContext
	UuidSet(i int) IUuidSetContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsGtuidSetContext differentiates from other interfaces.
	IsGtuidSetContext()
}

type GtuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGtuidSetContext() *GtuidSetContext {
	var p = new(GtuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_gtuidSet
	return p
}

func InitEmptyGtuidSetContext(p *GtuidSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_gtuidSet
}

func (*GtuidSetContext) IsGtuidSetContext() {}

func NewGtuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GtuidSetContext {
	var p = new(GtuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_gtuidSet

	return p
}

func (s *GtuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GtuidSetContext) AllUuidSet() []IUuidSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUuidSetContext); ok {
			len++
		}
	}

	tst := make([]IUuidSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUuidSetContext); ok {
			tst[i] = t.(IUuidSetContext)
			i++
		}
	}

	return tst
}

func (s *GtuidSetContext) UuidSet(i int) IUuidSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidSetContext)
}

func (s *GtuidSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *GtuidSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *GtuidSetContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *GtuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GtuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGtuidSet(s)
	}
}

func (s *GtuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGtuidSet(s)
	}
}

func (s *GtuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGtuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) GtuidSet() (localctx IGtuidSetContext) {
	localctx = NewGtuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MariaDBParserRULE_gtuidSet)
	var _la int

	p.SetState(4748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4739)
			p.UuidSet()
		}
		p.SetState(4744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(4740)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4741)
				p.UuidSet()
			}

			p.SetState(4746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MariaDBParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4747)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaStartTransactionContext is an interface to support dynamic dispatch.
type IXaStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetXaStart returns the xaStart token.
	GetXaStart() antlr.Token

	// GetXaAction returns the xaAction token.
	GetXaAction() antlr.Token

	// SetXaStart sets the xaStart token.
	SetXaStart(antlr.Token)

	// SetXaAction sets the xaAction token.
	SetXaAction(antlr.Token)

	// Getter signatures
	XA() antlr.TerminalNode
	Xid() IXidContext
	START() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RESUME() antlr.TerminalNode

	// IsXaStartTransactionContext differentiates from other interfaces.
	IsXaStartTransactionContext()
}

type XaStartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	xaStart  antlr.Token
	xaAction antlr.Token
}

func NewEmptyXaStartTransactionContext() *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaStartTransaction
	return p
}

func InitEmptyXaStartTransactionContext(p *XaStartTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaStartTransaction
}

func (*XaStartTransactionContext) IsXaStartTransactionContext() {}

func NewXaStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaStartTransaction

	return p
}

func (s *XaStartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStartTransactionContext) GetXaStart() antlr.Token { return s.xaStart }

func (s *XaStartTransactionContext) GetXaAction() antlr.Token { return s.xaAction }

func (s *XaStartTransactionContext) SetXaStart(v antlr.Token) { s.xaStart = v }

func (s *XaStartTransactionContext) SetXaAction(v antlr.Token) { s.xaAction = v }

func (s *XaStartTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaStartTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *XaStartTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEGIN, 0)
}

func (s *XaStartTransactionContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJOIN, 0)
}

func (s *XaStartTransactionContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESUME, 0)
}

func (s *XaStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaStartTransaction() (localctx IXaStartTransactionContext) {
	localctx = NewXaStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MariaDBParserRULE_xaStartTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4750)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4751)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*XaStartTransactionContext).xaStart = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserBEGIN || _la == MariaDBParserSTART) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*XaStartTransactionContext).xaStart = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4752)
		p.Xid()
	}
	p.SetState(4754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserJOIN || _la == MariaDBParserRESUME {
		{
			p.SetState(4753)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*XaStartTransactionContext).xaAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserJOIN || _la == MariaDBParserRESUME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*XaStartTransactionContext).xaAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaEndTransactionContext is an interface to support dynamic dispatch.
type IXaEndTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	END() antlr.TerminalNode
	Xid() IXidContext
	SUSPEND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode

	// IsXaEndTransactionContext differentiates from other interfaces.
	IsXaEndTransactionContext()
}

type XaEndTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaEndTransactionContext() *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaEndTransaction
	return p
}

func InitEmptyXaEndTransactionContext(p *XaEndTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaEndTransaction
}

func (*XaEndTransactionContext) IsXaEndTransactionContext() {}

func NewXaEndTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaEndTransaction

	return p
}

func (s *XaEndTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaEndTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaEndTransactionContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *XaEndTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaEndTransactionContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUSPEND, 0)
}

func (s *XaEndTransactionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *XaEndTransactionContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIGRATE, 0)
}

func (s *XaEndTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaEndTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaEndTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaEndTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaEndTransaction() (localctx IXaEndTransactionContext) {
	localctx = NewXaEndTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MariaDBParserRULE_xaEndTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4756)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4757)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4758)
		p.Xid()
	}
	p.SetState(4764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserSUSPEND {
		{
			p.SetState(4759)
			p.Match(MariaDBParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(4760)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4761)
				p.Match(MariaDBParserMIGRATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaPrepareStatementContext is an interface to support dynamic dispatch.
type IXaPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	Xid() IXidContext

	// IsXaPrepareStatementContext differentiates from other interfaces.
	IsXaPrepareStatementContext()
}

type XaPrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaPrepareStatementContext() *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaPrepareStatement
	return p
}

func InitEmptyXaPrepareStatementContext(p *XaPrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaPrepareStatement
}

func (*XaPrepareStatementContext) IsXaPrepareStatementContext() {}

func NewXaPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaPrepareStatement

	return p
}

func (s *XaPrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaPrepareStatementContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaPrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREPARE, 0)
}

func (s *XaPrepareStatementContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaPrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaPrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaPrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaPrepareStatement() (localctx IXaPrepareStatementContext) {
	localctx = NewXaPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MariaDBParserRULE_xaPrepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4766)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4767)
		p.Match(MariaDBParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4768)
		p.Xid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaCommitWorkContext is an interface to support dynamic dispatch.
type IXaCommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	Xid() IXidContext
	ONE() antlr.TerminalNode
	PHASE() antlr.TerminalNode

	// IsXaCommitWorkContext differentiates from other interfaces.
	IsXaCommitWorkContext()
}

type XaCommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaCommitWorkContext() *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaCommitWork
	return p
}

func InitEmptyXaCommitWorkContext(p *XaCommitWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaCommitWork
}

func (*XaCommitWorkContext) IsXaCommitWorkContext() {}

func NewXaCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaCommitWork

	return p
}

func (s *XaCommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaCommitWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaCommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMIT, 0)
}

func (s *XaCommitWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaCommitWorkContext) ONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE, 0)
}

func (s *XaCommitWorkContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPHASE, 0)
}

func (s *XaCommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaCommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaCommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaCommitWork() (localctx IXaCommitWorkContext) {
	localctx = NewXaCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MariaDBParserRULE_xaCommitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4770)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4771)
		p.Match(MariaDBParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4772)
		p.Xid()
	}
	p.SetState(4775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserONE {
		{
			p.SetState(4773)
			p.Match(MariaDBParserONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4774)
			p.Match(MariaDBParserPHASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaRollbackWorkContext is an interface to support dynamic dispatch.
type IXaRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRollbackWorkContext differentiates from other interfaces.
	IsXaRollbackWorkContext()
}

type XaRollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRollbackWorkContext() *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaRollbackWork
	return p
}

func InitEmptyXaRollbackWorkContext(p *XaRollbackWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaRollbackWork
}

func (*XaRollbackWorkContext) IsXaRollbackWorkContext() {}

func NewXaRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaRollbackWork

	return p
}

func (s *XaRollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRollbackWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaRollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLBACK, 0)
}

func (s *XaRollbackWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaRollbackWork() (localctx IXaRollbackWorkContext) {
	localctx = NewXaRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MariaDBParserRULE_xaRollbackWork)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4777)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4778)
		p.Match(MariaDBParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4779)
		p.Xid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaRecoverWorkContext is an interface to support dynamic dispatch.
type IXaRecoverWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRecoverWorkContext differentiates from other interfaces.
	IsXaRecoverWorkContext()
}

type XaRecoverWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRecoverWorkContext() *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaRecoverWork
	return p
}

func InitEmptyXaRecoverWorkContext(p *XaRecoverWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xaRecoverWork
}

func (*XaRecoverWorkContext) IsXaRecoverWorkContext() {}

func NewXaRecoverWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xaRecoverWork

	return p
}

func (s *XaRecoverWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRecoverWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *XaRecoverWorkContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRECOVER, 0)
}

func (s *XaRecoverWorkContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONVERT, 0)
}

func (s *XaRecoverWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRecoverWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRecoverWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRecoverWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXaRecoverWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XaRecoverWork() (localctx IXaRecoverWorkContext) {
	localctx = NewXaRecoverWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MariaDBParserRULE_xaRecoverWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4781)
		p.Match(MariaDBParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4782)
		p.Match(MariaDBParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCONVERT {
		{
			p.SetState(4783)
			p.Match(MariaDBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4784)
			p.Xid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQuery returns the query token.
	GetQuery() antlr.Token

	// GetVariable returns the variable token.
	GetVariable() antlr.Token

	// SetQuery sets the query token.
	SetQuery(antlr.Token)

	// SetVariable sets the variable token.
	SetVariable(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	FROM() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	LOCAL_ID() antlr.TerminalNode

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	query    antlr.Token
	variable antlr.Token
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) GetQuery() antlr.Token { return s.query }

func (s *PrepareStatementContext) GetVariable() antlr.Token { return s.variable }

func (s *PrepareStatementContext) SetQuery(v antlr.Token) { s.query = v }

func (s *PrepareStatementContext) SetVariable(v antlr.Token) { s.variable = v }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREPARE, 0)
}

func (s *PrepareStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *PrepareStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *PrepareStatementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MariaDBParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4787)
		p.Match(MariaDBParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4788)
		p.Uid()
	}
	{
		p.SetState(4789)
		p.Match(MariaDBParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSTRING_LITERAL:
		{
			p.SetState(4790)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*PrepareStatementContext).query = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLOCAL_ID:
		{
			p.SetState(4791)

			var _m = p.Match(MariaDBParserLOCAL_ID)

			localctx.(*PrepareStatementContext).variable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Uid() IUidContext
	USING() antlr.TerminalNode
	UserVariables() IUserVariablesContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *ExecuteStatementContext) UserVariables() IUserVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariablesContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, MariaDBParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4794)
		p.Match(MariaDBParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4795)
		p.Uid()
	}
	p.SetState(4798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserUSING {
		{
			p.SetState(4796)
			p.Match(MariaDBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4797)
			p.UserVariables()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocatePrepareContext is an interface to support dynamic dispatch.
type IDeallocatePrepareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropFormat returns the dropFormat token.
	GetDropFormat() antlr.Token

	// SetDropFormat sets the dropFormat token.
	SetDropFormat(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocatePrepareContext differentiates from other interfaces.
	IsDeallocatePrepareContext()
}

type DeallocatePrepareContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	dropFormat antlr.Token
}

func NewEmptyDeallocatePrepareContext() *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_deallocatePrepare
	return p
}

func InitEmptyDeallocatePrepareContext(p *DeallocatePrepareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_deallocatePrepare
}

func (*DeallocatePrepareContext) IsDeallocatePrepareContext() {}

func NewDeallocatePrepareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_deallocatePrepare

	return p
}

func (s *DeallocatePrepareContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocatePrepareContext) GetDropFormat() antlr.Token { return s.dropFormat }

func (s *DeallocatePrepareContext) SetDropFormat(v antlr.Token) { s.dropFormat = v }

func (s *DeallocatePrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREPARE, 0)
}

func (s *DeallocatePrepareContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeallocatePrepareContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEALLOCATE, 0)
}

func (s *DeallocatePrepareContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DeallocatePrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocatePrepareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocatePrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeallocatePrepare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeallocatePrepare() (localctx IDeallocatePrepareContext) {
	localctx = NewDeallocatePrepareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, MariaDBParserRULE_deallocatePrepare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4800)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeallocatePrepareContext).dropFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDROP || _la == MariaDBParserDEALLOCATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeallocatePrepareContext).dropFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4801)
		p.Match(MariaDBParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4802)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	SqlStatement() ISqlStatementContext

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_routineBody
	return p
}

func InitEmptyRoutineBodyContext(p *RoutineBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_routineBody
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *RoutineBodyContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (s *RoutineBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoutineBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, MariaDBParserRULE_routineBody)
	p.SetState(4806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4804)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4805)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllDeclareVariable() []IDeclareVariableContext
	DeclareVariable(i int) IDeclareVariableContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllDeclareCondition() []IDeclareConditionContext
	DeclareCondition(i int) IDeclareConditionContext
	AllDeclareCursor() []IDeclareCursorContext
	DeclareCursor(i int) IDeclareCursorContext
	AllDeclareHandler() []IDeclareHandlerContext
	DeclareHandler(i int) IDeclareHandlerContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEGIN, 0)
}

func (s *BlockStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *BlockStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *BlockStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLON_SYMB, 0)
}

func (s *BlockStatementContext) AllDeclareVariable() []IDeclareVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			len++
		}
	}

	tst := make([]IDeclareVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareVariableContext); ok {
			tst[i] = t.(IDeclareVariableContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareVariable(i int) IDeclareVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareVariableContext)
}

func (s *BlockStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSEMI)
}

func (s *BlockStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEMI, i)
}

func (s *BlockStatementContext) AllDeclareCondition() []IDeclareConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			len++
		}
	}

	tst := make([]IDeclareConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareConditionContext); ok {
			tst[i] = t.(IDeclareConditionContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCondition(i int) IDeclareConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareConditionContext)
}

func (s *BlockStatementContext) AllDeclareCursor() []IDeclareCursorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			len++
		}
	}

	tst := make([]IDeclareCursorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareCursorContext); ok {
			tst[i] = t.(IDeclareCursorContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCursor(i int) IDeclareCursorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareCursorContext)
}

func (s *BlockStatementContext) AllDeclareHandler() []IDeclareHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			len++
		}
	}

	tst := make([]IDeclareHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareHandlerContext); ok {
			tst[i] = t.(IDeclareHandlerContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareHandler(i int) IDeclareHandlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareHandlerContext)
}

func (s *BlockStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, MariaDBParserRULE_blockStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4811)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4808)
			p.Uid()
		}
		{
			p.SetState(4809)
			p.Match(MariaDBParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4813)
		p.Match(MariaDBParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4852)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 714, p.GetParserRuleContext()) == 1 {
		p.SetState(4819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4814)
					p.DeclareVariable()
				}
				{
					p.SetState(4815)
					p.Match(MariaDBParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(4821)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(4827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4822)
					p.DeclareCondition()
				}
				{
					p.SetState(4823)
					p.Match(MariaDBParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(4829)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(4835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4830)
					p.DeclareCursor()
				}
				{
					p.SetState(4831)
					p.Match(MariaDBParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(4837)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(4843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserDECLARE {
			{
				p.SetState(4838)
				p.DeclareHandler()
			}
			{
				p.SetState(4839)
				p.Match(MariaDBParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(4845)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4846)
					p.ProcedureSqlStatement()
				}

			}
			p.SetState(4851)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4854)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4856)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4855)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCASE() []antlr.TerminalNode
	CASE(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	Uid() IUidContext
	Expression() IExpressionContext
	AllCaseAlternative() []ICaseAlternativeContext
	CaseAlternative(i int) ICaseAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCASE)
}

func (s *CaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASE, i)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *CaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) AllCaseAlternative() []ICaseAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseAlternativeContext); ok {
			tst[i] = t.(ICaseAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseAlternative(i int) ICaseAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativeContext)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELSE, 0)
}

func (s *CaseStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, MariaDBParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4858)
		p.Match(MariaDBParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4861)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4859)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4860)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MariaDBParserWHEN {
		{
			p.SetState(4863)
			p.CaseAlternative()
		}

		p.SetState(4866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserELSE {
		{
			p.SetState(4868)
			p.Match(MariaDBParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4869)
					p.ProcedureSqlStatement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4872)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 718, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4876)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4877)
		p.Match(MariaDBParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_procedureSqlStatement returns the _procedureSqlStatement rule contexts.
	Get_procedureSqlStatement() IProcedureSqlStatementContext

	// Set_procedureSqlStatement sets the _procedureSqlStatement rule contexts.
	Set_procedureSqlStatement(IProcedureSqlStatementContext)

	// GetThenStatements returns the thenStatements rule context list.
	GetThenStatements() []IProcedureSqlStatementContext

	// GetElseStatements returns the elseStatements rule context list.
	GetElseStatements() []IProcedureSqlStatementContext

	// SetThenStatements sets the thenStatements rule context list.
	SetThenStatements([]IProcedureSqlStatementContext)

	// SetElseStatements sets the elseStatements rule context list.
	SetElseStatements([]IProcedureSqlStatementContext)

	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllElifAlternative() []IElifAlternativeContext
	ElifAlternative(i int) IElifAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	_procedureSqlStatement IProcedureSqlStatementContext
	thenStatements         []IProcedureSqlStatementContext
	elseStatements         []IProcedureSqlStatementContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Get_procedureSqlStatement() IProcedureSqlStatementContext {
	return s._procedureSqlStatement
}

func (s *IfStatementContext) Set_procedureSqlStatement(v IProcedureSqlStatementContext) {
	s._procedureSqlStatement = v
}

func (s *IfStatementContext) GetThenStatements() []IProcedureSqlStatementContext {
	return s.thenStatements
}

func (s *IfStatementContext) GetElseStatements() []IProcedureSqlStatementContext {
	return s.elseStatements
}

func (s *IfStatementContext) SetThenStatements(v []IProcedureSqlStatementContext) {
	s.thenStatements = v
}

func (s *IfStatementContext) SetElseStatements(v []IProcedureSqlStatementContext) {
	s.elseStatements = v
}

func (s *IfStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserIF)
}

func (s *IfStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserIF, i)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHEN, 0)
}

func (s *IfStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *IfStatementContext) AllElifAlternative() []IElifAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			len++
		}
	}

	tst := make([]IElifAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElifAlternativeContext); ok {
			tst[i] = t.(IElifAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElifAlternative(i int) IElifAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElifAlternativeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELSE, 0)
}

func (s *IfStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, MariaDBParserRULE_ifStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4879)
		p.Match(MariaDBParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4880)
		p.expression(0)
	}
	{
		p.SetState(4881)
		p.Match(MariaDBParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4882)

				var _x = p.ProcedureSqlStatement()

				localctx.(*IfStatementContext)._procedureSqlStatement = _x
			}
			localctx.(*IfStatementContext).thenStatements = append(localctx.(*IfStatementContext).thenStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4885)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserELSEIF {
		{
			p.SetState(4887)
			p.ElifAlternative()
		}

		p.SetState(4892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserELSE {
		{
			p.SetState(4893)
			p.Match(MariaDBParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4894)

					var _x = p.ProcedureSqlStatement()

					localctx.(*IfStatementContext)._procedureSqlStatement = _x
				}
				localctx.(*IfStatementContext).elseStatements = append(localctx.(*IfStatementContext).elseStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4897)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4901)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4902)
		p.Match(MariaDBParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE() antlr.TerminalNode
	Uid() IUidContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_iterateStatement
	return p
}

func InitEmptyIterateStatementContext(p *IterateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_iterateStatement
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserITERATE, 0)
}

func (s *IterateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (s *IterateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIterateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IterateStatement() (localctx IIterateStatementContext) {
	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, MariaDBParserRULE_iterateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4904)
		p.Match(MariaDBParserITERATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4905)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE() antlr.TerminalNode
	Uid() IUidContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_leaveStatement
	return p
}

func InitEmptyLeaveStatementContext(p *LeaveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_leaveStatement
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAVE, 0)
}

func (s *LeaveStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLeaveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LeaveStatement() (localctx ILeaveStatementContext) {
	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, MariaDBParserRULE_leaveStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4907)
		p.Match(MariaDBParserLEAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4908)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP() []antlr.TerminalNode
	LOOP(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLOOP)
}

func (s *LoopStatementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOOP, i)
}

func (s *LoopStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *LoopStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LoopStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLON_SYMB, 0)
}

func (s *LoopStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, MariaDBParserRULE_loopStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4910)
			p.Uid()
		}
		{
			p.SetState(4911)
			p.Match(MariaDBParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4915)
		p.Match(MariaDBParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4916)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4919)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4921)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4922)
		p.Match(MariaDBParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4923)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT() []antlr.TerminalNode
	REPEAT(i int) antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) AllREPEAT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserREPEAT)
}

func (s *RepeatStatementContext) REPEAT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPEAT, i)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *RepeatStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RepeatStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLON_SYMB, 0)
}

func (s *RepeatStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, MariaDBParserRULE_repeatStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4926)
			p.Uid()
		}
		{
			p.SetState(4927)
			p.Match(MariaDBParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4931)
		p.Match(MariaDBParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4932)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4935)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4937)
		p.Match(MariaDBParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4938)
		p.expression(0)
	}
	{
		p.SetState(4939)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4940)
		p.Match(MariaDBParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4941)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, MariaDBParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4944)
		p.Match(MariaDBParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4945)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE() []antlr.TerminalNode
	WHILE(i int) antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) AllWHILE() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserWHILE)
}

func (s *WhileStatementContext) WHILE(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHILE, i)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDO, 0)
}

func (s *WhileStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *WhileStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WhileStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLON_SYMB, 0)
}

func (s *WhileStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, MariaDBParserRULE_whileStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4947)
			p.Uid()
		}
		{
			p.SetState(4948)
			p.Match(MariaDBParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4952)
		p.Match(MariaDBParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4953)
		p.expression(0)
	}
	{
		p.SetState(4954)
		p.Match(MariaDBParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4955)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4958)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4960)
		p.Match(MariaDBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4961)
		p.Match(MariaDBParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649091674010173440) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845687230545) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&335610497) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-1) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-16777217) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-1) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-288230376160101889) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-549755813889) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-2846283760607985665) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-8193) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-786433) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&-1) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&81064795440218111) != 0) || _la == MariaDBParserID || _la == MariaDBParserREVERSE_QUOTE_ID {
		{
			p.SetState(4962)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorStatementContext is an interface to support dynamic dispatch.
type ICursorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCursorStatementContext differentiates from other interfaces.
	IsCursorStatementContext()
}

type CursorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorStatementContext() *CursorStatementContext {
	var p = new(CursorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cursorStatement
	return p
}

func InitEmptyCursorStatementContext(p *CursorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cursorStatement
}

func (*CursorStatementContext) IsCursorStatementContext() {}

func NewCursorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorStatementContext {
	var p = new(CursorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_cursorStatement

	return p
}

func (s *CursorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorStatementContext) CopyAll(ctx *CursorStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CursorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CloseCursorContext struct {
	CursorStatementContext
}

func NewCloseCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloseCursorContext {
	var p = new(CloseCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *CloseCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseCursorContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLOSE, 0)
}

func (s *CloseCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CloseCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCloseCursor(s)
	}
}

func (s *CloseCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCloseCursor(s)
	}
}

func (s *CloseCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCloseCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

type OpenCursorContext struct {
	CursorStatementContext
}

func NewOpenCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpenCursorContext {
	var p = new(OpenCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *OpenCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenCursorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPEN, 0)
}

func (s *OpenCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *OpenCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOpenCursor(s)
	}
}

func (s *OpenCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOpenCursor(s)
	}
}

func (s *OpenCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOpenCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FetchCursorContext struct {
	CursorStatementContext
}

func NewFetchCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FetchCursorContext {
	var p = new(FetchCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *FetchCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FetchCursorContext) FETCH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFETCH, 0)
}

func (s *FetchCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FetchCursorContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *FetchCursorContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *FetchCursorContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *FetchCursorContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXT, 0)
}

func (s *FetchCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFetchCursor(s)
	}
}

func (s *FetchCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFetchCursor(s)
	}
}

func (s *FetchCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFetchCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CursorStatement() (localctx ICursorStatementContext) {
	localctx = NewCursorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, MariaDBParserRULE_cursorStatement)
	var _la int

	p.SetState(4980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCLOSE:
		localctx = NewCloseCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4965)
			p.Match(MariaDBParserCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4966)
			p.Uid()
		}

	case MariaDBParserFETCH:
		localctx = NewFetchCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4967)
			p.Match(MariaDBParserFETCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4972)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
			p.SetState(4969)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserNEXT {
				{
					p.SetState(4968)
					p.Match(MariaDBParserNEXT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4971)
				p.Match(MariaDBParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4974)
			p.Uid()
		}
		{
			p.SetState(4975)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4976)
			p.UidList()
		}

	case MariaDBParserOPEN:
		localctx = NewOpenCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4978)
			p.Match(MariaDBParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4979)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareVariableContext is an interface to support dynamic dispatch.
type IDeclareVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	UidList() IUidListContext
	DataType() IDataTypeContext
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeclareVariableContext differentiates from other interfaces.
	IsDeclareVariableContext()
}

type DeclareVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareVariableContext() *DeclareVariableContext {
	var p = new(DeclareVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareVariable
	return p
}

func InitEmptyDeclareVariableContext(p *DeclareVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareVariable
}

func (*DeclareVariableContext) IsDeclareVariableContext() {}

func NewDeclareVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareVariableContext {
	var p = new(DeclareVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_declareVariable

	return p
}

func (s *DeclareVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECLARE, 0)
}

func (s *DeclareVariableContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DeclareVariableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DeclareVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *DeclareVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclareVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeclareVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeclareVariable() (localctx IDeclareVariableContext) {
	localctx = NewDeclareVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, MariaDBParserRULE_declareVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4982)
		p.Match(MariaDBParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4983)
		p.UidList()
	}
	{
		p.SetState(4984)
		p.DataType()
	}
	p.SetState(4987)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserDEFAULT {
		{
			p.SetState(4985)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4986)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareConditionContext is an interface to support dynamic dispatch.
type IDeclareConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CONDITION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	SQLSTATE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDeclareConditionContext differentiates from other interfaces.
	IsDeclareConditionContext()
}

type DeclareConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareConditionContext() *DeclareConditionContext {
	var p = new(DeclareConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareCondition
	return p
}

func InitEmptyDeclareConditionContext(p *DeclareConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareCondition
}

func (*DeclareConditionContext) IsDeclareConditionContext() {}

func NewDeclareConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareConditionContext {
	var p = new(DeclareConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_declareCondition

	return p
}

func (s *DeclareConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareConditionContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECLARE, 0)
}

func (s *DeclareConditionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareConditionContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONDITION, 0)
}

func (s *DeclareConditionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *DeclareConditionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeclareConditionContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLSTATE, 0)
}

func (s *DeclareConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *DeclareConditionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *DeclareConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeclareCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeclareCondition() (localctx IDeclareConditionContext) {
	localctx = NewDeclareConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, MariaDBParserRULE_declareCondition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4989)
		p.Match(MariaDBParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4990)
		p.Uid()
	}
	{
		p.SetState(4991)
		p.Match(MariaDBParserCONDITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4992)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
		{
			p.SetState(4993)
			p.DecimalLiteral()
		}

	case MariaDBParserSQLSTATE:
		{
			p.SetState(4994)
			p.Match(MariaDBParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVALUE {
			{
				p.SetState(4995)
				p.Match(MariaDBParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4998)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareCursorContext is an interface to support dynamic dispatch.
type IDeclareCursorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CURSOR() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SelectStatement() ISelectStatementContext

	// IsDeclareCursorContext differentiates from other interfaces.
	IsDeclareCursorContext()
}

type DeclareCursorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareCursorContext() *DeclareCursorContext {
	var p = new(DeclareCursorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareCursor
	return p
}

func InitEmptyDeclareCursorContext(p *DeclareCursorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareCursor
}

func (*DeclareCursorContext) IsDeclareCursorContext() {}

func NewDeclareCursorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareCursorContext {
	var p = new(DeclareCursorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_declareCursor

	return p
}

func (s *DeclareCursorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareCursorContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECLARE, 0)
}

func (s *DeclareCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareCursorContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURSOR, 0)
}

func (s *DeclareCursorContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *DeclareCursorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DeclareCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareCursorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeclareCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeclareCursor() (localctx IDeclareCursorContext) {
	localctx = NewDeclareCursorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, MariaDBParserRULE_declareCursor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5001)
		p.Match(MariaDBParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5002)
		p.Uid()
	}
	{
		p.SetState(5003)
		p.Match(MariaDBParserCURSOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5004)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5005)
		p.SelectStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareHandlerContext is an interface to support dynamic dispatch.
type IDeclareHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHandlerAction returns the handlerAction token.
	GetHandlerAction() antlr.Token

	// SetHandlerAction sets the handlerAction token.
	SetHandlerAction(antlr.Token)

	// Getter signatures
	DECLARE() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllHandlerConditionValue() []IHandlerConditionValueContext
	HandlerConditionValue(i int) IHandlerConditionValueContext
	RoutineBody() IRoutineBodyContext
	CONTINUE() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	UNDO() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDeclareHandlerContext differentiates from other interfaces.
	IsDeclareHandlerContext()
}

type DeclareHandlerContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	handlerAction antlr.Token
}

func NewEmptyDeclareHandlerContext() *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareHandler
	return p
}

func InitEmptyDeclareHandlerContext(p *DeclareHandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_declareHandler
}

func (*DeclareHandlerContext) IsDeclareHandlerContext() {}

func NewDeclareHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_declareHandler

	return p
}

func (s *DeclareHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareHandlerContext) GetHandlerAction() antlr.Token { return s.handlerAction }

func (s *DeclareHandlerContext) SetHandlerAction(v antlr.Token) { s.handlerAction = v }

func (s *DeclareHandlerContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECLARE, 0)
}

func (s *DeclareHandlerContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *DeclareHandlerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *DeclareHandlerContext) AllHandlerConditionValue() []IHandlerConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IHandlerConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerConditionValueContext); ok {
			tst[i] = t.(IHandlerConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *DeclareHandlerContext) HandlerConditionValue(i int) IHandlerConditionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerConditionValueContext)
}

func (s *DeclareHandlerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *DeclareHandlerContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTINUE, 0)
}

func (s *DeclareHandlerContext) EXIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXIT, 0)
}

func (s *DeclareHandlerContext) UNDO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDO, 0)
}

func (s *DeclareHandlerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DeclareHandlerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DeclareHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDeclareHandler(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DeclareHandler() (localctx IDeclareHandlerContext) {
	localctx = NewDeclareHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, MariaDBParserRULE_declareHandler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5007)
		p.Match(MariaDBParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5008)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeclareHandlerContext).handlerAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserCONTINUE || _la == MariaDBParserEXIT || _la == MariaDBParserUNDO) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeclareHandlerContext).handlerAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5009)
		p.Match(MariaDBParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5010)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5011)
		p.HandlerConditionValue()
	}
	p.SetState(5016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(5012)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5013)
			p.HandlerConditionValue()
		}

		p.SetState(5018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5019)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerConditionValueContext is an interface to support dynamic dispatch.
type IHandlerConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHandlerConditionValueContext differentiates from other interfaces.
	IsHandlerConditionValueContext()
}

type HandlerConditionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerConditionValueContext() *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerConditionValue
	return p
}

func InitEmptyHandlerConditionValueContext(p *HandlerConditionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_handlerConditionValue
}

func (*HandlerConditionValueContext) IsHandlerConditionValueContext() {}

func NewHandlerConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_handlerConditionValue

	return p
}

func (s *HandlerConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerConditionValueContext) CopyAll(ctx *HandlerConditionValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *HandlerConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HandlerConditionWarningContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionWarningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionWarningContext {
	var p = new(HandlerConditionWarningContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionWarningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionWarningContext) SQLWARNING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLWARNING, 0)
}

func (s *HandlerConditionWarningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionWarning(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionCodeContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionCodeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionCodeContext {
	var p = new(HandlerConditionCodeContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionCodeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *HandlerConditionCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionCode(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionNotfoundContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNotfoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNotfoundContext {
	var p = new(HandlerConditionNotfoundContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNotfoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNotfoundContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *HandlerConditionNotfoundContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOUND, 0)
}

func (s *HandlerConditionNotfoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionNotfound(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionStateContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionStateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionStateContext {
	var p = new(HandlerConditionStateContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionStateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionStateContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLSTATE, 0)
}

func (s *HandlerConditionStateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *HandlerConditionStateContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *HandlerConditionStateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionState(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionExceptionContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionExceptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionExceptionContext {
	var p = new(HandlerConditionExceptionContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionExceptionContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLEXCEPTION, 0)
}

func (s *HandlerConditionExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionException(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionNameContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNameContext {
	var p = new(HandlerConditionNameContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHandlerConditionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HandlerConditionValue() (localctx IHandlerConditionValueContext) {
	localctx = NewHandlerConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, MariaDBParserRULE_handlerConditionValue)
	var _la int

	p.SetState(5032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
		localctx = NewHandlerConditionCodeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5021)
			p.DecimalLiteral()
		}

	case MariaDBParserSQLSTATE:
		localctx = NewHandlerConditionStateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5022)
			p.Match(MariaDBParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVALUE {
			{
				p.SetState(5023)
				p.Match(MariaDBParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5026)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		localctx = NewHandlerConditionNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5027)
			p.Uid()
		}

	case MariaDBParserSQLWARNING:
		localctx = NewHandlerConditionWarningContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5028)
			p.Match(MariaDBParserSQLWARNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserNOT:
		localctx = NewHandlerConditionNotfoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5029)
			p.Match(MariaDBParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5030)
			p.Match(MariaDBParserFOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSQLEXCEPTION:
		localctx = NewHandlerConditionExceptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5031)
			p.Match(MariaDBParserSQLEXCEPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureSqlStatementContext is an interface to support dynamic dispatch.
type IProcedureSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	SqlStatement() ISqlStatementContext

	// IsProcedureSqlStatementContext differentiates from other interfaces.
	IsProcedureSqlStatementContext()
}

type ProcedureSqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSqlStatementContext() *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_procedureSqlStatement
	return p
}

func InitEmptyProcedureSqlStatementContext(p *ProcedureSqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_procedureSqlStatement
}

func (*ProcedureSqlStatementContext) IsProcedureSqlStatementContext() {}

func NewProcedureSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_procedureSqlStatement

	return p
}

func (s *ProcedureSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSqlStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEMI, 0)
}

func (s *ProcedureSqlStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureSqlStatementContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProcedureSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitProcedureSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ProcedureSqlStatement() (localctx IProcedureSqlStatementContext) {
	localctx = NewProcedureSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, MariaDBParserRULE_procedureSqlStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5034)
			p.CompoundStatement()
		}

	case 2:
		{
			p.SetState(5035)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(5038)
		p.Match(MariaDBParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseAlternativeContext is an interface to support dynamic dispatch.
type ICaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	Constant() IConstantContext
	Expression() IExpressionContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseAlternativeContext differentiates from other interfaces.
	IsCaseAlternativeContext()
}

type CaseAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativeContext() *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseAlternative
	return p
}

func InitEmptyCaseAlternativeContext(p *CaseAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseAlternative
}

func (*CaseAlternativeContext) IsCaseAlternativeContext() {}

func NewCaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_caseAlternative

	return p
}

func (s *CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHEN, 0)
}

func (s *CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHEN, 0)
}

func (s *CaseAlternativeContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *CaseAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCaseAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CaseAlternative() (localctx ICaseAlternativeContext) {
	localctx = NewCaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, MariaDBParserRULE_caseAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5040)
		p.Match(MariaDBParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 743, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5041)
			p.Constant()
		}

	case 2:
		{
			p.SetState(5042)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(5045)
		p.Match(MariaDBParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5046)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5049)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElifAlternativeContext is an interface to support dynamic dispatch.
type IElifAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSEIF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsElifAlternativeContext differentiates from other interfaces.
	IsElifAlternativeContext()
}

type ElifAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElifAlternativeContext() *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_elifAlternative
	return p
}

func InitEmptyElifAlternativeContext(p *ElifAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_elifAlternative
}

func (*ElifAlternativeContext) IsElifAlternativeContext() {}

func NewElifAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_elifAlternative

	return p
}

func (s *ElifAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElifAlternativeContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELSEIF, 0)
}

func (s *ElifAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElifAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHEN, 0)
}

func (s *ElifAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *ElifAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *ElifAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElifAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElifAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitElifAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ElifAlternative() (localctx IElifAlternativeContext) {
	localctx = NewElifAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, MariaDBParserRULE_elifAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5051)
		p.Match(MariaDBParserELSEIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5052)
		p.expression(0)
	}
	{
		p.SetState(5053)
		p.Match(MariaDBParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5054)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5057)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) CopyAll(ctx *AlterUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUserMysqlV80Context struct {
	AlterUserContext
	tlsNone antlr.Token
}

func NewAlterUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV80Context {
	var p = new(AlterUserMysqlV80Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *AlterUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *AlterUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV80Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *AlterUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *AlterUserMysqlV80Context) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREQUIRE, 0)
}

func (s *AlterUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *AlterUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *AlterUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *AlterUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *AlterUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AlterUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserATTRIBUTE, 0)
}

func (s *AlterUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *AlterUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *AlterUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *AlterUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserAND)
}

func (s *AlterUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, i)
}

func (s *AlterUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterUserMysqlV56Context struct {
	AlterUserContext
}

func NewAlterUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV56Context {
	var p = new(AlterUserMysqlV56Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV56Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *AlterUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *AlterUserMysqlV56Context) AllUserSpecification() []IUserSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IUserSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserSpecificationContext); ok {
			tst[i] = t.(IUserSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV56Context) UserSpecification(i int) IUserSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSpecificationContext)
}

func (s *AlterUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AlterUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AlterUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAlterUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, MariaDBParserRULE_alterUser)
	var _la int

	p.SetState(5119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 758, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5059)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5060)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5061)
			p.UserSpecification()
		}
		p.SetState(5066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5062)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5063)
				p.UserSpecification()
			}

			p.SetState(5068)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5069)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5070)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIF {
			{
				p.SetState(5071)
				p.IfExists()
			}

		}
		{
			p.SetState(5074)
			p.UserAuthOption()
		}
		p.SetState(5079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5075)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5076)
				p.UserAuthOption()
			}

			p.SetState(5081)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserREQUIRE {
			{
				p.SetState(5082)
				p.Match(MariaDBParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5094)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserNONE:
				{
					p.SetState(5083)

					var _m = p.Match(MariaDBParserNONE)

					localctx.(*AlterUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MariaDBParserSSL, MariaDBParserCIPHER, MariaDBParserISSUER, MariaDBParserSUBJECT, MariaDBParserX509:
				{
					p.SetState(5084)
					p.TlsOption()
				}
				p.SetState(5091)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MariaDBParserAND || _la == MariaDBParserSSL || _la == MariaDBParserCIPHER || _la == MariaDBParserISSUER || _la == MariaDBParserSUBJECT || _la == MariaDBParserX509 {
					p.SetState(5086)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MariaDBParserAND {
						{
							p.SetState(5085)
							p.Match(MariaDBParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5088)
						p.TlsOption()
					}

					p.SetState(5093)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(5098)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5100)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&51) != 0) {
				{
					p.SetState(5099)
					p.UserResourceOption()
				}

				p.SetState(5102)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(5110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserACCOUNT || _la == MariaDBParserFAILED_LOGIN_ATTEMPTS || _la == MariaDBParserPASSWORD || _la == MariaDBParserPASSWORD_LOCK_TIME {
			p.SetState(5108)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5106)
					p.UserPasswordOption()
				}

			case MariaDBParserACCOUNT:
				{
					p.SetState(5107)
					p.UserLockOption()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5112)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserCOMMENT:
			{
				p.SetState(5113)
				p.Match(MariaDBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5114)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserATTRIBUTE:
			{
				p.SetState(5115)
				p.Match(MariaDBParserATTRIBUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5116)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserSEMI:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CopyAll(ctx *CreateUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateUserMysqlV56Context struct {
	CreateUserContext
}

func NewCreateUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV56Context {
	var p = new(CreateUserMysqlV56Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV56Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *CreateUserMysqlV56Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV56Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateUserMysqlV80Context struct {
	CreateUserContext
	tlsNone antlr.Token
}

func NewCreateUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV80Context {
	var p = new(CreateUserMysqlV80Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *CreateUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *CreateUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV80Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *CreateUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV80Context) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CreateUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CreateUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREQUIRE, 0)
}

func (s *CreateUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *CreateUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *CreateUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *CreateUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *CreateUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserATTRIBUTE, 0)
}

func (s *CreateUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *CreateUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *CreateUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *CreateUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserAND)
}

func (s *CreateUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, i)
}

func (s *CreateUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, MariaDBParserRULE_createUser)
	var _la int

	p.SetState(5181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5121)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5122)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5123)
			p.UserAuthOption()
		}
		p.SetState(5128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5124)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5125)
				p.UserAuthOption()
			}

			p.SetState(5130)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewCreateUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5131)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5132)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIF {
			{
				p.SetState(5133)
				p.IfNotExists()
			}

		}
		{
			p.SetState(5136)
			p.UserAuthOption()
		}
		p.SetState(5141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5137)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5138)
				p.UserAuthOption()
			}

			p.SetState(5143)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserREQUIRE {
			{
				p.SetState(5144)
				p.Match(MariaDBParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5156)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserNONE:
				{
					p.SetState(5145)

					var _m = p.Match(MariaDBParserNONE)

					localctx.(*CreateUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MariaDBParserSSL, MariaDBParserCIPHER, MariaDBParserISSUER, MariaDBParserSUBJECT, MariaDBParserX509:
				{
					p.SetState(5146)
					p.TlsOption()
				}
				p.SetState(5153)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MariaDBParserAND || _la == MariaDBParserSSL || _la == MariaDBParserCIPHER || _la == MariaDBParserISSUER || _la == MariaDBParserSUBJECT || _la == MariaDBParserX509 {
					p.SetState(5148)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MariaDBParserAND {
						{
							p.SetState(5147)
							p.Match(MariaDBParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5150)
						p.TlsOption()
					}

					p.SetState(5155)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(5160)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5162)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&51) != 0) {
				{
					p.SetState(5161)
					p.UserResourceOption()
				}

				p.SetState(5164)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(5172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserACCOUNT || _la == MariaDBParserFAILED_LOGIN_ATTEMPTS || _la == MariaDBParserPASSWORD || _la == MariaDBParserPASSWORD_LOCK_TIME {
			p.SetState(5170)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5168)
					p.UserPasswordOption()
				}

			case MariaDBParserACCOUNT:
				{
					p.SetState(5169)
					p.UserLockOption()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5174)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserCOMMENT:
			{
				p.SetState(5175)
				p.Match(MariaDBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5176)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserATTRIBUTE:
			{
				p.SetState(5177)
				p.Match(MariaDBParserATTRIBUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5178)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserSEMI:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *DropUserContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DropUserContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DropUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, MariaDBParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5183)
		p.Match(MariaDBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5184)
		p.Match(MariaDBParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIF {
		{
			p.SetState(5185)
			p.IfExists()
		}

	}
	{
		p.SetState(5188)
		p.UserName()
	}
	p.SetState(5193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(5189)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5190)
			p.UserName()
		}

		p.SetState(5195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantStatementContext is an interface to support dynamic dispatch.
type IGrantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrivilegeObject returns the privilegeObject token.
	GetPrivilegeObject() antlr.Token

	// GetTlsNone returns the tlsNone token.
	GetTlsNone() antlr.Token

	// SetPrivilegeObject sets the privilegeObject token.
	SetPrivilegeObject(antlr.Token)

	// SetTlsNone sets the tlsNone token.
	SetTlsNone(antlr.Token)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	AllPrivelegeClause() []IPrivelegeClauseContext
	PrivelegeClause(i int) IPrivelegeClauseContext
	ON() antlr.TerminalNode
	PrivilegeLevel() IPrivilegeLevelContext
	TO() antlr.TerminalNode
	AllUserAuthOption() []IUserAuthOptionContext
	UserAuthOption(i int) IUserAuthOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	ROLE() antlr.TerminalNode
	RoleOption() IRoleOptionContext
	TABLE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	AllTlsOption() []ITlsOptionContext
	TlsOption(i int) ITlsOptionContext
	NONE() antlr.TerminalNode
	AllOPTION() []antlr.TerminalNode
	OPTION(i int) antlr.TerminalNode
	AllUserResourceOption() []IUserResourceOptionContext
	UserResourceOption(i int) IUserResourceOptionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADMIN() antlr.TerminalNode

	// IsGrantStatementContext differentiates from other interfaces.
	IsGrantStatementContext()
}

type GrantStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	privilegeObject antlr.Token
	tlsNone         antlr.Token
}

func NewEmptyGrantStatementContext() *GrantStatementContext {
	var p = new(GrantStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_grantStatement
	return p
}

func InitEmptyGrantStatementContext(p *GrantStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_grantStatement
}

func (*GrantStatementContext) IsGrantStatementContext() {}

func NewGrantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantStatementContext {
	var p = new(GrantStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_grantStatement

	return p
}

func (s *GrantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantStatementContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *GrantStatementContext) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *GrantStatementContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *GrantStatementContext) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *GrantStatementContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserGRANT)
}

func (s *GrantStatementContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANT, i)
}

func (s *GrantStatementContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *GrantStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *GrantStatementContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *GrantStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *GrantStatementContext) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *GrantStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *GrantStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *GrantStatementContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREQUIRE, 0)
}

func (s *GrantStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserWITH)
}

func (s *GrantStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, i)
}

func (s *GrantStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *GrantStatementContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *GrantStatementContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *GrantStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *GrantStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *GrantStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *GrantStatementContext) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *GrantStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *GrantStatementContext) AllOPTION() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserOPTION)
}

func (s *GrantStatementContext) OPTION(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, i)
}

func (s *GrantStatementContext) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *GrantStatementContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserAND)
}

func (s *GrantStatementContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, i)
}

func (s *GrantStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *GrantStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADMIN, 0)
}

func (s *GrantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGrantStatement(s)
	}
}

func (s *GrantStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGrantStatement(s)
	}
}

func (s *GrantStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGrantStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) GrantStatement() (localctx IGrantStatementContext) {
	localctx = NewGrantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, MariaDBParserRULE_grantStatement)
	var _la int

	var _alt int

	p.SetState(5289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 792, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5196)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5197)
			p.PrivelegeClause()
		}
		p.SetState(5202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5198)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5199)
				p.PrivelegeClause()
			}

			p.SetState(5204)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5205)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5207)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 775, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5206)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*GrantStatementContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserPROCEDURE || _la == MariaDBParserTABLE || _la == MariaDBParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*GrantStatementContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5209)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5210)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5211)
			p.UserAuthOption()
		}
		p.SetState(5216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5212)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5213)
				p.UserAuthOption()
			}

			p.SetState(5218)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserREQUIRE {
			{
				p.SetState(5219)
				p.Match(MariaDBParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5231)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserNONE:
				{
					p.SetState(5220)

					var _m = p.Match(MariaDBParserNONE)

					localctx.(*GrantStatementContext).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MariaDBParserSSL, MariaDBParserCIPHER, MariaDBParserISSUER, MariaDBParserSUBJECT, MariaDBParserX509:
				{
					p.SetState(5221)
					p.TlsOption()
				}
				p.SetState(5228)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MariaDBParserAND || _la == MariaDBParserSSL || _la == MariaDBParserCIPHER || _la == MariaDBParserISSUER || _la == MariaDBParserSUBJECT || _la == MariaDBParserX509 {
					p.SetState(5223)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MariaDBParserAND {
						{
							p.SetState(5222)
							p.Match(MariaDBParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5225)
						p.TlsOption()
					}

					p.SetState(5230)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(5235)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5241)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(5239)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case MariaDBParserGRANT:
						{
							p.SetState(5236)
							p.Match(MariaDBParserGRANT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(5237)
							p.Match(MariaDBParserOPTION)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					case MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS:
						{
							p.SetState(5238)
							p.UserResourceOption()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(5243)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}
		p.SetState(5252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(5246)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5247)
				p.UserName()
			}
			{
				p.SetState(5248)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5249)
				p.Match(MariaDBParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5250)
				p.RoleOption()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5254)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 785, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5255)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5256)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5259)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5262)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 786, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5260)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5261)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5269)
			p.Match(MariaDBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5270)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5271)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5274)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5277)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 789, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5275)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5276)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5283)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(5284)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5285)
				p.Match(MariaDBParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5286)
				p.Match(MariaDBParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOptionContext is an interface to support dynamic dispatch.
type IRoleOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRoleOptionContext differentiates from other interfaces.
	IsRoleOptionContext()
}

type RoleOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOptionContext() *RoleOptionContext {
	var p = new(RoleOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_roleOption
	return p
}

func InitEmptyRoleOptionContext(p *RoleOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_roleOption
}

func (*RoleOptionContext) IsRoleOptionContext() {}

func NewRoleOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOptionContext {
	var p = new(RoleOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_roleOption

	return p
}

func (s *RoleOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *RoleOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *RoleOptionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *RoleOptionContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCEPT, 0)
}

func (s *RoleOptionContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleOptionContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RoleOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RoleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoleOption(s)
	}
}

func (s *RoleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoleOption(s)
	}
}

func (s *RoleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoleOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RoleOption() (localctx IRoleOptionContext) {
	localctx = NewRoleOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, MariaDBParserRULE_roleOption)
	var _la int

	p.SetState(5313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 796, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5291)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5292)
			p.Match(MariaDBParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5293)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserEXCEPT {
			{
				p.SetState(5294)
				p.Match(MariaDBParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5295)
				p.UserName()
			}
			p.SetState(5300)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(5296)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5297)
					p.UserName()
				}

				p.SetState(5302)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5305)
			p.UserName()
		}
		p.SetState(5310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5306)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5307)
				p.UserName()
			}

			p.SetState(5312)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantProxyContext is an interface to support dynamic dispatch.
type IGrantProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetToOther returns the toOther rule context list.
	GetToOther() []IUserNameContext

	// SetToOther sets the toOther rule context list.
	SetToOther([]IUserNameContext)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrantProxyContext differentiates from other interfaces.
	IsGrantProxyContext()
}

type GrantProxyContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
	_userName IUserNameContext
	toOther   []IUserNameContext
}

func NewEmptyGrantProxyContext() *GrantProxyContext {
	var p = new(GrantProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_grantProxy
	return p
}

func InitEmptyGrantProxyContext(p *GrantProxyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_grantProxy
}

func (*GrantProxyContext) IsGrantProxyContext() {}

func NewGrantProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantProxyContext {
	var p = new(GrantProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_grantProxy

	return p
}

func (s *GrantProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *GrantProxyContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *GrantProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *GrantProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *GrantProxyContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *GrantProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *GrantProxyContext) GetToOther() []IUserNameContext { return s.toOther }

func (s *GrantProxyContext) SetToOther(v []IUserNameContext) { s.toOther = v }

func (s *GrantProxyContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserGRANT)
}

func (s *GrantProxyContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANT, i)
}

func (s *GrantProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROXY, 0)
}

func (s *GrantProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *GrantProxyContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *GrantProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *GrantProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *GrantProxyContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *GrantProxyContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, 0)
}

func (s *GrantProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGrantProxy(s)
	}
}

func (s *GrantProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGrantProxy(s)
	}
}

func (s *GrantProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGrantProxy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) GrantProxy() (localctx IGrantProxyContext) {
	localctx = NewGrantProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, MariaDBParserRULE_grantProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5315)
		p.Match(MariaDBParserGRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5316)
		p.Match(MariaDBParserPROXY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5317)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5318)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).fromFirst = _x
	}
	{
		p.SetState(5319)
		p.Match(MariaDBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5320)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).toFirst = _x
	}
	p.SetState(5325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(5321)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5322)

			var _x = p.UserName()

			localctx.(*GrantProxyContext)._userName = _x
		}
		localctx.(*GrantProxyContext).toOther = append(localctx.(*GrantProxyContext).toOther, localctx.(*GrantProxyContext)._userName)

		p.SetState(5327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserWITH {
		{
			p.SetState(5328)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5329)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5330)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRenameUserClause() []IRenameUserClauseContext
	RenameUserClause(i int) IRenameUserClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameUser
	return p
}

func InitEmptyRenameUserContext(p *RenameUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameUser
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRENAME, 0)
}

func (s *RenameUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *RenameUserContext) AllRenameUserClause() []IRenameUserClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameUserClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameUserClauseContext); ok {
			tst[i] = t.(IRenameUserClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) RenameUserClause(i int) IRenameUserClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserClauseContext)
}

func (s *RenameUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RenameUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (s *RenameUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRenameUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RenameUser() (localctx IRenameUserContext) {
	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, MariaDBParserRULE_renameUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5333)
		p.Match(MariaDBParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5334)
		p.Match(MariaDBParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5335)
		p.RenameUserClause()
	}
	p.SetState(5340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(5336)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5337)
			p.RenameUserClause()
		}

		p.SetState(5342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeStatementContext is an interface to support dynamic dispatch.
type IRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeStatementContext differentiates from other interfaces.
	IsRevokeStatementContext()
}

type RevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeStatementContext() *RevokeStatementContext {
	var p = new(RevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_revokeStatement
	return p
}

func InitEmptyRevokeStatementContext(p *RevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_revokeStatement
}

func (*RevokeStatementContext) IsRevokeStatementContext() {}

func NewRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeStatementContext {
	var p = new(RevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_revokeStatement

	return p
}

func (s *RevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeStatementContext) CopyAll(ctx *RevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DetailRevokeContext struct {
	RevokeStatementContext
	privilegeObject antlr.Token
}

func NewDetailRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DetailRevokeContext {
	var p = new(DetailRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *DetailRevokeContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *DetailRevokeContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *DetailRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DetailRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVOKE, 0)
}

func (s *DetailRevokeContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *DetailRevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *DetailRevokeContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *DetailRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *DetailRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DetailRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DetailRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DetailRevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *DetailRevokeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *DetailRevokeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *DetailRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDetailRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoleRevokeContext struct {
	RevokeStatementContext
}

func NewRoleRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoleRevokeContext {
	var p = new(RoleRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *RoleRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVOKE, 0)
}

func (s *RoleRevokeContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *RoleRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RoleRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RoleRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoleRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShortRevokeContext struct {
	RevokeStatementContext
}

func NewShortRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShortRevokeContext {
	var p = new(ShortRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *ShortRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVOKE, 0)
}

func (s *ShortRevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *ShortRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ShortRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ShortRevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANT, 0)
}

func (s *ShortRevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, 0)
}

func (s *ShortRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ShortRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *ShortRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShortRevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIVILEGES, 0)
}

func (s *ShortRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShortRevoke(s)
	}
}

func (s *ShortRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShortRevoke(s)
	}
}

func (s *ShortRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShortRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RevokeStatement() (localctx IRevokeStatementContext) {
	localctx = NewRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, MariaDBParserRULE_revokeStatement)
	var _la int

	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDetailRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5343)
			p.Match(MariaDBParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5344)
			p.PrivelegeClause()
		}
		p.SetState(5349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5345)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5346)
				p.PrivelegeClause()
			}

			p.SetState(5351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5352)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 801, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5353)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*DetailRevokeContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserPROCEDURE || _la == MariaDBParserTABLE || _la == MariaDBParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*DetailRevokeContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5356)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5357)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5358)
			p.UserName()
		}
		p.SetState(5363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5359)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5360)
				p.UserName()
			}

			p.SetState(5365)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewShortRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5366)
			p.Match(MariaDBParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5367)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPRIVILEGES {
			{
				p.SetState(5368)
				p.Match(MariaDBParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5371)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5372)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5373)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5374)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5375)
			p.UserName()
		}
		p.SetState(5380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5376)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5377)
				p.UserName()
			}

			p.SetState(5382)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewRoleRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5383)
			p.Match(MariaDBParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5384)
			p.Uid()
		}
		p.SetState(5389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5385)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5386)
				p.Uid()
			}

			p.SetState(5391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5392)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5393)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5394)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5397)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5400)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 807, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5398)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5399)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5406)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeProxyContext is an interface to support dynamic dispatch.
type IRevokeProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnUser returns the onUser rule contexts.
	GetOnUser() IUserNameContext

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetOnUser sets the onUser rule contexts.
	SetOnUser(IUserNameContext)

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetFromOther returns the fromOther rule context list.
	GetFromOther() []IUserNameContext

	// SetFromOther sets the fromOther rule context list.
	SetFromOther([]IUserNameContext)

	// Getter signatures
	REVOKE() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevokeProxyContext differentiates from other interfaces.
	IsRevokeProxyContext()
}

type RevokeProxyContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	onUser    IUserNameContext
	fromFirst IUserNameContext
	_userName IUserNameContext
	fromOther []IUserNameContext
}

func NewEmptyRevokeProxyContext() *RevokeProxyContext {
	var p = new(RevokeProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_revokeProxy
	return p
}

func InitEmptyRevokeProxyContext(p *RevokeProxyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_revokeProxy
}

func (*RevokeProxyContext) IsRevokeProxyContext() {}

func NewRevokeProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeProxyContext {
	var p = new(RevokeProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_revokeProxy

	return p
}

func (s *RevokeProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeProxyContext) GetOnUser() IUserNameContext { return s.onUser }

func (s *RevokeProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RevokeProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *RevokeProxyContext) SetOnUser(v IUserNameContext) { s.onUser = v }

func (s *RevokeProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RevokeProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *RevokeProxyContext) GetFromOther() []IUserNameContext { return s.fromOther }

func (s *RevokeProxyContext) SetFromOther(v []IUserNameContext) { s.fromOther = v }

func (s *RevokeProxyContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVOKE, 0)
}

func (s *RevokeProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROXY, 0)
}

func (s *RevokeProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *RevokeProxyContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *RevokeProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RevokeProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RevokeProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *RevokeProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *RevokeProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRevokeProxy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RevokeProxy() (localctx IRevokeProxyContext) {
	localctx = NewRevokeProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, MariaDBParserRULE_revokeProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5409)
		p.Match(MariaDBParserREVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5410)
		p.Match(MariaDBParserPROXY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5411)
		p.Match(MariaDBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5412)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).onUser = _x
	}
	{
		p.SetState(5413)
		p.Match(MariaDBParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5414)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).fromFirst = _x
	}
	p.SetState(5419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(5415)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5416)

			var _x = p.UserName()

			localctx.(*RevokeProxyContext)._userName = _x
		}
		localctx.(*RevokeProxyContext).fromOther = append(localctx.(*RevokeProxyContext).fromOther, localctx.(*RevokeProxyContext)._userName)

		p.SetState(5421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetPasswordStatementContext is an interface to support dynamic dispatch.
type ISetPasswordStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	PasswordFunctionClause() IPasswordFunctionClauseContext
	STRING_LITERAL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	UserName() IUserNameContext

	// IsSetPasswordStatementContext differentiates from other interfaces.
	IsSetPasswordStatementContext()
}

type SetPasswordStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPasswordStatementContext() *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setPasswordStatement
	return p
}

func InitEmptySetPasswordStatementContext(p *SetPasswordStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setPasswordStatement
}

func (*SetPasswordStatementContext) IsSetPasswordStatementContext() {}

func NewSetPasswordStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setPasswordStatement

	return p
}

func (s *SetPasswordStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPasswordStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetPasswordStatementContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *SetPasswordStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *SetPasswordStatementContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *SetPasswordStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SetPasswordStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *SetPasswordStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetPasswordStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetPasswordStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetPasswordStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetPasswordStatement() (localctx ISetPasswordStatementContext) {
	localctx = NewSetPasswordStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, MariaDBParserRULE_setPasswordStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5422)
		p.Match(MariaDBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5423)
		p.Match(MariaDBParserPASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFOR {
		{
			p.SetState(5424)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5425)
			p.UserName()
		}

	}
	{
		p.SetState(5428)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserOLD_PASSWORD, MariaDBParserPASSWORD:
		{
			p.SetState(5429)
			p.PasswordFunctionClause()
		}

	case MariaDBParserSTRING_LITERAL:
		{
			p.SetState(5430)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserSpecificationContext is an interface to support dynamic dispatch.
type IUserSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	UserPasswordOption() IUserPasswordOptionContext

	// IsUserSpecificationContext differentiates from other interfaces.
	IsUserSpecificationContext()
}

type UserSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSpecificationContext() *UserSpecificationContext {
	var p = new(UserSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userSpecification
	return p
}

func InitEmptyUserSpecificationContext(p *UserSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userSpecification
}

func (*UserSpecificationContext) IsUserSpecificationContext() {}

func NewUserSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSpecificationContext {
	var p = new(UserSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userSpecification

	return p
}

func (s *UserSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSpecificationContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *UserSpecificationContext) UserPasswordOption() IUserPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *UserSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserSpecification(s)
	}
}

func (s *UserSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserSpecification(s)
	}
}

func (s *UserSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserSpecification() (localctx IUserSpecificationContext) {
	localctx = NewUserSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, MariaDBParserRULE_userSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5433)
		p.UserName()
	}
	{
		p.SetState(5434)
		p.UserPasswordOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserAuthOptionContext is an interface to support dynamic dispatch.
type IUserAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserAuthOptionContext differentiates from other interfaces.
	IsUserAuthOptionContext()
}

type UserAuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserAuthOptionContext() *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userAuthOption
	return p
}

func InitEmptyUserAuthOptionContext(p *UserAuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userAuthOption
}

func (*UserAuthOptionContext) IsUserAuthOptionContext() {}

func NewUserAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userAuthOption

	return p
}

func (s *UserAuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserAuthOptionContext) CopyAll(ctx *UserAuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserAuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewSimpleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleAuthOptionContext {
	var p = new(SimpleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *SimpleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SimpleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModuleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewModuleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleAuthOptionContext {
	var p = new(ModuleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *ModuleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ModuleAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIDENTIFIED, 0)
}

func (s *ModuleAuthOptionContext) AllAuthenticationRule() []IAuthenticationRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAuthenticationRuleContext); ok {
			len++
		}
	}

	tst := make([]IAuthenticationRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAuthenticationRuleContext); ok {
			tst[i] = t.(IAuthenticationRuleContext)
			i++
		}
	}

	return tst
}

func (s *ModuleAuthOptionContext) AuthenticationRule(i int) IAuthenticationRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationRuleContext)
}

func (s *ModuleAuthOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *ModuleAuthOptionContext) VIA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIA, 0)
}

func (s *ModuleAuthOptionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserOR)
}

func (s *ModuleAuthOptionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserOR, i)
}

func (s *ModuleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitModuleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringAuthOptionContext struct {
	UserAuthOptionContext
}

func NewStringAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAuthOptionContext {
	var p = new(StringAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *StringAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *StringAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIDENTIFIED, 0)
}

func (s *StringAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *StringAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *StringAuthOptionContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETAIN, 0)
}

func (s *StringAuthOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT, 0)
}

func (s *StringAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *StringAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStringAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type HashAuthOptionContext struct {
	UserAuthOptionContext
	hashed antlr.Token
}

func NewHashAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HashAuthOptionContext {
	var p = new(HashAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *HashAuthOptionContext) GetHashed() antlr.Token { return s.hashed }

func (s *HashAuthOptionContext) SetHashed(v antlr.Token) { s.hashed = v }

func (s *HashAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *HashAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIDENTIFIED, 0)
}

func (s *HashAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *HashAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *HashAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *HashAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHashAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserAuthOption() (localctx IUserAuthOptionContext) {
	localctx = NewUserAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, MariaDBParserRULE_userAuthOption)
	var _la int

	p.SetState(5463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext()) {
	case 1:
		localctx = NewHashAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5436)
			p.UserName()
		}
		{
			p.SetState(5437)
			p.Match(MariaDBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5438)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5439)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5440)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*HashAuthOptionContext).hashed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewStringAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5442)
			p.UserName()
		}
		{
			p.SetState(5443)
			p.Match(MariaDBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5444)
			p.Match(MariaDBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5445)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserRETAIN {
			{
				p.SetState(5446)
				p.Match(MariaDBParserRETAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5447)
				p.Match(MariaDBParserCURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5448)
				p.Match(MariaDBParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewModuleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5451)
			p.UserName()
		}
		{
			p.SetState(5452)
			p.Match(MariaDBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5453)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserWITH || _la == MariaDBParserVIA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5454)
			p.AuthenticationRule()
		}
		p.SetState(5459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserOR {
			{
				p.SetState(5455)
				p.Match(MariaDBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5456)
				p.AuthenticationRule()
			}

			p.SetState(5461)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewSimpleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5462)
			p.UserName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthenticationRuleContext is an interface to support dynamic dispatch.
type IAuthenticationRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationRuleContext differentiates from other interfaces.
	IsAuthenticationRuleContext()
}

type AuthenticationRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationRuleContext() *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_authenticationRule
	return p
}

func InitEmptyAuthenticationRuleContext(p *AuthenticationRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_authenticationRule
}

func (*AuthenticationRuleContext) IsAuthenticationRuleContext() {}

func NewAuthenticationRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_authenticationRule

	return p
}

func (s *AuthenticationRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationRuleContext) CopyAll(ctx *AuthenticationRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthenticationRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PasswordModuleOptionContext struct {
	AuthenticationRuleContext
}

func NewPasswordModuleOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordModuleOptionContext {
	var p = new(PasswordModuleOptionContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *PasswordModuleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordModuleOptionContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *PasswordModuleOptionContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordModuleOptionContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *PasswordModuleOptionContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *PasswordModuleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPasswordModuleOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModuleContext struct {
	AuthenticationRuleContext
}

func NewModuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleContext {
	var p = new(ModuleContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *ModuleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ModuleContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *ModuleContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *ModuleContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitModule(s)
	}
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AuthenticationRule() (localctx IAuthenticationRuleContext) {
	localctx = NewAuthenticationRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, MariaDBParserRULE_authenticationRule)
	var _la int

	p.SetState(5474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) {
	case 1:
		localctx = NewModuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5465)
			p.AuthPlugin()
		}
		p.SetState(5468)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 816, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5466)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserAS || _la == MariaDBParserBY || _la == MariaDBParserUSING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5467)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewPasswordModuleOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5470)
			p.AuthPlugin()
		}
		{
			p.SetState(5471)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserAS || _la == MariaDBParserUSING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5472)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITlsOptionContext is an interface to support dynamic dispatch.
type ITlsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSL() antlr.TerminalNode
	X509() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode

	// IsTlsOptionContext differentiates from other interfaces.
	IsTlsOptionContext()
}

type TlsOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTlsOptionContext() *TlsOptionContext {
	var p = new(TlsOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tlsOption
	return p
}

func InitEmptyTlsOptionContext(p *TlsOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tlsOption
}

func (*TlsOptionContext) IsTlsOptionContext() {}

func NewTlsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TlsOptionContext {
	var p = new(TlsOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tlsOption

	return p
}

func (s *TlsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TlsOptionContext) SSL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSSL, 0)
}

func (s *TlsOptionContext) X509() antlr.TerminalNode {
	return s.GetToken(MariaDBParserX509, 0)
}

func (s *TlsOptionContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCIPHER, 0)
}

func (s *TlsOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *TlsOptionContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISSUER, 0)
}

func (s *TlsOptionContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBJECT, 0)
}

func (s *TlsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TlsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TlsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTlsOption(s)
	}
}

func (s *TlsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTlsOption(s)
	}
}

func (s *TlsOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTlsOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TlsOption() (localctx ITlsOptionContext) {
	localctx = NewTlsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, MariaDBParserRULE_tlsOption)
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSSL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5476)
			p.Match(MariaDBParserSSL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserX509:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5477)
			p.Match(MariaDBParserX509)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCIPHER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5478)
			p.Match(MariaDBParserCIPHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5479)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserISSUER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5480)
			p.Match(MariaDBParserISSUER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5481)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSUBJECT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5482)
			p.Match(MariaDBParserSUBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5483)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserResourceOptionContext is an interface to support dynamic dispatch.
type IUserResourceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode

	// IsUserResourceOptionContext differentiates from other interfaces.
	IsUserResourceOptionContext()
}

type UserResourceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserResourceOptionContext() *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userResourceOption
	return p
}

func InitEmptyUserResourceOptionContext(p *UserResourceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userResourceOption
}

func (*UserResourceOptionContext) IsUserResourceOptionContext() {}

func NewUserResourceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userResourceOption

	return p
}

func (s *UserResourceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserResourceOptionContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserResourceOptionContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_USER_CONNECTIONS, 0)
}

func (s *UserResourceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserResourceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserResourceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserResourceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserResourceOption() (localctx IUserResourceOptionContext) {
	localctx = NewUserResourceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, MariaDBParserRULE_userResourceOption)
	p.SetState(5494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserMAX_QUERIES_PER_HOUR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5486)
			p.Match(MariaDBParserMAX_QUERIES_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5487)
			p.DecimalLiteral()
		}

	case MariaDBParserMAX_UPDATES_PER_HOUR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5488)
			p.Match(MariaDBParserMAX_UPDATES_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5489)
			p.DecimalLiteral()
		}

	case MariaDBParserMAX_CONNECTIONS_PER_HOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5490)
			p.Match(MariaDBParserMAX_CONNECTIONS_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5491)
			p.DecimalLiteral()
		}

	case MariaDBParserMAX_USER_CONNECTIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5492)
			p.Match(MariaDBParserMAX_USER_CONNECTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5493)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPasswordOptionContext is an interface to support dynamic dispatch.
type IUserPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpireType returns the expireType token.
	GetExpireType() antlr.Token

	// SetExpireType sets the expireType token.
	SetExpireType(antlr.Token)

	// Getter signatures
	PASSWORD() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	DAY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode

	// IsUserPasswordOptionContext differentiates from other interfaces.
	IsUserPasswordOptionContext()
}

type UserPasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	expireType antlr.Token
}

func NewEmptyUserPasswordOptionContext() *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userPasswordOption
	return p
}

func InitEmptyUserPasswordOptionContext(p *UserPasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userPasswordOption
}

func (*UserPasswordOptionContext) IsUserPasswordOptionContext() {}

func NewUserPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userPasswordOption

	return p
}

func (s *UserPasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordOptionContext) GetExpireType() antlr.Token { return s.expireType }

func (s *UserPasswordOptionContext) SetExpireType(v antlr.Token) { s.expireType = v }

func (s *UserPasswordOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *UserPasswordOptionContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPIRE, 0)
}

func (s *UserPasswordOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserPasswordOptionContext) DAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY, 0)
}

func (s *UserPasswordOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *UserPasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEVER, 0)
}

func (s *UserPasswordOptionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERVAL, 0)
}

func (s *UserPasswordOptionContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHISTORY, 0)
}

func (s *UserPasswordOptionContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREUSE, 0)
}

func (s *UserPasswordOptionContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREQUIRE, 0)
}

func (s *UserPasswordOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT, 0)
}

func (s *UserPasswordOptionContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONAL, 0)
}

func (s *UserPasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *UserPasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD_LOCK_TIME, 0)
}

func (s *UserPasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNBOUNDED, 0)
}

func (s *UserPasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserPasswordOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserPasswordOption() (localctx IUserPasswordOptionContext) {
	localctx = NewUserPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, MariaDBParserRULE_userPasswordOption)
	var _la int

	p.SetState(5534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 825, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5496)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5497)
			p.Match(MariaDBParserEXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserDEFAULT:
			{
				p.SetState(5498)

				var _m = p.Match(MariaDBParserDEFAULT)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserNEVER:
			{
				p.SetState(5499)

				var _m = p.Match(MariaDBParserNEVER)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserINTERVAL:
			{
				p.SetState(5500)

				var _m = p.Match(MariaDBParserINTERVAL)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5501)
				p.DecimalLiteral()
			}
			{
				p.SetState(5502)
				p.Match(MariaDBParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserATTRIBUTE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserACCOUNT, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserCOMMA, MariaDBParserSEMI:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5506)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5507)
			p.Match(MariaDBParserHISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserDEFAULT:
			{
				p.SetState(5508)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
			{
				p.SetState(5509)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5512)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5513)
			p.Match(MariaDBParserREUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5514)
			p.Match(MariaDBParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserDEFAULT:
			{
				p.SetState(5515)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
			{
				p.SetState(5516)
				p.DecimalLiteral()
			}
			{
				p.SetState(5517)
				p.Match(MariaDBParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5521)
			p.Match(MariaDBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5522)
			p.Match(MariaDBParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5523)
			p.Match(MariaDBParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT || _la == MariaDBParserOPTIONAL {
			{
				p.SetState(5524)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserDEFAULT || _la == MariaDBParserOPTIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5527)
			p.Match(MariaDBParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5528)
			p.DecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5529)
			p.Match(MariaDBParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
			{
				p.SetState(5530)
				p.DecimalLiteral()
			}

		case MariaDBParserUNBOUNDED:
			{
				p.SetState(5531)
				p.Match(MariaDBParserUNBOUNDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserLockOptionContext is an interface to support dynamic dispatch.
type IUserLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode

	// IsUserLockOptionContext differentiates from other interfaces.
	IsUserLockOptionContext()
}

type UserLockOptionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	lockType antlr.Token
}

func NewEmptyUserLockOptionContext() *UserLockOptionContext {
	var p = new(UserLockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userLockOption
	return p
}

func InitEmptyUserLockOptionContext(p *UserLockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userLockOption
}

func (*UserLockOptionContext) IsUserLockOptionContext() {}

func NewUserLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserLockOptionContext {
	var p = new(UserLockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userLockOption

	return p
}

func (s *UserLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserLockOptionContext) GetLockType() antlr.Token { return s.lockType }

func (s *UserLockOptionContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *UserLockOptionContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserACCOUNT, 0)
}

func (s *UserLockOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *UserLockOptionContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNLOCK, 0)
}

func (s *UserLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserLockOption(s)
	}
}

func (s *UserLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserLockOption(s)
	}
}

func (s *UserLockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserLockOption() (localctx IUserLockOptionContext) {
	localctx = NewUserLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, MariaDBParserRULE_userLockOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5536)
		p.Match(MariaDBParserACCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5537)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UserLockOptionContext).lockType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserLOCK || _la == MariaDBParserUNLOCK) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UserLockOptionContext).lockType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivelegeClauseContext is an interface to support dynamic dispatch.
type IPrivelegeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Privilege() IPrivilegeContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsPrivelegeClauseContext differentiates from other interfaces.
	IsPrivelegeClauseContext()
}

type PrivelegeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivelegeClauseContext() *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privelegeClause
	return p
}

func InitEmptyPrivelegeClauseContext(p *PrivelegeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privelegeClause
}

func (*PrivelegeClauseContext) IsPrivelegeClauseContext() {}

func NewPrivelegeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_privelegeClause

	return p
}

func (s *PrivelegeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivelegeClauseContext) Privilege() IPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivelegeClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PrivelegeClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivelegeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivelegeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrivelegeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PrivelegeClause() (localctx IPrivelegeClauseContext) {
	localctx = NewPrivelegeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, MariaDBParserRULE_privelegeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5539)
		p.Privilege()
	}
	p.SetState(5544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserLR_BRACKET {
		{
			p.SetState(5540)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5541)
			p.UidList()
		}
		{
			p.SetState(5542)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	USER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode
	FLUSH_STATUS() antlr.TerminalNode
	FLUSH_TABLES() antlr.TerminalNode
	FLUSH_USER_RESOURCES() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INNODB_REDO_LOG_ENABLE() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	SERVICE_CONNECTION_ADMIN() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	BINLOG_MONITOR() antlr.TerminalNode
	BINLOG_REPLAY() antlr.TerminalNode
	FEDERATED_ADMIN() antlr.TerminalNode
	READ_ONLY_ADMIN() antlr.TerminalNode
	REPLICATION_MASTER_ADMIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	MONITOR() antlr.TerminalNode
	REPLAY() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	READ_ONLY() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	SET() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	S3() antlr.TerminalNode
	INTO() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *PrivilegeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIVILEGES, 0)
}

func (s *PrivilegeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALTER, 0)
}

func (s *PrivilegeContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROUTINE, 0)
}

func (s *PrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *PrivilegeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *PrivilegeContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *PrivilegeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *PrivilegeContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *PrivilegeContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *PrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELETE, 0)
}

func (s *PrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *PrivilegeContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *PrivilegeContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXECUTE, 0)
}

func (s *PrivilegeContext) FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILE, 0)
}

func (s *PrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANT, 0)
}

func (s *PrivilegeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTION, 0)
}

func (s *PrivilegeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT, 0)
}

func (s *PrivilegeContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *PrivilegeContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCESS, 0)
}

func (s *PrivilegeContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROXY, 0)
}

func (s *PrivilegeContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREFERENCES, 0)
}

func (s *PrivilegeContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELOAD, 0)
}

func (s *PrivilegeContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION, 0)
}

func (s *PrivilegeContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLIENT, 0)
}

func (s *PrivilegeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *PrivilegeContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICA, 0)
}

func (s *PrivilegeContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *PrivilegeContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADMIN, 0)
}

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSELECT, 0)
}

func (s *PrivilegeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *PrivilegeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASES, 0)
}

func (s *PrivilegeContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMAS, 0)
}

func (s *PrivilegeContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHUTDOWN, 0)
}

func (s *PrivilegeContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUPER, 0)
}

func (s *PrivilegeContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGER, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *PrivilegeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSAGE, 0)
}

func (s *PrivilegeContext) APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAPPLICATION_PASSWORD_ADMIN, 0)
}

func (s *PrivilegeContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUDIT_ADMIN, 0)
}

func (s *PrivilegeContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBACKUP_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLONE_ADMIN, 0)
}

func (s *PrivilegeContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIREWALL_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIREWALL_USER, 0)
}

func (s *PrivilegeContext) FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH_OPTIMIZER_COSTS, 0)
}

func (s *PrivilegeContext) FLUSH_STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH_STATUS, 0)
}

func (s *PrivilegeContext) FLUSH_TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH_TABLES, 0)
}

func (s *PrivilegeContext) FLUSH_USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH_USER_RESOURCES, 0)
}

func (s *PrivilegeContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ENABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB_REDO_LOG_ENABLE, 0)
}

func (s *PrivilegeContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNDB_STORED_USER, 0)
}

func (s *PrivilegeContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *PrivilegeContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_APPLIER, 0)
}

func (s *PrivilegeContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESOURCE_GROUP_USER, 0)
}

func (s *PrivilegeContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE_ADMIN, 0)
}

func (s *PrivilegeContext) SERVICE_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERVICE_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET_USER_ID, 0)
}

func (s *PrivilegeContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW_ROUTINE, 0)
}

func (s *PrivilegeContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSYSTEM_USER, 0)
}

func (s *PrivilegeContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVERSION_TOKEN_ADMIN, 0)
}

func (s *PrivilegeContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA_RECOVER_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_MONITOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_MONITOR, 0)
}

func (s *PrivilegeContext) BINLOG_REPLAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_REPLAY, 0)
}

func (s *PrivilegeContext) FEDERATED_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFEDERATED_ADMIN, 0)
}

func (s *PrivilegeContext) READ_ONLY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD_ONLY_ADMIN, 0)
}

func (s *PrivilegeContext) REPLICATION_MASTER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_MASTER_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG, 0)
}

func (s *PrivilegeContext) MONITOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMONITOR, 0)
}

func (s *PrivilegeContext) REPLAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLAY, 0)
}

func (s *PrivilegeContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFEDERATED, 0)
}

func (s *PrivilegeContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *PrivilegeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLY, 0)
}

func (s *PrivilegeContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD_ONLY, 0)
}

func (s *PrivilegeContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *PrivilegeContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHISTORY, 0)
}

func (s *PrivilegeContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *PrivilegeContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOAD, 0)
}

func (s *PrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *PrivilegeContext) S3() antlr.TerminalNode {
	return s.GetToken(MariaDBParserS3, 0)
}

func (s *PrivilegeContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *PrivilegeContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKE, 0)
}

func (s *PrivilegeContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAMBDA, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, MariaDBParserRULE_privilege)
	var _la int

	p.SetState(5666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5546)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPRIVILEGES {
			{
				p.SetState(5547)
				p.Match(MariaDBParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5550)
			p.Match(MariaDBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserROUTINE {
			{
				p.SetState(5551)
				p.Match(MariaDBParserROUTINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5554)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MariaDBParserTEMPORARY:
			{
				p.SetState(5555)
				p.Match(MariaDBParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5556)
				p.Match(MariaDBParserTABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserROUTINE:
			{
				p.SetState(5557)
				p.Match(MariaDBParserROUTINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserVIEW:
			{
				p.SetState(5558)
				p.Match(MariaDBParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserUSER:
			{
				p.SetState(5559)
				p.Match(MariaDBParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserTABLESPACE:
			{
				p.SetState(5560)
				p.Match(MariaDBParserTABLESPACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserROLE:
			{
				p.SetState(5561)
				p.Match(MariaDBParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserON, MariaDBParserLR_BRACKET, MariaDBParserCOMMA:

		default:
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5564)
			p.Match(MariaDBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5565)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserROLE {
			{
				p.SetState(5566)
				p.Match(MariaDBParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5569)
			p.Match(MariaDBParserEVENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5570)
			p.Match(MariaDBParserEXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5571)
			p.Match(MariaDBParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5572)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5573)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5574)
			p.Match(MariaDBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5575)
			p.Match(MariaDBParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5576)
			p.Match(MariaDBParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5577)
			p.Match(MariaDBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5578)
			p.Match(MariaDBParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5579)
			p.Match(MariaDBParserPROXY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5580)
			p.Match(MariaDBParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5581)
			p.Match(MariaDBParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5582)
			p.Match(MariaDBParserREPLICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5583)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCLIENT || _la == MariaDBParserMASTER || _la == MariaDBParserSLAVE || _la == MariaDBParserREPLICA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserADMIN {
			{
				p.SetState(5584)
				p.Match(MariaDBParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5587)
			p.Match(MariaDBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5588)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5589)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDATABASES || _la == MariaDBParserSCHEMAS || _la == MariaDBParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5590)
			p.Match(MariaDBParserSHUTDOWN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5591)
			p.Match(MariaDBParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5592)
			p.Match(MariaDBParserTRIGGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5593)
			p.Match(MariaDBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5594)
			p.Match(MariaDBParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5595)
			p.Match(MariaDBParserAPPLICATION_PASSWORD_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5596)
			p.Match(MariaDBParserAUDIT_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5597)
			p.Match(MariaDBParserBACKUP_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5598)
			p.Match(MariaDBParserBINLOG_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5599)
			p.Match(MariaDBParserBINLOG_ENCRYPTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5600)
			p.Match(MariaDBParserCLONE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5601)
			p.Match(MariaDBParserCONNECTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5602)
			p.Match(MariaDBParserENCRYPTION_KEY_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5603)
			p.Match(MariaDBParserFIREWALL_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5604)
			p.Match(MariaDBParserFIREWALL_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5605)
			p.Match(MariaDBParserFLUSH_OPTIMIZER_COSTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5606)
			p.Match(MariaDBParserFLUSH_STATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5607)
			p.Match(MariaDBParserFLUSH_TABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5608)
			p.Match(MariaDBParserFLUSH_USER_RESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5609)
			p.Match(MariaDBParserGROUP_REPLICATION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5610)
			p.Match(MariaDBParserINNODB_REDO_LOG_ARCHIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5611)
			p.Match(MariaDBParserINNODB_REDO_LOG_ENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5612)
			p.Match(MariaDBParserNDB_STORED_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5613)
			p.Match(MariaDBParserPASSWORDLESS_USER_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5614)
			p.Match(MariaDBParserPERSIST_RO_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5615)
			p.Match(MariaDBParserREPLICATION_APPLIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5616)
			p.Match(MariaDBParserREPLICATION_SLAVE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5617)
			p.Match(MariaDBParserRESOURCE_GROUP_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5618)
			p.Match(MariaDBParserRESOURCE_GROUP_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5619)
			p.Match(MariaDBParserROLE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5620)
			p.Match(MariaDBParserSERVICE_CONNECTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5621)
			p.Match(MariaDBParserSESSION_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5622)
			p.Match(MariaDBParserSET_USER_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5623)
			p.Match(MariaDBParserSHOW_ROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5624)
			p.Match(MariaDBParserSYSTEM_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(5625)
			p.Match(MariaDBParserSYSTEM_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(5626)
			p.Match(MariaDBParserTABLE_ENCRYPTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(5627)
			p.Match(MariaDBParserVERSION_TOKEN_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(5628)
			p.Match(MariaDBParserXA_RECOVER_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(5629)
			p.Match(MariaDBParserBINLOG_MONITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(5630)
			p.Match(MariaDBParserBINLOG_REPLAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(5631)
			p.Match(MariaDBParserFEDERATED_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(5632)
			p.Match(MariaDBParserREAD_ONLY_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(5633)
			p.Match(MariaDBParserREPLICATION_MASTER_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(5634)
			p.Match(MariaDBParserBINLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5635)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserADMIN || _la == MariaDBParserMONITOR || _la == MariaDBParserREPLAY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(5636)
			p.Match(MariaDBParserFEDERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5637)
			p.Match(MariaDBParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		p.SetState(5641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserREAD:
			{
				p.SetState(5638)
				p.Match(MariaDBParserREAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5639)
				p.Match(MariaDBParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserREAD_ONLY:
			{
				p.SetState(5640)
				p.Match(MariaDBParserREAD_ONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(5643)
			p.Match(MariaDBParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(5644)
			p.Match(MariaDBParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5645)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(5646)
			p.Match(MariaDBParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5647)
			p.Match(MariaDBParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(5648)
			p.Match(MariaDBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5649)
			p.Match(MariaDBParserHISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(5650)
			p.Match(MariaDBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5651)
			p.Match(MariaDBParserMONITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(5652)
			p.Match(MariaDBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Match(MariaDBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(5654)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5655)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(5656)
			p.Match(MariaDBParserSLAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5657)
			p.Match(MariaDBParserMONITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(5658)
			p.Match(MariaDBParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5659)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5660)
			p.Match(MariaDBParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(5661)
			p.Match(MariaDBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5662)
			p.Match(MariaDBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5663)
			p.Match(MariaDBParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(5664)
			p.Match(MariaDBParserINVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5665)
			p.Match(MariaDBParserLAMBDA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeLevelContext is an interface to support dynamic dispatch.
type IPrivilegeLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrivilegeLevelContext differentiates from other interfaces.
	IsPrivilegeLevelContext()
}

type PrivilegeLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeLevelContext() *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilegeLevel
	return p
}

func InitEmptyPrivilegeLevelContext(p *PrivilegeLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilegeLevel
}

func (*PrivilegeLevelContext) IsPrivilegeLevelContext() {}

func NewPrivilegeLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_privilegeLevel

	return p
}

func (s *PrivilegeLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeLevelContext) CopyAll(ctx *PrivilegeLevelContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrivilegeLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DefiniteSchemaPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteSchemaPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteSchemaPrivLevelContext {
	var p = new(DefiniteSchemaPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteSchemaPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteSchemaPrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteSchemaPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *DefiniteSchemaPrivLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *DefiniteSchemaPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefiniteSchemaPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteFullTablePrivLevel2Context struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevel2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevel2Context {
	var p = new(DefiniteFullTablePrivLevel2Context)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevel2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevel2Context) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevel2Context) DottedId() IDottedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *DefiniteFullTablePrivLevel2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel2(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteFullTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevelContext {
	var p = new(DefiniteFullTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevelContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DefiniteFullTablePrivLevelContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *DefiniteFullTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type GlobalPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewGlobalPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GlobalPrivLevelContext {
	var p = new(GlobalPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *GlobalPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalPrivLevelContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTAR)
}

func (s *GlobalPrivLevelContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, i)
}

func (s *GlobalPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *GlobalPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGlobalPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteTablePrivLevelContext {
	var p = new(DefiniteTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteTablePrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefiniteTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentSchemaPriviLevelContext struct {
	PrivilegeLevelContext
}

func NewCurrentSchemaPriviLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentSchemaPriviLevelContext {
	var p = new(CurrentSchemaPriviLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *CurrentSchemaPriviLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentSchemaPriviLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *CurrentSchemaPriviLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCurrentSchemaPriviLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PrivilegeLevel() (localctx IPrivilegeLevelContext) {
	localctx = NewPrivilegeLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, MariaDBParserRULE_privilegeLevel)
	p.SetState(5684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 834, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentSchemaPriviLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5668)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGlobalPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5669)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5670)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5671)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDefiniteSchemaPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5672)
			p.Uid()
		}
		{
			p.SetState(5673)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5674)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDefiniteFullTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5676)
			p.Uid()
		}
		{
			p.SetState(5677)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5678)
			p.Uid()
		}

	case 5:
		localctx = NewDefiniteFullTablePrivLevel2Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5680)
			p.Uid()
		}
		{
			p.SetState(5681)
			p.DottedId()
		}

	case 6:
		localctx = NewDefiniteTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5683)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserClauseContext is an interface to support dynamic dispatch.
type IRenameUserClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Getter signatures
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext

	// IsRenameUserClauseContext differentiates from other interfaces.
	IsRenameUserClauseContext()
}

type RenameUserClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
}

func NewEmptyRenameUserClauseContext() *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameUserClause
	return p
}

func InitEmptyRenameUserClauseContext(p *RenameUserClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_renameUserClause
}

func (*RenameUserClauseContext) IsRenameUserClauseContext() {}

func NewRenameUserClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_renameUserClause

	return p
}

func (s *RenameUserClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserClauseContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RenameUserClauseContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *RenameUserClauseContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RenameUserClauseContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *RenameUserClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO, 0)
}

func (s *RenameUserClauseContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserClauseContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RenameUserClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRenameUserClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RenameUserClause() (localctx IRenameUserClauseContext) {
	localctx = NewRenameUserClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, MariaDBParserRULE_renameUserClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5686)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).fromFirst = _x
	}
	{
		p.SetState(5687)
		p.Match(MariaDBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5688)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).toFirst = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeTableContext is an interface to support dynamic dispatch.
type IAnalyzeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllHISTOGRAM() []antlr.TerminalNode
	HISTOGRAM(i int) antlr.TerminalNode
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	DROP() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	BUCKETS() antlr.TerminalNode

	// IsAnalyzeTableContext differentiates from other interfaces.
	IsAnalyzeTableContext()
}

type AnalyzeTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyAnalyzeTableContext() *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_analyzeTable
	return p
}

func InitEmptyAnalyzeTableContext(p *AnalyzeTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_analyzeTable
}

func (*AnalyzeTableContext) IsAnalyzeTableContext() {}

func NewAnalyzeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_analyzeTable

	return p
}

func (s *AnalyzeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *AnalyzeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserANALYZE, 0)
}

func (s *AnalyzeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *AnalyzeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *AnalyzeTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *AnalyzeTableContext) AllHISTOGRAM() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserHISTOGRAM)
}

func (s *AnalyzeTableContext) HISTOGRAM(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserHISTOGRAM, i)
}

func (s *AnalyzeTableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserON)
}

func (s *AnalyzeTableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, i)
}

func (s *AnalyzeTableContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *AnalyzeTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDROP, 0)
}

func (s *AnalyzeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO_WRITE_TO_BINLOG, 0)
}

func (s *AnalyzeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *AnalyzeTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AnalyzeTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AnalyzeTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *AnalyzeTableContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AnalyzeTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBUCKETS, 0)
}

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAnalyzeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AnalyzeTable() (localctx IAnalyzeTableContext) {
	localctx = NewAnalyzeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, MariaDBParserRULE_analyzeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5690)
		p.Match(MariaDBParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL {
		{
			p.SetState(5691)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AnalyzeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AnalyzeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5694)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserTABLE || _la == MariaDBParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5695)
		p.Tables()
	}
	p.SetState(5713)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5696)
			p.Match(MariaDBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5697)
			p.Match(MariaDBParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5698)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5699)
			p.FullColumnName()
		}
		p.SetState(5704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5700)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5701)
				p.FullColumnName()
			}

			p.SetState(5706)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWITH {
			{
				p.SetState(5707)
				p.Match(MariaDBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5708)
				p.DecimalLiteral()
			}
			{
				p.SetState(5709)
				p.Match(MariaDBParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5726)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5715)
			p.Match(MariaDBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5716)
			p.Match(MariaDBParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5717)
			p.Match(MariaDBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5718)
			p.FullColumnName()
		}
		p.SetState(5723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5719)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5720)
				p.FullColumnName()
			}

			p.SetState(5725)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckTableContext is an interface to support dynamic dispatch.
type ICheckTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	AllCheckTableOption() []ICheckTableOptionContext
	CheckTableOption(i int) ICheckTableOptionContext

	// IsCheckTableContext differentiates from other interfaces.
	IsCheckTableContext()
}

type CheckTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableContext() *CheckTableContext {
	var p = new(CheckTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checkTable
	return p
}

func InitEmptyCheckTableContext(p *CheckTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checkTable
}

func (*CheckTableContext) IsCheckTableContext() {}

func NewCheckTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableContext {
	var p = new(CheckTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_checkTable

	return p
}

func (s *CheckTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECK, 0)
}

func (s *CheckTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *CheckTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *CheckTableContext) AllCheckTableOption() []ICheckTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckTableOptionContext); ok {
			tst[i] = t.(ICheckTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CheckTableContext) CheckTableOption(i int) ICheckTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableOptionContext)
}

func (s *CheckTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCheckTable(s)
	}
}

func (s *CheckTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCheckTable(s)
	}
}

func (s *CheckTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCheckTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CheckTable() (localctx ICheckTableContext) {
	localctx = NewCheckTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, MariaDBParserRULE_checkTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5728)
		p.Match(MariaDBParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5729)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5730)
		p.Tables()
	}
	p.SetState(5734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserFOR || _la == MariaDBParserCHANGED || _la == MariaDBParserEXTENDED || _la == MariaDBParserFAST || _la == MariaDBParserMEDIUM || _la == MariaDBParserQUICK {
		{
			p.SetState(5731)
			p.CheckTableOption()
		}

		p.SetState(5736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChecksumTableContext is an interface to support dynamic dispatch.
type IChecksumTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	CHECKSUM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode

	// IsChecksumTableContext differentiates from other interfaces.
	IsChecksumTableContext()
}

type ChecksumTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyChecksumTableContext() *ChecksumTableContext {
	var p = new(ChecksumTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checksumTable
	return p
}

func InitEmptyChecksumTableContext(p *ChecksumTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checksumTable
}

func (*ChecksumTableContext) IsChecksumTableContext() {}

func NewChecksumTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChecksumTableContext {
	var p = new(ChecksumTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_checksumTable

	return p
}

func (s *ChecksumTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ChecksumTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *ChecksumTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *ChecksumTableContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECKSUM, 0)
}

func (s *ChecksumTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *ChecksumTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *ChecksumTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *ChecksumTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENDED, 0)
}

func (s *ChecksumTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChecksumTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChecksumTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterChecksumTable(s)
	}
}

func (s *ChecksumTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitChecksumTable(s)
	}
}

func (s *ChecksumTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitChecksumTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ChecksumTable() (localctx IChecksumTableContext) {
	localctx = NewChecksumTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, MariaDBParserRULE_checksumTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5737)
		p.Match(MariaDBParserCHECKSUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5738)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5739)
		p.Tables()
	}
	p.SetState(5741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEXTENDED || _la == MariaDBParserQUICK {
		{
			p.SetState(5740)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ChecksumTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserEXTENDED || _la == MariaDBParserQUICK) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ChecksumTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeTableContext is an interface to support dynamic dispatch.
type IOptimizeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsOptimizeTableContext differentiates from other interfaces.
	IsOptimizeTableContext()
}

type OptimizeTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyOptimizeTableContext() *OptimizeTableContext {
	var p = new(OptimizeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_optimizeTable
	return p
}

func InitEmptyOptimizeTableContext(p *OptimizeTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_optimizeTable
}

func (*OptimizeTableContext) IsOptimizeTableContext() {}

func NewOptimizeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeTableContext {
	var p = new(OptimizeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_optimizeTable

	return p
}

func (s *OptimizeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *OptimizeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *OptimizeTableContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIMIZE, 0)
}

func (s *OptimizeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *OptimizeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *OptimizeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *OptimizeTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *OptimizeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO_WRITE_TO_BINLOG, 0)
}

func (s *OptimizeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *OptimizeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOptimizeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OptimizeTable() (localctx IOptimizeTableContext) {
	localctx = NewOptimizeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, MariaDBParserRULE_optimizeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5743)
		p.Match(MariaDBParserOPTIMIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL {
		{
			p.SetState(5744)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OptimizeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OptimizeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5747)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserTABLE || _la == MariaDBParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5748)
		p.Tables()
	}
	p.SetState(5750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOWAIT || _la == MariaDBParserWAIT {
		{
			p.SetState(5749)
			p.WaitNowaitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepairTableContext is an interface to support dynamic dispatch.
type IRepairTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsRepairTableContext differentiates from other interfaces.
	IsRepairTableContext()
}

type RepairTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyRepairTableContext() *RepairTableContext {
	var p = new(RepairTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_repairTable
	return p
}

func InitEmptyRepairTableContext(p *RepairTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_repairTable
}

func (*RepairTableContext) IsRepairTableContext() {}

func NewRepairTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTableContext {
	var p = new(RepairTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_repairTable

	return p
}

func (s *RepairTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *RepairTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *RepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPAIR, 0)
}

func (s *RepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *RepairTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *RepairTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *RepairTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENDED, 0)
}

func (s *RepairTableContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSE_FRM, 0)
}

func (s *RepairTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO_WRITE_TO_BINLOG, 0)
}

func (s *RepairTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *RepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRepairTable(s)
	}
}

func (s *RepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRepairTable(s)
	}
}

func (s *RepairTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRepairTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RepairTable() (localctx IRepairTableContext) {
	localctx = NewRepairTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, MariaDBParserRULE_repairTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Match(MariaDBParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL {
		{
			p.SetState(5753)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RepairTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RepairTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5756)
		p.Match(MariaDBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5757)
		p.Tables()
	}
	p.SetState(5759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserQUICK {
		{
			p.SetState(5758)
			p.Match(MariaDBParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEXTENDED {
		{
			p.SetState(5761)
			p.Match(MariaDBParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserUSE_FRM {
		{
			p.SetState(5764)
			p.Match(MariaDBParserUSE_FRM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckTableOptionContext is an interface to support dynamic dispatch.
type ICheckTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	FAST() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	CHANGED() antlr.TerminalNode

	// IsCheckTableOptionContext differentiates from other interfaces.
	IsCheckTableOptionContext()
}

type CheckTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableOptionContext() *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checkTableOption
	return p
}

func InitEmptyCheckTableOptionContext(p *CheckTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_checkTableOption
}

func (*CheckTableOptionContext) IsCheckTableOptionContext() {}

func NewCheckTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_checkTableOption

	return p
}

func (s *CheckTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *CheckTableOptionContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPGRADE, 0)
}

func (s *CheckTableOptionContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *CheckTableOptionContext) FAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAST, 0)
}

func (s *CheckTableOptionContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEDIUM, 0)
}

func (s *CheckTableOptionContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENDED, 0)
}

func (s *CheckTableOptionContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANGED, 0)
}

func (s *CheckTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCheckTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CheckTableOption() (localctx ICheckTableOptionContext) {
	localctx = NewCheckTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, MariaDBParserRULE_checkTableOption)
	p.SetState(5774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5767)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5768)
			p.Match(MariaDBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserQUICK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5769)
			p.Match(MariaDBParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFAST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5770)
			p.Match(MariaDBParserFAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMEDIUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5771)
			p.Match(MariaDBParserMEDIUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserEXTENDED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5772)
			p.Match(MariaDBParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCHANGED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5773)
			p.Match(MariaDBParserCHANGED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUdfunctionContext is an interface to support dynamic dispatch.
type ICreateUdfunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnType returns the returnType token.
	GetReturnType() antlr.Token

	// SetReturnType sets the returnType token.
	SetReturnType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	Uid() IUidContext
	RETURNS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext

	// IsCreateUdfunctionContext differentiates from other interfaces.
	IsCreateUdfunctionContext()
}

type CreateUdfunctionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	returnType antlr.Token
}

func NewEmptyCreateUdfunctionContext() *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createUdfunction
	return p
}

func InitEmptyCreateUdfunctionContext(p *CreateUdfunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_createUdfunction
}

func (*CreateUdfunctionContext) IsCreateUdfunctionContext() {}

func NewCreateUdfunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_createUdfunction

	return p
}

func (s *CreateUdfunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUdfunctionContext) GetReturnType() antlr.Token { return s.returnType }

func (s *CreateUdfunctionContext) SetReturnType(v antlr.Token) { s.returnType = v }

func (s *CreateUdfunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *CreateUdfunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *CreateUdfunctionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateUdfunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNS, 0)
}

func (s *CreateUdfunctionContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSONAME, 0)
}

func (s *CreateUdfunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CreateUdfunctionContext) STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING, 0)
}

func (s *CreateUdfunctionContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTEGER, 0)
}

func (s *CreateUdfunctionContext) REAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAL, 0)
}

func (s *CreateUdfunctionContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECIMAL, 0)
}

func (s *CreateUdfunctionContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateUdfunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAGGREGATE, 0)
}

func (s *CreateUdfunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUdfunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUdfunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUdfunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCreateUdfunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CreateUdfunction() (localctx ICreateUdfunctionContext) {
	localctx = NewCreateUdfunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, MariaDBParserRULE_createUdfunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5776)
		p.Match(MariaDBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserOR {
		{
			p.SetState(5777)
			p.OrReplace()
		}

	}
	p.SetState(5781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserAGGREGATE {
		{
			p.SetState(5780)
			p.Match(MariaDBParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5783)
		p.Match(MariaDBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5785)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 852, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5784)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5787)
		p.Uid()
	}
	{
		p.SetState(5788)
		p.Match(MariaDBParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5789)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateUdfunctionContext).returnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&261) != 0) || _la == MariaDBParserSTRING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateUdfunctionContext).returnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5790)
		p.Match(MariaDBParserSONAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5791)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginContext is an interface to support dynamic dispatch.
type IInstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsInstallPluginContext differentiates from other interfaces.
	IsInstallPluginContext()
}

type InstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginContext() *InstallPluginContext {
	var p = new(InstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_installPlugin
	return p
}

func InitEmptyInstallPluginContext(p *InstallPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_installPlugin
}

func (*InstallPluginContext) IsInstallPluginContext() {}

func NewInstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginContext {
	var p = new(InstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_installPlugin

	return p
}

func (s *InstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGIN, 0)
}

func (s *InstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InstallPluginContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSONAME, 0)
}

func (s *InstallPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

func (s *InstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) InstallPlugin() (localctx IInstallPluginContext) {
	localctx = NewInstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, MariaDBParserRULE_installPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5793)
		p.Match(MariaDBParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5794)
		p.Match(MariaDBParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5795)
		p.Uid()
	}
	{
		p.SetState(5796)
		p.Match(MariaDBParserSONAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5797)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginContext is an interface to support dynamic dispatch.
type IUninstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext

	// IsUninstallPluginContext differentiates from other interfaces.
	IsUninstallPluginContext()
}

type UninstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginContext() *UninstallPluginContext {
	var p = new(UninstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uninstallPlugin
	return p
}

func InitEmptyUninstallPluginContext(p *UninstallPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uninstallPlugin
}

func (*UninstallPluginContext) IsUninstallPluginContext() {}

func NewUninstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_uninstallPlugin

	return p
}

func (s *UninstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGIN, 0)
}

func (s *UninstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUninstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UninstallPlugin() (localctx IUninstallPluginContext) {
	localctx = NewUninstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, MariaDBParserRULE_uninstallPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5799)
		p.Match(MariaDBParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5800)
		p.Match(MariaDBParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5801)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) CopyAll(ctx *SetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SetTransactionStatement() ISetTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTransactionStatementContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetCharsetContext struct {
	SetStatementContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *SetCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

func (s *SetCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNamesContext struct {
	SetStatementContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNAMES, 0)
}

func (s *SetNamesContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetNamesContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *SetNamesContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	SetStatementContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) SetPasswordStatement() ISetPasswordStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordStatementContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetAutocommitContext struct {
	SetStatementContext
}

func NewSetAutocommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAutocommitContext {
	var p = new(SetAutocommitContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetAutocommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitContext) SetAutocommitStatement() ISetAutocommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAutocommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAutocommitStatementContext)
}

func (s *SetAutocommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetAutocommit(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNewValueInsideTriggerContext struct {
	SetStatementContext
}

func NewSetNewValueInsideTriggerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNewValueInsideTriggerContext {
	var p = new(SetNewValueInsideTriggerContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNewValueInsideTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNewValueInsideTriggerContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetNewValueInsideTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SetNewValueInsideTriggerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNewValueInsideTriggerContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *SetNewValueInsideTriggerContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *SetNewValueInsideTriggerContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserVAR_ASSIGN)
}

func (s *SetNewValueInsideTriggerContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_ASSIGN, i)
}

func (s *SetNewValueInsideTriggerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SetNewValueInsideTriggerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SetNewValueInsideTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetNewValueInsideTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetVariableContext struct {
	SetStatementContext
}

func NewSetVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableContext {
	var p = new(SetVariableContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SetVariableContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *SetVariableContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *SetVariableContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *SetVariableContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserVAR_ASSIGN)
}

func (s *SetVariableContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_ASSIGN, i)
}

func (s *SetVariableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserON)
}

func (s *SetVariableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, i)
}

func (s *SetVariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SetVariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

func (s *SetVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSetVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, MariaDBParserRULE_setStatement)
	var _la int

	p.SetState(5855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 860, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5803)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5804)
			p.VariableClause()
		}
		{
			p.SetState(5805)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserVAR_ASSIGN || _la == MariaDBParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 853, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5806)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(5807)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5810)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5811)
				p.VariableClause()
			}
			{
				p.SetState(5812)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserVAR_ASSIGN || _la == MariaDBParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5815)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 854, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5813)
					p.expression(0)
				}

			case 2:
				{
					p.SetState(5814)
					p.Match(MariaDBParserON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5821)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5822)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5823)
			p.CharSet()
		}
		p.SetState(5826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserBINARY, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL:
			{
				p.SetState(5824)
				p.CharsetName()
			}

		case MariaDBParserDEFAULT:
			{
				p.SetState(5825)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5828)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5829)
			p.Match(MariaDBParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserBINARY, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL:
			{
				p.SetState(5830)
				p.CharsetName()
			}
			p.SetState(5833)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserCOLLATE {
				{
					p.SetState(5831)
					p.Match(MariaDBParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5832)
					p.CollationName()
				}

			}

		case MariaDBParserDEFAULT:
			{
				p.SetState(5835)
				p.Match(MariaDBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5838)
			p.SetPasswordStatement()
		}

	case 5:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5839)
			p.SetTransactionStatement()
		}

	case 6:
		localctx = NewSetAutocommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5840)
			p.SetAutocommitStatement()
		}

	case 7:
		localctx = NewSetNewValueInsideTriggerContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5841)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5842)
			p.FullId()
		}
		{
			p.SetState(5843)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserVAR_ASSIGN || _la == MariaDBParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5844)
			p.expression(0)
		}
		p.SetState(5852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(5845)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5846)
				p.FullId()
			}
			{
				p.SetState(5847)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserVAR_ASSIGN || _la == MariaDBParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5848)
				p.expression(0)
			}

			p.SetState(5854)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) CopyAll(ctx *ShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowOpenTablesContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowOpenTablesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *ShowOpenTablesContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowOpenTablesContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowOpenTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowExplainContext struct {
	ShowStatementContext
}

func NewShowExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowExplainContext {
	var p = new(ShowExplainContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExplainContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPLAIN, 0)
}

func (s *ShowExplainContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ShowExplainContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowExplainContext) FormatJsonStatement() IFormatJsonStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatJsonStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatJsonStatementContext)
}

func (s *ShowExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowExplain(s)
	}
}

func (s *ShowExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowExplain(s)
	}
}

func (s *ShowExplainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowExplain(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGlobalInfoContext struct {
	ShowStatementContext
}

func NewShowGlobalInfoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalInfoContext {
	var p = new(ShowGlobalInfoContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGlobalInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowGlobalInfoContext) ShowGlobalInfoClause() IShowGlobalInfoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGlobalInfoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGlobalInfoClauseContext)
}

func (s *ShowGlobalInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowGlobalInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateFullIdObjectContext struct {
	ShowStatementContext
	namedEntity antlr.Token
}

func NewShowCreateFullIdObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFullIdObjectContext {
	var p = new(ShowCreateFullIdObjectContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateFullIdObjectContext) GetNamedEntity() antlr.Token { return s.namedEntity }

func (s *ShowCreateFullIdObjectContext) SetNamedEntity(v antlr.Token) { s.namedEntity = v }

func (s *ShowCreateFullIdObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFullIdObjectContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowCreateFullIdObjectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *ShowCreateFullIdObjectContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowCreateFullIdObjectContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *ShowCreateFullIdObjectContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *ShowCreateFullIdObjectContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *ShowCreateFullIdObjectContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEQUENCE, 0)
}

func (s *ShowCreateFullIdObjectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *ShowCreateFullIdObjectContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGER, 0)
}

func (s *ShowCreateFullIdObjectContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *ShowCreateFullIdObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCreateFullIdObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateUserContext struct {
	ShowStatementContext
}

func NewShowCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserContext {
	var p = new(ShowCreateUserContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowCreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *ShowCreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *ShowCreateUserContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowCreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
}

func NewShowErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowErrorsContext {
	var p = new(ShowErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERRORS, 0)
}

func (s *ShowErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWARNINGS, 0)
}

func (s *ShowErrorsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowErrors(s)
	}
}

func (s *ShowErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowErrors(s)
	}
}

func (s *ShowErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowErrors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowUserstatPluginContext struct {
	ShowStatementContext
}

func NewShowUserstatPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowUserstatPluginContext {
	var p = new(ShowUserstatPluginContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowUserstatPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserstatPluginContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowUserstatPluginContext) USER_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER_STATISTICS, 0)
}

func (s *ShowUserstatPluginContext) CLIENT_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLIENT_STATISTICS, 0)
}

func (s *ShowUserstatPluginContext) INDEX_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX_STATISTICS, 0)
}

func (s *ShowUserstatPluginContext) TABLE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_STATISTICS, 0)
}

func (s *ShowUserstatPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowUserstatPlugin(s)
	}
}

func (s *ShowUserstatPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowUserstatPlugin(s)
	}
}

func (s *ShowUserstatPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowUserstatPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCountErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
}

func NewShowCountErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCountErrorsContext {
	var p = new(ShowCountErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCountErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowCountErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowCountErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCountErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowCountErrorsContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOUNT, 0)
}

func (s *ShowCountErrorsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *ShowCountErrorsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERRORS, 0)
}

func (s *ShowCountErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWARNINGS, 0)
}

func (s *ShowCountErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCountErrors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowObjectFilterContext struct {
	ShowStatementContext
}

func NewShowObjectFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowObjectFilterContext {
	var p = new(ShowObjectFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowObjectFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowObjectFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowObjectFilterContext) ShowCommonEntity() IShowCommonEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommonEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommonEntityContext)
}

func (s *ShowObjectFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowObjectFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowObjectFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateDbContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowCreateDbContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDbContext {
	var p = new(ShowCreateDbContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateDbContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowCreateDbContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowCreateDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowCreateDbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *ShowCreateDbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowCreateDbContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *ShowCreateDbContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *ShowCreateDbContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ShowCreateDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCreateDb(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowEngineContext struct {
	ShowStatementContext
	engineOption antlr.Token
}

func NewShowEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEngineContext {
	var p = new(ShowEngineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowEngineContext) GetEngineOption() antlr.Token { return s.engineOption }

func (s *ShowEngineContext) SetEngineOption(v antlr.Token) { s.engineOption = v }

func (s *ShowEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEngineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *ShowEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *ShowEngineContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowEngineContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMUTEX, 0)
}

func (s *ShowEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowEngine(s)
	}
}

func (s *ShowEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowEngine(s)
	}
}

func (s *ShowEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSchemaFilterContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowSchemaFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemaFilterContext {
	var p = new(ShowSchemaFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSchemaFilterContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowSchemaFilterContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowSchemaFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowSchemaFilterContext) ShowSchemaEntity() IShowSchemaEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSchemaEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSchemaEntityContext)
}

func (s *ShowSchemaFilterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowSchemaFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowSchemaFilterContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ShowSchemaFilterContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *ShowSchemaFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowSchemaFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowInnoDBStatusContext struct {
	ShowStatementContext
}

func NewShowInnoDBStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowInnoDBStatusContext {
	var p = new(ShowInnoDBStatusContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowInnoDBStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowInnoDBStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowInnoDBStatusContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB, 0)
}

func (s *ShowInnoDBStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowInnoDBStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowInnoDBStatus(s)
	}
}

func (s *ShowInnoDBStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowInnoDBStatus(s)
	}
}

func (s *ShowInnoDBStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowInnoDBStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexesContext struct {
	ShowStatementContext
	indexFormat  antlr.Token
	tableFormat  antlr.Token
	schemaFormat antlr.Token
}

func NewShowIndexesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexesContext {
	var p = new(ShowIndexesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *ShowIndexesContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowIndexesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *ShowIndexesContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowIndexesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *ShowIndexesContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEXES, 0)
}

func (s *ShowIndexesContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEYS, 0)
}

func (s *ShowIndexesContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserFROM)
}

func (s *ShowIndexesContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, i)
}

func (s *ShowIndexesContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserIN)
}

func (s *ShowIndexesContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, i)
}

func (s *ShowIndexesContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowIndexesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *ShowIndexesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowIndexes(s)
	}
}

func (s *ShowIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowIndexes(s)
	}
}

func (s *ShowIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowBinLogEventsContext struct {
	ShowStatementContext
	filename     antlr.Token
	fromPosition IDecimalLiteralContext
}

func NewShowBinLogEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBinLogEventsContext {
	var p = new(ShowBinLogEventsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowBinLogEventsContext) GetFilename() antlr.Token { return s.filename }

func (s *ShowBinLogEventsContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *ShowBinLogEventsContext) GetFromPosition() IDecimalLiteralContext { return s.fromPosition }

func (s *ShowBinLogEventsContext) SetFromPosition(v IDecimalLiteralContext) { s.fromPosition = v }

func (s *ShowBinLogEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBinLogEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowBinLogEventsContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG, 0)
}

func (s *ShowBinLogEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENTS, 0)
}

func (s *ShowBinLogEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *ShowBinLogEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ShowBinLogEventsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowBinLogEventsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ShowBinLogEventsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowBinLogEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowBinLogEvents(s)
	}
}

func (s *ShowBinLogEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowBinLogEvents(s)
	}
}

func (s *ShowBinLogEventsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowBinLogEvents(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreatePackageContext struct {
	ShowStatementContext
}

func NewShowCreatePackageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreatePackageContext {
	var p = new(ShowCreatePackageContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreatePackageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreatePackageContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowCreatePackageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE, 0)
}

func (s *ShowCreatePackageContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPACKAGE, 0)
}

func (s *ShowCreatePackageContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowCreatePackageContext) BODY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBODY, 0)
}

func (s *ShowCreatePackageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCreatePackage(s)
	}
}

func (s *ShowCreatePackageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCreatePackage(s)
	}
}

func (s *ShowCreatePackageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCreatePackage(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowMasterLogsContext struct {
	ShowStatementContext
	logFormat antlr.Token
}

func NewShowMasterLogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMasterLogsContext {
	var p = new(ShowMasterLogsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowMasterLogsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowMasterLogsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowMasterLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMasterLogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowMasterLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGS, 0)
}

func (s *ShowMasterLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *ShowMasterLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *ShowMasterLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowMasterLogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsContext struct {
	ShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANTS, 0)
}

func (s *ShowGrantsContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ShowGrantsContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowPackageStatusContext struct {
	ShowStatementContext
}

func NewShowPackageStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPackageStatusContext {
	var p = new(ShowPackageStatusContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowPackageStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPackageStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowPackageStatusContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPACKAGE, 0)
}

func (s *ShowPackageStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowPackageStatusContext) BODY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBODY, 0)
}

func (s *ShowPackageStatusContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowPackageStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowPackageStatus(s)
	}
}

func (s *ShowPackageStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowPackageStatus(s)
	}
}

func (s *ShowPackageStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowPackageStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSlaveStatusContext struct {
	ShowStatementContext
	connectionName antlr.Token
	channelName    antlr.Token
}

func NewShowSlaveStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSlaveStatusContext {
	var p = new(ShowSlaveStatusContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSlaveStatusContext) GetConnectionName() antlr.Token { return s.connectionName }

func (s *ShowSlaveStatusContext) GetChannelName() antlr.Token { return s.channelName }

func (s *ShowSlaveStatusContext) SetConnectionName(v antlr.Token) { s.connectionName = v }

func (s *ShowSlaveStatusContext) SetChannelName(v antlr.Token) { s.channelName = v }

func (s *ShowSlaveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSlaveStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowSlaveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowSlaveStatusContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *ShowSlaveStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICA, 0)
}

func (s *ShowSlaveStatusContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ShowSlaveStatusContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANNEL, 0)
}

func (s *ShowSlaveStatusContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *ShowSlaveStatusContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *ShowSlaveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowSlaveStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRoutineContext struct {
	ShowStatementContext
	routine antlr.Token
}

func NewShowRoutineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineContext {
	var p = new(ShowRoutineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowRoutineContext) GetRoutine() antlr.Token { return s.routine }

func (s *ShowRoutineContext) SetRoutine(v antlr.Token) { s.routine = v }

func (s *ShowRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowRoutineContext) CODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCODE, 0)
}

func (s *ShowRoutineContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowRoutineContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *ShowRoutineContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *ShowRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowRoutine(s)
	}
}

func (s *ShowRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowRoutine(s)
	}
}

func (s *ShowRoutineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowRoutine(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowProfileContext struct {
	ShowStatementContext
	queryCount IDecimalLiteralContext
}

func NewShowProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProfileContext {
	var p = new(ShowProfileContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowProfileContext) GetQueryCount() IDecimalLiteralContext { return s.queryCount }

func (s *ShowProfileContext) SetQueryCount(v IDecimalLiteralContext) { s.queryCount = v }

func (s *ShowProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROFILE, 0)
}

func (s *ShowProfileContext) AllShowProfileType() []IShowProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IShowProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShowProfileTypeContext); ok {
			tst[i] = t.(IShowProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) ShowProfileType(i int) IShowProfileTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfileTypeContext)
}

func (s *ShowProfileContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ShowProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY, 0)
}

func (s *ShowProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowProfileContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowProfileContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ShowProfileContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ShowProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowProfile(s)
	}
}

func (s *ShowProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowProfile(s)
	}
}

func (s *ShowProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	ShowStatementContext
	columnsFormat antlr.Token
	tableFormat   antlr.Token
	schemaFormat  antlr.Token
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetColumnsFormat() antlr.Token { return s.columnsFormat }

func (s *ShowColumnsContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowColumnsContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowColumnsContext) SetColumnsFormat(v antlr.Token) { s.columnsFormat = v }

func (s *ShowColumnsContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowColumnsContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowColumnsContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, i)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULL, 0)
}

func (s *ShowColumnsContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowColumnsContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRelayLogEventsContext struct {
	ShowStatementContext
	connectionName antlr.Token
	filename       antlr.Token
	fromPosition   IDecimalLiteralContext
	channelName    antlr.Token
}

func NewShowRelayLogEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRelayLogEventsContext {
	var p = new(ShowRelayLogEventsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowRelayLogEventsContext) GetConnectionName() antlr.Token { return s.connectionName }

func (s *ShowRelayLogEventsContext) GetFilename() antlr.Token { return s.filename }

func (s *ShowRelayLogEventsContext) GetChannelName() antlr.Token { return s.channelName }

func (s *ShowRelayLogEventsContext) SetConnectionName(v antlr.Token) { s.connectionName = v }

func (s *ShowRelayLogEventsContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *ShowRelayLogEventsContext) SetChannelName(v antlr.Token) { s.channelName = v }

func (s *ShowRelayLogEventsContext) GetFromPosition() IDecimalLiteralContext { return s.fromPosition }

func (s *ShowRelayLogEventsContext) SetFromPosition(v IDecimalLiteralContext) { s.fromPosition = v }

func (s *ShowRelayLogEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRelayLogEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW, 0)
}

func (s *ShowRelayLogEventsContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAYLOG, 0)
}

func (s *ShowRelayLogEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENTS, 0)
}

func (s *ShowRelayLogEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *ShowRelayLogEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ShowRelayLogEventsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowRelayLogEventsContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ShowRelayLogEventsContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANNEL, 0)
}

func (s *ShowRelayLogEventsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *ShowRelayLogEventsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *ShowRelayLogEventsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowRelayLogEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowRelayLogEvents(s)
	}
}

func (s *ShowRelayLogEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowRelayLogEvents(s)
	}
}

func (s *ShowRelayLogEventsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowRelayLogEvents(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, MariaDBParserRULE_showStatement)
	var _la int

	p.SetState(6048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 892, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowMasterLogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5857)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5858)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowMasterLogsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserBINARY || _la == MariaDBParserMASTER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowMasterLogsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5859)
			p.Match(MariaDBParserLOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowBinLogEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5860)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5861)
			p.Match(MariaDBParserBINLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5862)
			p.Match(MariaDBParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIN {
			{
				p.SetState(5863)
				p.Match(MariaDBParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5864)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowBinLogEventsContext).filename = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(5869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM {
			{
				p.SetState(5867)
				p.Match(MariaDBParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5868)

				var _x = p.DecimalLiteral()

				localctx.(*ShowBinLogEventsContext).fromPosition = _x
			}

		}
		p.SetState(5872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(5871)
				p.LimitClause()
			}

		}

	case 3:
		localctx = NewShowRelayLogEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5874)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5875)
			p.Match(MariaDBParserRELAYLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTRING_LITERAL {
			{
				p.SetState(5876)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowRelayLogEventsContext).connectionName = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5879)
			p.Match(MariaDBParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserIN {
			{
				p.SetState(5880)
				p.Match(MariaDBParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5881)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowRelayLogEventsContext).filename = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(5886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM {
			{
				p.SetState(5884)
				p.Match(MariaDBParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5885)

				var _x = p.DecimalLiteral()

				localctx.(*ShowRelayLogEventsContext).fromPosition = _x
			}

		}
		p.SetState(5889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(5888)
				p.LimitClause()
			}

		}
		p.SetState(5894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(5891)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5892)
				p.Match(MariaDBParserCHANNEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5893)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowRelayLogEventsContext).channelName = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewShowObjectFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5896)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5897)
			p.ShowCommonEntity()
		}
		p.SetState(5899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIKE || _la == MariaDBParserWHERE {
			{
				p.SetState(5898)
				p.ShowFilter()
			}

		}

	case 5:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5901)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFULL {
			{
				p.SetState(5902)
				p.Match(MariaDBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5905)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).columnsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCOLUMNS || _la == MariaDBParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).columnsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5906)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5907)
			p.TableName()
		}
		p.SetState(5910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM || _la == MariaDBParserIN {
			{
				p.SetState(5908)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowColumnsContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowColumnsContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5909)
				p.Uid()
			}

		}
		p.SetState(5913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIKE || _la == MariaDBParserWHERE {
			{
				p.SetState(5912)
				p.ShowFilter()
			}

		}

	case 6:
		localctx = NewShowCreateDbContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5915)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5916)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5917)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateDbContext).schemaFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserDATABASE || _la == MariaDBParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateDbContext).schemaFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5919)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 873, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5918)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5921)
			p.Uid()
		}

	case 7:
		localctx = NewShowCreateFullIdObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5922)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5923)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5924)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateFullIdObjectContext).namedEntity = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&36283883716609) != 0) || _la == MariaDBParserEVENT || _la == MariaDBParserFUNCTION || _la == MariaDBParserSEQUENCE || _la == MariaDBParserVIEW) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateFullIdObjectContext).namedEntity = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5925)
			p.FullId()
		}

	case 8:
		localctx = NewShowCreatePackageContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5926)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5927)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5928)
			p.Match(MariaDBParserPACKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5930)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 874, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5929)
				p.Match(MariaDBParserBODY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5932)
			p.FullId()
		}

	case 9:
		localctx = NewShowCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5933)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5934)
			p.Match(MariaDBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5935)
			p.Match(MariaDBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5936)
			p.UserName()
		}

	case 10:
		localctx = NewShowEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5937)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5938)
			p.Match(MariaDBParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5939)
			p.EngineName()
		}
		{
			p.SetState(5940)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowEngineContext).engineOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserMUTEX || _la == MariaDBParserSTATUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowEngineContext).engineOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewShowInnoDBStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5942)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5943)
			p.Match(MariaDBParserINNODB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5944)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowGlobalInfoContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5945)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5946)
			p.ShowGlobalInfoClause()
		}

	case 13:
		localctx = NewShowErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5947)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5948)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserERRORS || _la == MariaDBParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(5949)
				p.LimitClause()
			}

		}

	case 14:
		localctx = NewShowCountErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5952)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5953)
			p.Match(MariaDBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5954)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5955)
			p.Match(MariaDBParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5956)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5957)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCountErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserERRORS || _la == MariaDBParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCountErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 15:
		localctx = NewShowSchemaFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5958)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5959)
			p.ShowSchemaEntity()
		}
		p.SetState(5962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM || _la == MariaDBParserIN {
			{
				p.SetState(5960)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowSchemaFilterContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowSchemaFilterContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5961)
				p.Uid()
			}

		}
		p.SetState(5965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIKE || _la == MariaDBParserWHERE {
			{
				p.SetState(5964)
				p.ShowFilter()
			}

		}

	case 16:
		localctx = NewShowRoutineContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5967)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5968)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowRoutineContext).routine = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserPROCEDURE || _la == MariaDBParserFUNCTION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowRoutineContext).routine = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5969)
			p.Match(MariaDBParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5970)
			p.FullId()
		}

	case 17:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5971)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5972)
			p.Match(MariaDBParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(5973)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5974)
				p.UserName()
			}

		}

	case 18:
		localctx = NewShowIndexesContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5977)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5978)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEYS || _la == MariaDBParserINDEXES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5979)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5980)
			p.TableName()
		}
		p.SetState(5983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM || _la == MariaDBParserIN {
			{
				p.SetState(5981)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowIndexesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowIndexesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5982)
				p.Uid()
			}

		}
		p.SetState(5987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserWHERE {
			{
				p.SetState(5985)
				p.Match(MariaDBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5986)
				p.expression(0)
			}

		}

	case 19:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5989)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5990)
			p.Match(MariaDBParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5991)
			p.Match(MariaDBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFROM || _la == MariaDBParserIN {
			{
				p.SetState(5992)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowOpenTablesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserFROM || _la == MariaDBParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowOpenTablesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5993)
				p.FullId()
			}

		}
		p.SetState(5997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIKE || _la == MariaDBParserWHERE {
			{
				p.SetState(5996)
				p.ShowFilter()
			}

		}

	case 20:
		localctx = NewShowProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5999)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6000)
			p.Match(MariaDBParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserALL || ((int64((_la-347)) & ^0x3f) == 0 && ((int64(1)<<(_la-347))&309237645313) != 0) || _la == MariaDBParserIPC || _la == MariaDBParserPAGE || _la == MariaDBParserSOURCE || _la == MariaDBParserSWAPS || _la == MariaDBParserMEMORY {
			{
				p.SetState(6001)
				p.ShowProfileType()
			}
			p.SetState(6006)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(6002)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6003)
					p.ShowProfileType()
				}

				p.SetState(6008)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(6014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(6011)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6012)
				p.Match(MariaDBParserQUERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6013)

				var _x = p.DecimalLiteral()

				localctx.(*ShowProfileContext).queryCount = _x
			}

		}
		p.SetState(6017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIMIT {
			{
				p.SetState(6016)
				p.LimitClause()
			}

		}

	case 21:
		localctx = NewShowSlaveStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6019)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6020)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSLAVE || _la == MariaDBParserREPLICA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTRING_LITERAL {
			{
				p.SetState(6021)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowSlaveStatusContext).connectionName = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6024)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(6025)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6026)
				p.Match(MariaDBParserCHANNEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6027)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*ShowSlaveStatusContext).channelName = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 22:
		localctx = NewShowUserstatPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6030)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6031)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-703)) & ^0x3f) == 0 && ((int64(1)<<(_la-703))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 23:
		localctx = NewShowExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6032)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6033)
			p.Match(MariaDBParserEXPLAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFORMAT {
			{
				p.SetState(6034)
				p.FormatJsonStatement()
			}

		}
		{
			p.SetState(6037)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6038)
			p.DecimalLiteral()
		}

	case 24:
		localctx = NewShowPackageStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6039)
			p.Match(MariaDBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6040)
			p.Match(MariaDBParserPACKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserBODY {
			{
				p.SetState(6041)
				p.Match(MariaDBParserBODY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6044)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLIKE || _la == MariaDBParserWHERE {
			{
				p.SetState(6045)
				p.ShowFilter()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainStatementContext is an interface to support dynamic dispatch.
type IExplainStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExplainStatementContext differentiates from other interfaces.
	IsExplainStatementContext()
}

type ExplainStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStatementContext() *ExplainStatementContext {
	var p = new(ExplainStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_explainStatement
	return p
}

func InitEmptyExplainStatementContext(p *ExplainStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_explainStatement
}

func (*ExplainStatementContext) IsExplainStatementContext() {}

func NewExplainStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStatementContext {
	var p = new(ExplainStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_explainStatement

	return p
}

func (s *ExplainStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStatementContext) CopyAll(ctx *ExplainStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExplainStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainForConnectionContext struct {
	ExplainStatementContext
}

func NewExplainForConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainForConnectionContext {
	var p = new(ExplainForConnectionContext)

	InitEmptyExplainStatementContext(&p.ExplainStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExplainStatementContext))

	return p
}

func (s *ExplainForConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainForConnectionContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPLAIN, 0)
}

func (s *ExplainForConnectionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *ExplainForConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *ExplainForConnectionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ExplainForConnectionContext) FormatJsonStatement() IFormatJsonStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatJsonStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatJsonStatementContext)
}

func (s *ExplainForConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExplainForConnection(s)
	}
}

func (s *ExplainForConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExplainForConnection(s)
	}
}

func (s *ExplainForConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExplainForConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ExplainStatement() (localctx IExplainStatementContext) {
	localctx = NewExplainStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, MariaDBParserRULE_explainStatement)
	var _la int

	localctx = NewExplainForConnectionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6050)
		p.Match(MariaDBParserEXPLAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserFORMAT {
		{
			p.SetState(6051)
			p.FormatJsonStatement()
		}

	}
	{
		p.SetState(6054)
		p.Match(MariaDBParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6055)
		p.Match(MariaDBParserCONNECTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6056)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableClauseContext is an interface to support dynamic dispatch.
type IVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode
	Uid() IUidContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllAT_SIGN() []antlr.TerminalNode
	AT_SIGN(i int) antlr.TerminalNode

	// IsVariableClauseContext differentiates from other interfaces.
	IsVariableClauseContext()
}

type VariableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableClauseContext() *VariableClauseContext {
	var p = new(VariableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_variableClause
	return p
}

func InitEmptyVariableClauseContext(p *VariableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_variableClause
}

func (*VariableClauseContext) IsVariableClauseContext() {}

func NewVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableClauseContext {
	var p = new(VariableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_variableClause

	return p
}

func (s *VariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableClauseContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *VariableClauseContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL_ID, 0)
}

func (s *VariableClauseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *VariableClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL, 0)
}

func (s *VariableClauseContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION, 0)
}

func (s *VariableClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *VariableClauseContext) AllAT_SIGN() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserAT_SIGN)
}

func (s *VariableClauseContext) AT_SIGN(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserAT_SIGN, i)
}

func (s *VariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterVariableClause(s)
	}
}

func (s *VariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitVariableClause(s)
	}
}

func (s *VariableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitVariableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) VariableClause() (localctx IVariableClauseContext) {
	localctx = NewVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, MariaDBParserRULE_variableClause)
	var _la int

	p.SetState(6068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6058)
			p.Match(MariaDBParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6059)
			p.Match(MariaDBParserGLOBAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserAT_SIGN, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6065)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) == 1 {
			p.SetState(6062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserAT_SIGN {
				{
					p.SetState(6060)
					p.Match(MariaDBParserAT_SIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6061)
					p.Match(MariaDBParserAT_SIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6064)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserGLOBAL || _la == MariaDBParserLOCAL || _la == MariaDBParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6067)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCommonEntityContext is an interface to support dynamic dispatch.
type IShowCommonEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsShowCommonEntityContext differentiates from other interfaces.
	IsShowCommonEntityContext()
}

type ShowCommonEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommonEntityContext() *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showCommonEntity
	return p
}

func InitEmptyShowCommonEntityContext(p *ShowCommonEntityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showCommonEntity
}

func (*ShowCommonEntityContext) IsShowCommonEntityContext() {}

func NewShowCommonEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showCommonEntity

	return p
}

func (s *ShowCommonEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommonEntityContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *ShowCommonEntityContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *ShowCommonEntityContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATION, 0)
}

func (s *ShowCommonEntityContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASES, 0)
}

func (s *ShowCommonEntityContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMAS, 0)
}

func (s *ShowCommonEntityContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *ShowCommonEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowCommonEntityContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCEDURE, 0)
}

func (s *ShowCommonEntityContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARIABLES, 0)
}

func (s *ShowCommonEntityContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL, 0)
}

func (s *ShowCommonEntityContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION, 0)
}

func (s *ShowCommonEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommonEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCommonEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowCommonEntity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowCommonEntity() (localctx IShowCommonEntityContext) {
	localctx = NewShowCommonEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, MariaDBParserRULE_showCommonEntity)
	var _la int

	p.SetState(6083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6070)
			p.Match(MariaDBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6071)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCOLLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6072)
			p.Match(MariaDBParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDATABASES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6073)
			p.Match(MariaDBParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSCHEMAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6074)
			p.Match(MariaDBParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFUNCTION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6075)
			p.Match(MariaDBParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6076)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPROCEDURE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6077)
			p.Match(MariaDBParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6078)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserGLOBAL, MariaDBParserSESSION, MariaDBParserSTATUS, MariaDBParserVARIABLES:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(6080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserGLOBAL || _la == MariaDBParserSESSION {
			{
				p.SetState(6079)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserGLOBAL || _la == MariaDBParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6082)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSTATUS || _la == MariaDBParserVARIABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFilterContext is an interface to support dynamic dispatch.
type IShowFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowFilterContext differentiates from other interfaces.
	IsShowFilterContext()
}

type ShowFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFilterContext() *ShowFilterContext {
	var p = new(ShowFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showFilter
	return p
}

func InitEmptyShowFilterContext(p *ShowFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showFilter
}

func (*ShowFilterContext) IsShowFilterContext() {}

func NewShowFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFilterContext {
	var p = new(ShowFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showFilter

	return p
}

func (s *ShowFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFilterContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIKE, 0)
}

func (s *ShowFilterContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ShowFilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHERE, 0)
}

func (s *ShowFilterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowFilter(s)
	}
}

func (s *ShowFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowFilter(s)
	}
}

func (s *ShowFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowFilter() (localctx IShowFilterContext) {
	localctx = NewShowFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, MariaDBParserRULE_showFilter)
	p.SetState(6089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6085)
			p.Match(MariaDBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6086)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6087)
			p.Match(MariaDBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6088)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGlobalInfoClauseContext is an interface to support dynamic dispatch.
type IShowGlobalInfoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINES() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ShowFilter() IShowFilterContext
	PRIVILEGES() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	LOCALES() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	QUERY_RESPONSE_TIME() antlr.TerminalNode
	ALL() antlr.TerminalNode
	SLAVES() antlr.TerminalNode
	REPLICAS() antlr.TerminalNode
	WSREP_MEMBERSHIP() antlr.TerminalNode
	WSREP_STATUS() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TYPES() antlr.TerminalNode

	// IsShowGlobalInfoClauseContext differentiates from other interfaces.
	IsShowGlobalInfoClauseContext()
}

type ShowGlobalInfoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGlobalInfoClauseContext() *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showGlobalInfoClause
	return p
}

func InitEmptyShowGlobalInfoClauseContext(p *ShowGlobalInfoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showGlobalInfoClause
}

func (*ShowGlobalInfoClauseContext) IsShowGlobalInfoClauseContext() {}

func NewShowGlobalInfoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showGlobalInfoClause

	return p
}

func (s *ShowGlobalInfoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGlobalInfoClauseContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINES, 0)
}

func (s *ShowGlobalInfoClauseContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORAGE, 0)
}

func (s *ShowGlobalInfoClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowGlobalInfoClauseContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *ShowGlobalInfoClauseContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG, 0)
}

func (s *ShowGlobalInfoClauseContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGINS, 0)
}

func (s *ShowGlobalInfoClauseContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSONAME, 0)
}

func (s *ShowGlobalInfoClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *ShowGlobalInfoClauseContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowGlobalInfoClauseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIVILEGES, 0)
}

func (s *ShowGlobalInfoClauseContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCESSLIST, 0)
}

func (s *ShowGlobalInfoClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULL, 0)
}

func (s *ShowGlobalInfoClauseContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROFILES, 0)
}

func (s *ShowGlobalInfoClauseContext) LOCALES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALES, 0)
}

func (s *ShowGlobalInfoClauseContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOSTS, 0)
}

func (s *ShowGlobalInfoClauseContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *ShowGlobalInfoClauseContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICA, 0)
}

func (s *ShowGlobalInfoClauseContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTHORS, 0)
}

func (s *ShowGlobalInfoClauseContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTRIBUTORS, 0)
}

func (s *ShowGlobalInfoClauseContext) QUERY_RESPONSE_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY_RESPONSE_TIME, 0)
}

func (s *ShowGlobalInfoClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *ShowGlobalInfoClauseContext) SLAVES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVES, 0)
}

func (s *ShowGlobalInfoClauseContext) REPLICAS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICAS, 0)
}

func (s *ShowGlobalInfoClauseContext) WSREP_MEMBERSHIP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWSREP_MEMBERSHIP, 0)
}

func (s *ShowGlobalInfoClauseContext) WSREP_STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWSREP_STATUS, 0)
}

func (s *ShowGlobalInfoClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *ShowGlobalInfoClauseContext) TYPES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTYPES, 0)
}

func (s *ShowGlobalInfoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGlobalInfoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowGlobalInfoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowGlobalInfoClause() (localctx IShowGlobalInfoClauseContext) {
	localctx = NewShowGlobalInfoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, MariaDBParserRULE_showGlobalInfoClause)
	var _la int

	p.SetState(6124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserENGINES, MariaDBParserSTORAGE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSTORAGE {
			{
				p.SetState(6091)
				p.Match(MariaDBParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6094)
			p.Match(MariaDBParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBINLOG, MariaDBParserMASTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6095)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserBINLOG || _la == MariaDBParserMASTER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6096)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPLUGINS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6097)
			p.Match(MariaDBParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSONAME {
			{
				p.SetState(6098)
				p.Match(MariaDBParserSONAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6101)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MariaDBParserSTRING_LITERAL:
				{
					p.SetState(6099)
					p.Match(MariaDBParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MariaDBParserLIKE, MariaDBParserWHERE:
				{
					p.SetState(6100)
					p.ShowFilter()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case MariaDBParserPRIVILEGES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6105)
			p.Match(MariaDBParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFULL, MariaDBParserPROCESSLIST:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(6107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFULL {
			{
				p.SetState(6106)
				p.Match(MariaDBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6109)
			p.Match(MariaDBParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPROFILES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6110)
			p.Match(MariaDBParserPROFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLOCALES:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6111)
			p.Match(MariaDBParserLOCALES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSLAVE, MariaDBParserREPLICA:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6112)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSLAVE || _la == MariaDBParserREPLICA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6113)
			p.Match(MariaDBParserHOSTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserAUTHORS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6114)
			p.Match(MariaDBParserAUTHORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCONTRIBUTORS:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6115)
			p.Match(MariaDBParserCONTRIBUTORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserQUERY_RESPONSE_TIME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6116)
			p.Match(MariaDBParserQUERY_RESPONSE_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserALL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6117)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6118)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSLAVES || _la == MariaDBParserREPLICAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6119)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserWSREP_MEMBERSHIP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6120)
			p.Match(MariaDBParserWSREP_MEMBERSHIP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserWSREP_STATUS:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6121)
			p.Match(MariaDBParserWSREP_STATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserTABLE:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6122)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6123)
			p.Match(MariaDBParserTYPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSchemaEntityContext is an interface to support dynamic dispatch.
type IShowSchemaEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENTS() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode

	// IsShowSchemaEntityContext differentiates from other interfaces.
	IsShowSchemaEntityContext()
}

type ShowSchemaEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSchemaEntityContext() *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showSchemaEntity
	return p
}

func InitEmptyShowSchemaEntityContext(p *ShowSchemaEntityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showSchemaEntity
}

func (*ShowSchemaEntityContext) IsShowSchemaEntityContext() {}

func NewShowSchemaEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showSchemaEntity

	return p
}

func (s *ShowSchemaEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSchemaEntityContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENTS, 0)
}

func (s *ShowSchemaEntityContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *ShowSchemaEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *ShowSchemaEntityContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *ShowSchemaEntityContext) FULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULL, 0)
}

func (s *ShowSchemaEntityContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGERS, 0)
}

func (s *ShowSchemaEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSchemaEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowSchemaEntity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowSchemaEntity() (localctx IShowSchemaEntityContext) {
	localctx = NewShowSchemaEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, MariaDBParserRULE_showSchemaEntity)
	var _la int

	p.SetState(6134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserEVENTS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6126)
			p.Match(MariaDBParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6127)
			p.Match(MariaDBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6128)
			p.Match(MariaDBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFULL, MariaDBParserTABLES:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6130)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFULL {
			{
				p.SetState(6129)
				p.Match(MariaDBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6132)
			p.Match(MariaDBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserTRIGGERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6133)
			p.Match(MariaDBParserTRIGGERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfileTypeContext is an interface to support dynamic dispatch.
type IShowProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	IO() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	CPU() antlr.TerminalNode
	IPC() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SWAPS() antlr.TerminalNode

	// IsShowProfileTypeContext differentiates from other interfaces.
	IsShowProfileTypeContext()
}

type ShowProfileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProfileTypeContext() *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showProfileType
	return p
}

func InitEmptyShowProfileTypeContext(p *ShowProfileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_showProfileType
}

func (*ShowProfileTypeContext) IsShowProfileTypeContext() {}

func NewShowProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_showProfileType

	return p
}

func (s *ShowProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfileTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *ShowProfileTypeContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBLOCK, 0)
}

func (s *ShowProfileTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIO, 0)
}

func (s *ShowProfileTypeContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTEXT, 0)
}

func (s *ShowProfileTypeContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSWITCHES, 0)
}

func (s *ShowProfileTypeContext) CPU() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCPU, 0)
}

func (s *ShowProfileTypeContext) IPC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIPC, 0)
}

func (s *ShowProfileTypeContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMORY, 0)
}

func (s *ShowProfileTypeContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE, 0)
}

func (s *ShowProfileTypeContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAULTS, 0)
}

func (s *ShowProfileTypeContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOURCE, 0)
}

func (s *ShowProfileTypeContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSWAPS, 0)
}

func (s *ShowProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShowProfileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShowProfileType() (localctx IShowProfileTypeContext) {
	localctx = NewShowProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, MariaDBParserRULE_showProfileType)
	p.SetState(6148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6136)
			p.Match(MariaDBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6137)
			p.Match(MariaDBParserBLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6138)
			p.Match(MariaDBParserIO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCONTEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6139)
			p.Match(MariaDBParserCONTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6140)
			p.Match(MariaDBParserSWITCHES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCPU:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6141)
			p.Match(MariaDBParserCPU)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserIPC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6142)
			p.Match(MariaDBParserIPC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMEMORY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6143)
			p.Match(MariaDBParserMEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserPAGE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6144)
			p.Match(MariaDBParserPAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6145)
			p.Match(MariaDBParserFAULTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6146)
			p.Match(MariaDBParserSOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSWAPS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6147)
			p.Match(MariaDBParserSWAPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinlogStatementContext is an interface to support dynamic dispatch.
type IBinlogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINLOG() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsBinlogStatementContext differentiates from other interfaces.
	IsBinlogStatementContext()
}

type BinlogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinlogStatementContext() *BinlogStatementContext {
	var p = new(BinlogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_binlogStatement
	return p
}

func InitEmptyBinlogStatementContext(p *BinlogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_binlogStatement
}

func (*BinlogStatementContext) IsBinlogStatementContext() {}

func NewBinlogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinlogStatementContext {
	var p = new(BinlogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_binlogStatement

	return p
}

func (s *BinlogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BinlogStatementContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG, 0)
}

func (s *BinlogStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *BinlogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinlogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinlogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBinlogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BinlogStatement() (localctx IBinlogStatementContext) {
	localctx = NewBinlogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, MariaDBParserRULE_binlogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6150)
		p.Match(MariaDBParserBINLOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6151)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICacheIndexStatementContext is an interface to support dynamic dispatch.
type ICacheIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSchema returns the schema rule contexts.
	GetSchema() IUidContext

	// SetSchema sets the schema rule contexts.
	SetSchema(IUidContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllTableIndexes() []ITableIndexesContext
	TableIndexes(i int) ITableIndexesContext
	IN() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	ALL() antlr.TerminalNode

	// IsCacheIndexStatementContext differentiates from other interfaces.
	IsCacheIndexStatementContext()
}

type CacheIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	schema IUidContext
}

func NewEmptyCacheIndexStatementContext() *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cacheIndexStatement
	return p
}

func InitEmptyCacheIndexStatementContext(p *CacheIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_cacheIndexStatement
}

func (*CacheIndexStatementContext) IsCacheIndexStatementContext() {}

func NewCacheIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_cacheIndexStatement

	return p
}

func (s *CacheIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CacheIndexStatementContext) GetSchema() IUidContext { return s.schema }

func (s *CacheIndexStatementContext) SetSchema(v IUidContext) { s.schema = v }

func (s *CacheIndexStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *CacheIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *CacheIndexStatementContext) AllTableIndexes() []ITableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ITableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIndexesContext); ok {
			tst[i] = t.(ITableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *CacheIndexStatementContext) TableIndexes(i int) ITableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexesContext)
}

func (s *CacheIndexStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *CacheIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CacheIndexStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CacheIndexStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CacheIndexStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *CacheIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CacheIndexStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *CacheIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CacheIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCacheIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CacheIndexStatement() (localctx ICacheIndexStatementContext) {
	localctx = NewCacheIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, MariaDBParserRULE_cacheIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6153)
		p.Match(MariaDBParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6154)
		p.Match(MariaDBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6155)
		p.TableIndexes()
	}
	p.SetState(6160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6156)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6157)
			p.TableIndexes()
		}

		p.SetState(6162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(6170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(6163)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6164)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(6165)
				p.UidList()
			}

		case MariaDBParserALL:
			{
				p.SetState(6166)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6169)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6172)
		p.Match(MariaDBParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6173)

		var _x = p.Uid()

		localctx.(*CacheIndexStatementContext).schema = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushStatementContext is an interface to support dynamic dispatch.
type IFlushStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFlushFormat returns the flushFormat token.
	GetFlushFormat() antlr.Token

	// SetFlushFormat sets the flushFormat token.
	SetFlushFormat(antlr.Token)

	// Getter signatures
	FLUSH() antlr.TerminalNode
	AllFlushOption() []IFlushOptionContext
	FlushOption(i int) IFlushOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	USER_STATISTICS() antlr.TerminalNode
	CLIENT_STATISTICS() antlr.TerminalNode
	INDEX_STATISTICS() antlr.TerminalNode
	TABLE_STATISTICS() antlr.TerminalNode

	// IsFlushStatementContext differentiates from other interfaces.
	IsFlushStatementContext()
}

type FlushStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	flushFormat antlr.Token
}

func NewEmptyFlushStatementContext() *FlushStatementContext {
	var p = new(FlushStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushStatement
	return p
}

func InitEmptyFlushStatementContext(p *FlushStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushStatement
}

func (*FlushStatementContext) IsFlushStatementContext() {}

func NewFlushStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushStatementContext {
	var p = new(FlushStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_flushStatement

	return p
}

func (s *FlushStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushStatementContext) GetFlushFormat() antlr.Token { return s.flushFormat }

func (s *FlushStatementContext) SetFlushFormat(v antlr.Token) { s.flushFormat = v }

func (s *FlushStatementContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH, 0)
}

func (s *FlushStatementContext) AllFlushOption() []IFlushOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlushOptionContext); ok {
			len++
		}
	}

	tst := make([]IFlushOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlushOptionContext); ok {
			tst[i] = t.(IFlushOptionContext)
			i++
		}
	}

	return tst
}

func (s *FlushStatementContext) FlushOption(i int) IFlushOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushOptionContext)
}

func (s *FlushStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *FlushStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *FlushStatementContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO_WRITE_TO_BINLOG, 0)
}

func (s *FlushStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *FlushStatementContext) USER_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER_STATISTICS, 0)
}

func (s *FlushStatementContext) CLIENT_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLIENT_STATISTICS, 0)
}

func (s *FlushStatementContext) INDEX_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX_STATISTICS, 0)
}

func (s *FlushStatementContext) TABLE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_STATISTICS, 0)
}

func (s *FlushStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFlushStatement(s)
	}
}

func (s *FlushStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFlushStatement(s)
	}
}

func (s *FlushStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFlushStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FlushStatement() (localctx IFlushStatementContext) {
	localctx = NewFlushStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, MariaDBParserRULE_flushStatement)
	var _la int

	p.SetState(6189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 913, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6175)
			p.Match(MariaDBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL {
			{
				p.SetState(6176)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*FlushStatementContext).flushFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserNO_WRITE_TO_BINLOG || _la == MariaDBParserLOCAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*FlushStatementContext).flushFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6179)
			p.FlushOption()
		}
		p.SetState(6184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(6180)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6181)
				p.FlushOption()
			}

			p.SetState(6186)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6187)
			p.Match(MariaDBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6188)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-703)) & ^0x3f) == 0 && ((int64(1)<<(_la-703))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnectionFormat returns the connectionFormat token.
	GetConnectionFormat() antlr.Token

	// SetConnectionFormat sets the connectionFormat token.
	SetConnectionFormat(antlr.Token)

	// Getter signatures
	KILL() antlr.TerminalNode
	Expression() IExpressionContext
	CONNECTION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	connectionFormat antlr.Token
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnectionFormat() antlr.Token { return s.connectionFormat }

func (s *KillStatementContext) SetConnectionFormat(v antlr.Token) { s.connectionFormat = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKILL, 0)
}

func (s *KillStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, MariaDBParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6191)
		p.Match(MariaDBParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6193)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 914, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6192)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*KillStatementContext).connectionFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCONNECTION || _la == MariaDBParserQUERY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*KillStatementContext).connectionFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6195)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadIndexIntoCacheContext is an interface to support dynamic dispatch.
type ILoadIndexIntoCacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INTO() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	AllLoadedTableIndexes() []ILoadedTableIndexesContext
	LoadedTableIndexes(i int) ILoadedTableIndexesContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadIndexIntoCacheContext differentiates from other interfaces.
	IsLoadIndexIntoCacheContext()
}

type LoadIndexIntoCacheContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadIndexIntoCacheContext() *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadIndexIntoCache
	return p
}

func InitEmptyLoadIndexIntoCacheContext(p *LoadIndexIntoCacheContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadIndexIntoCache
}

func (*LoadIndexIntoCacheContext) IsLoadIndexIntoCacheContext() {}

func NewLoadIndexIntoCacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_loadIndexIntoCache

	return p
}

func (s *LoadIndexIntoCacheContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadIndexIntoCacheContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOAD, 0)
}

func (s *LoadIndexIntoCacheContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *LoadIndexIntoCacheContext) INTO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTO, 0)
}

func (s *LoadIndexIntoCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *LoadIndexIntoCacheContext) AllLoadedTableIndexes() []ILoadedTableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ILoadedTableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadedTableIndexesContext); ok {
			tst[i] = t.(ILoadedTableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *LoadIndexIntoCacheContext) LoadedTableIndexes(i int) ILoadedTableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadedTableIndexesContext)
}

func (s *LoadIndexIntoCacheContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *LoadIndexIntoCacheContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *LoadIndexIntoCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadIndexIntoCacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadIndexIntoCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLoadIndexIntoCache(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LoadIndexIntoCache() (localctx ILoadIndexIntoCacheContext) {
	localctx = NewLoadIndexIntoCacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, MariaDBParserRULE_loadIndexIntoCache)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6197)
		p.Match(MariaDBParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6198)
		p.Match(MariaDBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6199)
		p.Match(MariaDBParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6200)
		p.Match(MariaDBParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6201)
		p.LoadedTableIndexes()
	}
	p.SetState(6206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6202)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6203)
			p.LoadedTableIndexes()
		}

		p.SetState(6208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	CACHE() antlr.TerminalNode

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetStatement
	return p
}

func InitEmptyResetStatementContext(p *ResetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resetStatement
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESET, 0)
}

func (s *ResetStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY, 0)
}

func (s *ResetStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (s *ResetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitResetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ResetStatement() (localctx IResetStatementContext) {
	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, MariaDBParserRULE_resetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6209)
		p.Match(MariaDBParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6210)
		p.Match(MariaDBParserQUERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6211)
		p.Match(MariaDBParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShutdownStatementContext is an interface to support dynamic dispatch.
type IShutdownStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHUTDOWN() antlr.TerminalNode

	// IsShutdownStatementContext differentiates from other interfaces.
	IsShutdownStatementContext()
}

type ShutdownStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShutdownStatementContext() *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_shutdownStatement
	return p
}

func InitEmptyShutdownStatementContext(p *ShutdownStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_shutdownStatement
}

func (*ShutdownStatementContext) IsShutdownStatementContext() {}

func NewShutdownStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_shutdownStatement

	return p
}

func (s *ShutdownStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShutdownStatementContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHUTDOWN, 0)
}

func (s *ShutdownStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShutdownStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShutdownStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitShutdownStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ShutdownStatement() (localctx IShutdownStatementContext) {
	localctx = NewShutdownStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, MariaDBParserRULE_shutdownStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6213)
		p.Match(MariaDBParserSHUTDOWN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIndexesContext is an interface to support dynamic dispatch.
type ITableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// Getter signatures
	TableName() ITableNameContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsTableIndexesContext differentiates from other interfaces.
	IsTableIndexesContext()
}

type TableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	indexFormat antlr.Token
}

func NewEmptyTableIndexesContext() *TableIndexesContext {
	var p = new(TableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableIndexes
	return p
}

func InitEmptyTableIndexesContext(p *TableIndexesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableIndexes
}

func (*TableIndexesContext) IsTableIndexesContext() {}

func NewTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexesContext {
	var p = new(TableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableIndexes

	return p
}

func (s *TableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *TableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *TableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableIndexesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TableIndexesContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *TableIndexesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *TableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *TableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableIndexes(s)
	}
}

func (s *TableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableIndexes(s)
	}
}

func (s *TableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableIndexes() (localctx ITableIndexesContext) {
	localctx = NewTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, MariaDBParserRULE_tableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6215)
		p.TableName()
	}
	p.SetState(6223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserINDEX || _la == MariaDBParserKEY || _la == MariaDBParserLR_BRACKET {
		p.SetState(6217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(6216)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*TableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*TableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6219)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6220)
			p.UidList()
		}
		{
			p.SetState(6221)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushOptionContext is an interface to support dynamic dispatch.
type IFlushOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFlushOptionContext differentiates from other interfaces.
	IsFlushOptionContext()
}

type FlushOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushOptionContext() *FlushOptionContext {
	var p = new(FlushOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushOption
	return p
}

func InitEmptyFlushOptionContext(p *FlushOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushOption
}

func (*FlushOptionContext) IsFlushOptionContext() {}

func NewFlushOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushOptionContext {
	var p = new(FlushOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_flushOption

	return p
}

func (s *FlushOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushOptionContext) CopyAll(ctx *FlushOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableFlushOptionContext struct {
	FlushOptionContext
}

func NewTableFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFlushOptionContext {
	var p = new(TableFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *TableFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFlushOptionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE, 0)
}

func (s *TableFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *TableFlushOptionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableFlushOptionContext) FlushTableOption() IFlushTableOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTableOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTableOptionContext)
}

func (s *TableFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ChannelFlushOptionContext struct {
	FlushOptionContext
}

func NewChannelFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChannelFlushOptionContext {
	var p = new(ChannelFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *ChannelFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY, 0)
}

func (s *ChannelFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGS, 0)
}

func (s *ChannelFlushOptionContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChannelFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitChannelFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFlushOptionContext struct {
	FlushOptionContext
}

func NewSimpleFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFlushOptionContext {
	var p = new(SimpleFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *SimpleFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFlushOptionContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDES_KEY_FILE, 0)
}

func (s *SimpleFlushOptionContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOSTS, 0)
}

func (s *SimpleFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGS, 0)
}

func (s *SimpleFlushOptionContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIMIZER_COSTS, 0)
}

func (s *SimpleFlushOptionContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIVILEGES, 0)
}

func (s *SimpleFlushOptionContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY, 0)
}

func (s *SimpleFlushOptionContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *SimpleFlushOptionContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *SimpleFlushOptionContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER_RESOURCES, 0)
}

func (s *SimpleFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *SimpleFlushOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *SimpleFlushOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *SimpleFlushOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *SimpleFlushOptionContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *SimpleFlushOptionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *SimpleFlushOptionContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERROR, 0)
}

func (s *SimpleFlushOptionContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGENERAL, 0)
}

func (s *SimpleFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY, 0)
}

func (s *SimpleFlushOptionContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLOW, 0)
}

func (s *SimpleFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FlushOption() (localctx IFlushOptionContext) {
	localctx = NewFlushOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, MariaDBParserRULE_flushOption)
	var _la int

	p.SetState(6257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 924, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserDES_KEY_FILE:
			{
				p.SetState(6225)
				p.Match(MariaDBParserDES_KEY_FILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserHOSTS:
			{
				p.SetState(6226)
				p.Match(MariaDBParserHOSTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserBINARY, MariaDBParserENGINE, MariaDBParserERROR, MariaDBParserGENERAL, MariaDBParserLOGS, MariaDBParserRELAY, MariaDBParserSLOW:
			p.SetState(6228)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserBINARY || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&536870917) != 0) || _la == MariaDBParserRELAY || _la == MariaDBParserSLOW {
				{
					p.SetState(6227)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserBINARY || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&536870917) != 0) || _la == MariaDBParserRELAY || _la == MariaDBParserSLOW) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(6230)
				p.Match(MariaDBParserLOGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserOPTIMIZER_COSTS:
			{
				p.SetState(6231)
				p.Match(MariaDBParserOPTIMIZER_COSTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserPRIVILEGES:
			{
				p.SetState(6232)
				p.Match(MariaDBParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserQUERY:
			{
				p.SetState(6233)
				p.Match(MariaDBParserQUERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6234)
				p.Match(MariaDBParserCACHE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserSTATUS:
			{
				p.SetState(6235)
				p.Match(MariaDBParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserUSER_RESOURCES:
			{
				p.SetState(6236)
				p.Match(MariaDBParserUSER_RESOURCES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserTABLES:
			{
				p.SetState(6237)
				p.Match(MariaDBParserTABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6241)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserWITH {
				{
					p.SetState(6238)
					p.Match(MariaDBParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6239)
					p.Match(MariaDBParserREAD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6240)
					p.Match(MariaDBParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewChannelFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6245)
			p.Match(MariaDBParserRELAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6246)
			p.Match(MariaDBParserLOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(6247)
				p.ChannelOption()
			}

		}

	case 3:
		localctx = NewTableFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6250)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserTABLE || _la == MariaDBParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6251)
				p.Tables()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR || _la == MariaDBParserWITH {
			{
				p.SetState(6254)
				p.FlushTableOption()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushTableOptionContext is an interface to support dynamic dispatch.
type IFlushTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	READ() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsFlushTableOptionContext differentiates from other interfaces.
	IsFlushTableOptionContext()
}

type FlushTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTableOptionContext() *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushTableOption
	return p
}

func InitEmptyFlushTableOptionContext(p *FlushTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_flushTableOption
}

func (*FlushTableOptionContext) IsFlushTableOptionContext() {}

func NewFlushTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_flushTableOption

	return p
}

func (s *FlushTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTableOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITH, 0)
}

func (s *FlushTableOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD, 0)
}

func (s *FlushTableOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCK, 0)
}

func (s *FlushTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *FlushTableOptionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPORT, 0)
}

func (s *FlushTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFlushTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FlushTableOption() (localctx IFlushTableOptionContext) {
	localctx = NewFlushTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, MariaDBParserRULE_flushTableOption)
	p.SetState(6264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6259)
			p.Match(MariaDBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6260)
			p.Match(MariaDBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6261)
			p.Match(MariaDBParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6262)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6263)
			p.Match(MariaDBParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadedTableIndexesContext is an interface to support dynamic dispatch.
type ILoadedTableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IUidListContext

	// GetIndexList returns the indexList rule contexts.
	GetIndexList() IUidListContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IUidListContext)

	// SetIndexList sets the indexList rule contexts.
	SetIndexList(IUidListContext)

	// Getter signatures
	TableName() ITableNameContext
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	ALL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsLoadedTableIndexesContext differentiates from other interfaces.
	IsLoadedTableIndexesContext()
}

type LoadedTableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionList IUidListContext
	indexFormat   antlr.Token
	indexList     IUidListContext
}

func NewEmptyLoadedTableIndexesContext() *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadedTableIndexes
	return p
}

func InitEmptyLoadedTableIndexesContext(p *LoadedTableIndexesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_loadedTableIndexes
}

func (*LoadedTableIndexesContext) IsLoadedTableIndexesContext() {}

func NewLoadedTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_loadedTableIndexes

	return p
}

func (s *LoadedTableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadedTableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *LoadedTableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *LoadedTableIndexesContext) GetPartitionList() IUidListContext { return s.partitionList }

func (s *LoadedTableIndexesContext) GetIndexList() IUidListContext { return s.indexList }

func (s *LoadedTableIndexesContext) SetPartitionList(v IUidListContext) { s.partitionList = v }

func (s *LoadedTableIndexesContext) SetIndexList(v IUidListContext) { s.indexList = v }

func (s *LoadedTableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadedTableIndexesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *LoadedTableIndexesContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *LoadedTableIndexesContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *LoadedTableIndexesContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE, 0)
}

func (s *LoadedTableIndexesContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAVES, 0)
}

func (s *LoadedTableIndexesContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *LoadedTableIndexesContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadedTableIndexesContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *LoadedTableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX, 0)
}

func (s *LoadedTableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY, 0)
}

func (s *LoadedTableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadedTableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadedTableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLoadedTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LoadedTableIndexes() (localctx ILoadedTableIndexesContext) {
	localctx = NewLoadedTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, MariaDBParserRULE_loadedTableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6266)
		p.TableName()
	}
	p.SetState(6274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(6267)
			p.Match(MariaDBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6268)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
			{
				p.SetState(6269)

				var _x = p.UidList()

				localctx.(*LoadedTableIndexesContext).partitionList = _x
			}

		case MariaDBParserALL:
			{
				p.SetState(6270)
				p.Match(MariaDBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6273)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(6283)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 929, p.GetParserRuleContext()) == 1 {
		p.SetState(6277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINDEX || _la == MariaDBParserKEY {
			{
				p.SetState(6276)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*LoadedTableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserINDEX || _la == MariaDBParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*LoadedTableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6279)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6280)

			var _x = p.UidList()

			localctx.(*LoadedTableIndexesContext).indexList = _x
		}
		{
			p.SetState(6281)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserIGNORE {
		{
			p.SetState(6285)
			p.Match(MariaDBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6286)
			p.Match(MariaDBParserLEAVES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDescribeStatementContext is an interface to support dynamic dispatch.
type ISimpleDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetColumn returns the column rule contexts.
	GetColumn() IUidContext

	// SetColumn sets the column rule contexts.
	SetColumn(IUidContext)

	// Getter signatures
	TableName() ITableNameContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleDescribeStatementContext differentiates from other interfaces.
	IsSimpleDescribeStatementContext()
}

type SimpleDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	command antlr.Token
	column  IUidContext
	pattern antlr.Token
}

func NewEmptySimpleDescribeStatementContext() *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleDescribeStatement
	return p
}

func InitEmptySimpleDescribeStatementContext(p *SimpleDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleDescribeStatement
}

func (*SimpleDescribeStatementContext) IsSimpleDescribeStatementContext() {}

func NewSimpleDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_simpleDescribeStatement

	return p
}

func (s *SimpleDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *SimpleDescribeStatementContext) GetPattern() antlr.Token { return s.pattern }

func (s *SimpleDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *SimpleDescribeStatementContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *SimpleDescribeStatementContext) GetColumn() IUidContext { return s.column }

func (s *SimpleDescribeStatementContext) SetColumn(v IUidContext) { s.column = v }

func (s *SimpleDescribeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SimpleDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPLAIN, 0)
}

func (s *SimpleDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESCRIBE, 0)
}

func (s *SimpleDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *SimpleDescribeStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleDescribeStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *SimpleDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SimpleDescribeStatement() (localctx ISimpleDescribeStatementContext) {
	localctx = NewSimpleDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, MariaDBParserRULE_simpleDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6289)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SimpleDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611897124659920896) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SimpleDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6290)
		p.TableName()
	}
	p.SetState(6293)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6291)

			var _x = p.Uid()

			localctx.(*SimpleDescribeStatementContext).column = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6292)

			var _m = p.Match(MariaDBParserSTRING_LITERAL)

			localctx.(*SimpleDescribeStatementContext).pattern = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullDescribeStatementContext is an interface to support dynamic dispatch.
type IFullDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetFormatType returns the formatType token.
	GetFormatType() antlr.Token

	// GetFormatValue returns the formatValue token.
	GetFormatValue() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetFormatType sets the formatType token.
	SetFormatType(antlr.Token)

	// SetFormatValue sets the formatValue token.
	SetFormatValue(antlr.Token)

	// Getter signatures
	DescribeObjectClause() IDescribeObjectClauseContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFullDescribeStatementContext differentiates from other interfaces.
	IsFullDescribeStatementContext()
}

type FullDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	command     antlr.Token
	formatType  antlr.Token
	formatValue antlr.Token
}

func NewEmptyFullDescribeStatementContext() *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullDescribeStatement
	return p
}

func InitEmptyFullDescribeStatementContext(p *FullDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullDescribeStatement
}

func (*FullDescribeStatementContext) IsFullDescribeStatementContext() {}

func NewFullDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_fullDescribeStatement

	return p
}

func (s *FullDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FullDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *FullDescribeStatementContext) GetFormatType() antlr.Token { return s.formatType }

func (s *FullDescribeStatementContext) GetFormatValue() antlr.Token { return s.formatValue }

func (s *FullDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *FullDescribeStatementContext) SetFormatType(v antlr.Token) { s.formatType = v }

func (s *FullDescribeStatementContext) SetFormatValue(v antlr.Token) { s.formatValue = v }

func (s *FullDescribeStatementContext) DescribeObjectClause() IDescribeObjectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeObjectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeObjectClauseContext)
}

func (s *FullDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPLAIN, 0)
}

func (s *FullDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESCRIBE, 0)
}

func (s *FullDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *FullDescribeStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *FullDescribeStatementContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENDED, 0)
}

func (s *FullDescribeStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONS, 0)
}

func (s *FullDescribeStatementContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFORMAT, 0)
}

func (s *FullDescribeStatementContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRADITIONAL, 0)
}

func (s *FullDescribeStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON, 0)
}

func (s *FullDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFullDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FullDescribeStatement() (localctx IFullDescribeStatementContext) {
	localctx = NewFullDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, MariaDBParserRULE_fullDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6295)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FullDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611897124659920896) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FullDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(6299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserEXTENDED || _la == MariaDBParserPARTITIONS || _la == MariaDBParserFORMAT {
		{
			p.SetState(6296)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserEXTENDED || _la == MariaDBParserPARTITIONS || _la == MariaDBParserFORMAT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6297)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6298)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserJSON || _la == MariaDBParserTRADITIONAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6301)
		p.DescribeObjectClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatJsonStatementContext is an interface to support dynamic dispatch.
type IFormatJsonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFormatValue returns the formatValue token.
	GetFormatValue() antlr.Token

	// SetFormatValue sets the formatValue token.
	SetFormatValue(antlr.Token)

	// Getter signatures
	FORMAT() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFormatJsonStatementContext differentiates from other interfaces.
	IsFormatJsonStatementContext()
}

type FormatJsonStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	formatValue antlr.Token
}

func NewEmptyFormatJsonStatementContext() *FormatJsonStatementContext {
	var p = new(FormatJsonStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_formatJsonStatement
	return p
}

func InitEmptyFormatJsonStatementContext(p *FormatJsonStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_formatJsonStatement
}

func (*FormatJsonStatementContext) IsFormatJsonStatementContext() {}

func NewFormatJsonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatJsonStatementContext {
	var p = new(FormatJsonStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_formatJsonStatement

	return p
}

func (s *FormatJsonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatJsonStatementContext) GetFormatValue() antlr.Token { return s.formatValue }

func (s *FormatJsonStatementContext) SetFormatValue(v antlr.Token) { s.formatValue = v }

func (s *FormatJsonStatementContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFORMAT, 0)
}

func (s *FormatJsonStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *FormatJsonStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON, 0)
}

func (s *FormatJsonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatJsonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatJsonStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFormatJsonStatement(s)
	}
}

func (s *FormatJsonStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFormatJsonStatement(s)
	}
}

func (s *FormatJsonStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFormatJsonStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FormatJsonStatement() (localctx IFormatJsonStatementContext) {
	localctx = NewFormatJsonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, MariaDBParserRULE_formatJsonStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6303)
		p.Match(MariaDBParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6304)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6305)

		var _m = p.Match(MariaDBParserJSON)

		localctx.(*FormatJsonStatementContext).formatValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHELP, 0)
}

func (s *HelpStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, MariaDBParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6307)
		p.Match(MariaDBParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6308)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Uid() IUidContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_useStatement
	return p
}

func InitEmptyUseStatementContext(p *UseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_useStatement
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSE, 0)
}

func (s *UseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, MariaDBParserRULE_useStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6310)
		p.Match(MariaDBParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6311)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalStatementContext is an interface to support dynamic dispatch.
type ISignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSignalStatementContext differentiates from other interfaces.
	IsSignalStatementContext()
}

type SignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStatementContext() *SignalStatementContext {
	var p = new(SignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_signalStatement
	return p
}

func InitEmptySignalStatementContext(p *SignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_signalStatement
}

func (*SignalStatementContext) IsSignalStatementContext() {}

func NewSignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStatementContext {
	var p = new(SignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_signalStatement

	return p
}

func (s *SignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStatementContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIGNAL, 0)
}

func (s *SignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *SignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE_QUOTE_ID, 0)
}

func (s *SignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *SignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *SignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *SignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLSTATE, 0)
}

func (s *SignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *SignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSignalStatement(s)
	}
}

func (s *SignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSignalStatement(s)
	}
}

func (s *SignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SignalStatement() (localctx ISignalStatementContext) {
	localctx = NewSignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, MariaDBParserRULE_signalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6313)
		p.Match(MariaDBParserSIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSQLSTATE:
		{
			p.SetState(6314)
			p.Match(MariaDBParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVALUE {
			{
				p.SetState(6315)
				p.Match(MariaDBParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6318)
			p.StringLiteral()
		}

	case MariaDBParserID:
		{
			p.SetState(6319)
			p.Match(MariaDBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREVERSE_QUOTE_ID:
		{
			p.SetState(6320)
			p.Match(MariaDBParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6332)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 936, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6323)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6324)
			p.SignalConditionInformation()
		}
		p.SetState(6329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(6325)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6326)
				p.SignalConditionInformation()
			}

			p.SetState(6331)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResignalStatementContext is an interface to support dynamic dispatch.
type IResignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsResignalStatementContext differentiates from other interfaces.
	IsResignalStatementContext()
}

type ResignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignalStatementContext() *ResignalStatementContext {
	var p = new(ResignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resignalStatement
	return p
}

func InitEmptyResignalStatementContext(p *ResignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_resignalStatement
}

func (*ResignalStatementContext) IsResignalStatementContext() {}

func NewResignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResignalStatementContext {
	var p = new(ResignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_resignalStatement

	return p
}

func (s *ResignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResignalStatementContext) RESIGNAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESIGNAL, 0)
}

func (s *ResignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *ResignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE_QUOTE_ID, 0)
}

func (s *ResignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *ResignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *ResignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *ResignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQLSTATE, 0)
}

func (s *ResignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ResignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ResignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ResignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *ResignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterResignalStatement(s)
	}
}

func (s *ResignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitResignalStatement(s)
	}
}

func (s *ResignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitResignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ResignalStatement() (localctx IResignalStatementContext) {
	localctx = NewResignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, MariaDBParserRULE_resignalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6334)
		p.Match(MariaDBParserRESIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSQLSTATE:
		{
			p.SetState(6335)
			p.Match(MariaDBParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVALUE {
			{
				p.SetState(6336)
				p.Match(MariaDBParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6339)
			p.StringLiteral()
		}

	case MariaDBParserID:
		{
			p.SetState(6340)
			p.Match(MariaDBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREVERSE_QUOTE_ID:
		{
			p.SetState(6341)
			p.Match(MariaDBParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserEOF, MariaDBParserALTER, MariaDBParserANALYZE, MariaDBParserCALL, MariaDBParserCHANGE, MariaDBParserCHECK, MariaDBParserCREATE, MariaDBParserDELETE, MariaDBParserDESC, MariaDBParserDESCRIBE, MariaDBParserDROP, MariaDBParserEXPLAIN, MariaDBParserGET, MariaDBParserGRANT, MariaDBParserINSERT, MariaDBParserKILL, MariaDBParserLOAD, MariaDBParserLOCK, MariaDBParserOPTIMIZE, MariaDBParserPURGE, MariaDBParserRELEASE, MariaDBParserRENAME, MariaDBParserREPLACE, MariaDBParserRESIGNAL, MariaDBParserREVOKE, MariaDBParserSELECT, MariaDBParserSET, MariaDBParserSHOW, MariaDBParserSIGNAL, MariaDBParserUNLOCK, MariaDBParserUPDATE, MariaDBParserUSE, MariaDBParserVALUES, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserCACHE, MariaDBParserCHECKSUM, MariaDBParserCOMMIT, MariaDBParserDEALLOCATE, MariaDBParserDO, MariaDBParserFLUSH, MariaDBParserHANDLER, MariaDBParserHELP, MariaDBParserINSTALL, MariaDBParserPREPARE, MariaDBParserREPAIR, MariaDBParserRESET, MariaDBParserROLLBACK, MariaDBParserSAVEPOINT, MariaDBParserSTART, MariaDBParserSTOP, MariaDBParserTRUNCATE, MariaDBParserUNINSTALL, MariaDBParserXA, MariaDBParserEXECUTE, MariaDBParserSHUTDOWN, MariaDBParserMINUS, MariaDBParserLR_BRACKET, MariaDBParserSEMI:

	default:
	}
	p.SetState(6353)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 940, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6344)
			p.Match(MariaDBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6345)
			p.SignalConditionInformation()
		}
		p.SetState(6350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(6346)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6347)
				p.SignalConditionInformation()
			}

			p.SetState(6352)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalConditionInformationContext is an interface to support dynamic dispatch.
type ISignalConditionInformationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DECIMAL_LITERAL() antlr.TerminalNode
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsSignalConditionInformationContext differentiates from other interfaces.
	IsSignalConditionInformationContext()
}

type SignalConditionInformationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalConditionInformationContext() *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_signalConditionInformation
	return p
}

func InitEmptySignalConditionInformationContext(p *SignalConditionInformationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_signalConditionInformation
}

func (*SignalConditionInformationContext) IsSignalConditionInformationContext() {}

func NewSignalConditionInformationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_signalConditionInformation

	return p
}

func (s *SignalConditionInformationContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalConditionInformationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *SignalConditionInformationContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMESSAGE_TEXT, 0)
}

func (s *SignalConditionInformationContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL_ERRNO, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_CATALOG, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_SCHEMA, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_NAME, 0)
}

func (s *SignalConditionInformationContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCATALOG_NAME, 0)
}

func (s *SignalConditionInformationContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA_NAME, 0)
}

func (s *SignalConditionInformationContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_NAME, 0)
}

func (s *SignalConditionInformationContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN_NAME, 0)
}

func (s *SignalConditionInformationContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURSOR_NAME, 0)
}

func (s *SignalConditionInformationContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalConditionInformationContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECIMAL_LITERAL, 0)
}

func (s *SignalConditionInformationContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *SignalConditionInformationContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SignalConditionInformationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalConditionInformationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalConditionInformationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSignalConditionInformation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SignalConditionInformation() (localctx ISignalConditionInformationContext) {
	localctx = NewSignalConditionInformationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, MariaDBParserRULE_signalConditionInformation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6355)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&272105729) != 0) || _la == MariaDBParserMESSAGE_TEXT || _la == MariaDBParserMYSQL_ERRNO || _la == MariaDBParserSUBCLASS_ORIGIN || _la == MariaDBParserTABLE_NAME || _la == MariaDBParserCATALOG_NAME || _la == MariaDBParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6356)
		p.Match(MariaDBParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6357)
			p.StringLiteral()
		}

	case 2:
		{
			p.SetState(6358)
			p.Match(MariaDBParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(6359)
			p.MysqlVariable()
		}

	case 4:
		{
			p.SetState(6360)
			p.SimpleId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiagnosticsStatementContext is an interface to support dynamic dispatch.
type IDiagnosticsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	AllVariableClause() []IVariableClauseContext
	VariableClause(i int) IVariableClauseContext
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext
	DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	AllROW_COUNT() []antlr.TerminalNode
	ROW_COUNT(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDiagnosticsStatementContext differentiates from other interfaces.
	IsDiagnosticsStatementContext()
}

type DiagnosticsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsStatementContext() *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_diagnosticsStatement
	return p
}

func InitEmptyDiagnosticsStatementContext(p *DiagnosticsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_diagnosticsStatement
}

func (*DiagnosticsStatementContext) IsDiagnosticsStatementContext() {}

func NewDiagnosticsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_diagnosticsStatement

	return p
}

func (s *DiagnosticsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsStatementContext) GET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGET, 0)
}

func (s *DiagnosticsStatementContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIAGNOSTICS, 0)
}

func (s *DiagnosticsStatementContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT, 0)
}

func (s *DiagnosticsStatementContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTACKED, 0)
}

func (s *DiagnosticsStatementContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *DiagnosticsStatementContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserEQUAL_SYMBOL)
}

func (s *DiagnosticsStatementContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, i)
}

func (s *DiagnosticsStatementContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONDITION, 0)
}

func (s *DiagnosticsStatementContext) AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			len++
		}
	}

	tst := make([]IDiagnosticsConditionInformationNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			tst[i] = t.(IDiagnosticsConditionInformationNameContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsConditionInformationNameContext)
}

func (s *DiagnosticsStatementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserNUMBER)
}

func (s *DiagnosticsStatementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMBER, i)
}

func (s *DiagnosticsStatementContext) AllROW_COUNT() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserROW_COUNT)
}

func (s *DiagnosticsStatementContext) ROW_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_COUNT, i)
}

func (s *DiagnosticsStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DiagnosticsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *DiagnosticsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *DiagnosticsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDiagnosticsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DiagnosticsStatement() (localctx IDiagnosticsStatementContext) {
	localctx = NewDiagnosticsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, MariaDBParserRULE_diagnosticsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6363)
		p.Match(MariaDBParserGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCURRENT || _la == MariaDBParserSTACKED {
		{
			p.SetState(6364)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCURRENT || _la == MariaDBParserSTACKED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6367)
		p.Match(MariaDBParserDIAGNOSTICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 946, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6368)
			p.VariableClause()
		}
		{
			p.SetState(6369)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6370)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNUMBER || _la == MariaDBParserROW_COUNT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(6371)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6372)
				p.VariableClause()
			}
			{
				p.SetState(6373)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6374)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserNUMBER || _la == MariaDBParserROW_COUNT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(6380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(6381)
			p.Match(MariaDBParserCONDITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
			{
				p.SetState(6382)
				p.DecimalLiteral()
			}

		case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserAT_SIGN, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID, MariaDBParserLOCAL_ID, MariaDBParserGLOBAL_ID:
			{
				p.SetState(6383)
				p.VariableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6386)
			p.VariableClause()
		}
		{
			p.SetState(6387)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6388)
			p.DiagnosticsConditionInformationName()
		}
		p.SetState(6396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(6389)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6390)
				p.VariableClause()
			}
			{
				p.SetState(6391)
				p.Match(MariaDBParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6392)
				p.DiagnosticsConditionInformationName()
			}

			p.SetState(6398)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiagnosticsConditionInformationNameContext is an interface to support dynamic dispatch.
type IDiagnosticsConditionInformationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode

	// IsDiagnosticsConditionInformationNameContext differentiates from other interfaces.
	IsDiagnosticsConditionInformationNameContext()
}

type DiagnosticsConditionInformationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsConditionInformationNameContext() *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_diagnosticsConditionInformationName
	return p
}

func InitEmptyDiagnosticsConditionInformationNameContext(p *DiagnosticsConditionInformationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_diagnosticsConditionInformationName
}

func (*DiagnosticsConditionInformationNameContext) IsDiagnosticsConditionInformationNameContext() {}

func NewDiagnosticsConditionInformationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_diagnosticsConditionInformationName

	return p
}

func (s *DiagnosticsConditionInformationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsConditionInformationNameContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNED_SQLSTATE, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMESSAGE_TEXT, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL_ERRNO, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_CATALOG, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_SCHEMA, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCATALOG_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURSOR_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsConditionInformationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsConditionInformationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDiagnosticsConditionInformationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DiagnosticsConditionInformationName() (localctx IDiagnosticsConditionInformationNameContext) {
	localctx = NewDiagnosticsConditionInformationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, MariaDBParserRULE_diagnosticsConditionInformationName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6401)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&272105729) != 0) || _la == MariaDBParserMESSAGE_TEXT || _la == MariaDBParserMYSQL_ERRNO || ((int64((_la-594)) & ^0x3f) == 0 && ((int64(1)<<(_la-594))&36310271995674625) != 0) || _la == MariaDBParserCATALOG_NAME || _la == MariaDBParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeObjectClauseContext is an interface to support dynamic dispatch.
type IDescribeObjectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDescribeObjectClauseContext differentiates from other interfaces.
	IsDescribeObjectClauseContext()
}

type DescribeObjectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeObjectClauseContext() *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_describeObjectClause
	return p
}

func InitEmptyDescribeObjectClauseContext(p *DescribeObjectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_describeObjectClause
}

func (*DescribeObjectClauseContext) IsDescribeObjectClauseContext() {}

func NewDescribeObjectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_describeObjectClause

	return p
}

func (s *DescribeObjectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeObjectClauseContext) CopyAll(ctx *DescribeObjectClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DescribeObjectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeObjectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeStatementsContext struct {
	DescribeObjectClauseContext
}

func NewDescribeStatementsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStatementsContext {
	var p = new(DescribeStatementsContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementsContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DescribeStatementsContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DescribeStatementsContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DescribeStatementsContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DescribeStatementsContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DescribeStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDescribeStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeConnectionContext struct {
	DescribeObjectClauseContext
}

func NewDescribeConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectionContext {
	var p = new(DescribeConnectionContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *DescribeConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *DescribeConnectionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DescribeConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDescribeConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DescribeObjectClause() (localctx IDescribeObjectClauseContext) {
	localctx = NewDescribeObjectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, MariaDBParserRULE_describeObjectClause)
	p.SetState(6413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserDELETE, MariaDBParserINSERT, MariaDBParserREPLACE, MariaDBParserSELECT, MariaDBParserUPDATE, MariaDBParserLR_BRACKET:
		localctx = NewDescribeStatementsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserSELECT, MariaDBParserLR_BRACKET:
			{
				p.SetState(6403)
				p.SelectStatement()
			}

		case MariaDBParserDELETE:
			{
				p.SetState(6404)
				p.DeleteStatement()
			}

		case MariaDBParserINSERT:
			{
				p.SetState(6405)
				p.InsertStatement()
			}

		case MariaDBParserREPLACE:
			{
				p.SetState(6406)
				p.ReplaceStatement()
			}

		case MariaDBParserUPDATE:
			{
				p.SetState(6407)
				p.UpdateStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MariaDBParserFOR:
		localctx = NewDescribeConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6410)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6411)
			p.Match(MariaDBParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6412)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullId
	return p
}

func InitEmptyFullIdContext(p *FullIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullId
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FullId() (localctx IFullIdContext) {
	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, MariaDBParserRULE_fullId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6415)
		p.Uid()
	}
	p.SetState(6419)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 949, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6416)
			p.Match(MariaDBParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 949, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6417)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6418)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullId() IFullIdContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, MariaDBParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6421)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleNameContext is an interface to support dynamic dispatch.
type IRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	Uid() IUidContext

	// IsRoleNameContext differentiates from other interfaces.
	IsRoleNameContext()
}

type RoleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleNameContext() *RoleNameContext {
	var p = new(RoleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_roleName
	return p
}

func InitEmptyRoleNameContext(p *RoleNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_roleName
}

func (*RoleNameContext) IsRoleNameContext() {}

func NewRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleNameContext {
	var p = new(RoleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_roleName

	return p
}

func (s *RoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleNameContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRoleName(s)
	}
}

func (s *RoleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRoleName(s)
	}
}

func (s *RoleNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRoleName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) RoleName() (localctx IRoleNameContext) {
	localctx = NewRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, MariaDBParserRULE_roleName)
	p.SetState(6425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 950, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6423)
			p.UserName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6424)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	AllDottedId() []IDottedIdContext
	DottedId(i int) IDottedIdContext

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullColumnName
	return p
}

func InitEmptyFullColumnNameContext(p *FullColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fullColumnName
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FullColumnName() (localctx IFullColumnNameContext) {
	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, MariaDBParserRULE_fullColumnName)
	p.SetState(6439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 954, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6427)
			p.Uid()
		}
		p.SetState(6432)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6428)
				p.DottedId()
			}
			p.SetState(6430)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 951, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6429)
					p.DottedId()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6434)
		p.MatchWildcard()

		{
			p.SetState(6435)
			p.DottedId()
		}
		p.SetState(6437)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 953, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6436)
				p.DottedId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token

	// SetSortType sets the sortType token.
	SetSortType(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnName
	return p
}

func InitEmptyIndexColumnNameContext(p *IndexColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnName
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }

func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }

func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, MariaDBParserRULE_indexColumnName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 957, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 955, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6441)
				p.Uid()
			}

		case 2:
			{
				p.SetState(6442)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(6445)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6446)
				p.DecimalLiteral()
			}
			{
				p.SetState(6447)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		{
			p.SetState(6451)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(6455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserASC || _la == MariaDBParserDESC {
		{
			p.SetState(6454)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserASC || _la == MariaDBParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserNameContext is an interface to support dynamic dispatch.
type IUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_USER_NAME() antlr.TerminalNode
	STRING_USER_NAME_MARIADB() antlr.TerminalNode
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	KeywordsCanBeId() IKeywordsCanBeIdContext
	CurrentUserExpression() ICurrentUserExpressionContext

	// IsUserNameContext differentiates from other interfaces.
	IsUserNameContext()
}

type UserNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserNameContext() *UserNameContext {
	var p = new(UserNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userName
	return p
}

func InitEmptyUserNameContext(p *UserNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userName
}

func (*UserNameContext) IsUserNameContext() {}

func NewUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserNameContext {
	var p = new(UserNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userName

	return p
}

func (s *UserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserNameContext) STRING_USER_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_USER_NAME, 0)
}

func (s *UserNameContext) STRING_USER_NAME_MARIADB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_USER_NAME_MARIADB, 0)
}

func (s *UserNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *UserNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *UserNameContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADMIN, 0)
}

func (s *UserNameContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *UserNameContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *UserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserName(s)
	}
}

func (s *UserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserName(s)
	}
}

func (s *UserNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserName() (localctx IUserNameContext) {
	localctx = NewUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, MariaDBParserRULE_userName)
	p.SetState(6464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6457)
			p.Match(MariaDBParserSTRING_USER_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6458)
			p.Match(MariaDBParserSTRING_USER_NAME_MARIADB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6459)
			p.Match(MariaDBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6460)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6461)
			p.Match(MariaDBParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6462)
			p.KeywordsCanBeId()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6463)
			p.CurrentUserExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_mysqlVariable
	return p
}

func InitEmptyMysqlVariableContext(p *MysqlVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_mysqlVariable
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMysqlVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) MysqlVariable() (localctx IMysqlVariableContext) {
	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, MariaDBParserRULE_mysqlVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6466)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserLOCAL_ID || _la == MariaDBParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	STRING_LITERAL() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, MariaDBParserRULE_charsetName)
	p.SetState(6472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 960, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6468)
			p.Match(MariaDBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6469)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6470)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6471)
			p.Match(MariaDBParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, MariaDBParserRULE_collationName)
	p.SetState(6476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 961, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6474)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6475)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CONNECT() antlr.TerminalNode

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_engineName
	return p
}

func InitEmptyEngineNameContext(p *EngineNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_engineName
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserARCHIVE, 0)
}

func (s *EngineNameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBLACKHOLE, 0)
}

func (s *EngineNameContext) CSV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCSV, 0)
}

func (s *EngineNameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFEDERATED, 0)
}

func (s *EngineNameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB, 0)
}

func (s *EngineNameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMORY, 0)
}

func (s *EngineNameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMRG_MYISAM, 0)
}

func (s *EngineNameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYISAM, 0)
}

func (s *EngineNameContext) NDB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNDB, 0)
}

func (s *EngineNameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNDBCLUSTER, 0)
}

func (s *EngineNameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTOKUDB, 0)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE_QUOTE_ID, 0)
}

func (s *EngineNameContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECT, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (s *EngineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitEngineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) EngineName() (localctx IEngineNameContext) {
	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, MariaDBParserRULE_engineName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6478)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserCONNECT || ((int64((_la-794)) & ^0x3f) == 0 && ((int64(1)<<(_la-794))&4095) != 0) || ((int64((_la-1169)) & ^0x3f) == 0 && ((int64(1)<<(_la-1169))&769) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEncryptedLiteralContext is an interface to support dynamic dispatch.
type IEncryptedLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENCRYPTED() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsEncryptedLiteralContext differentiates from other interfaces.
	IsEncryptedLiteralContext()
}

type EncryptedLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncryptedLiteralContext() *EncryptedLiteralContext {
	var p = new(EncryptedLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_encryptedLiteral
	return p
}

func InitEmptyEncryptedLiteralContext(p *EncryptedLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_encryptedLiteral
}

func (*EncryptedLiteralContext) IsEncryptedLiteralContext() {}

func NewEncryptedLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncryptedLiteralContext {
	var p = new(EncryptedLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_encryptedLiteral

	return p
}

func (s *EncryptedLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *EncryptedLiteralContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTED, 0)
}

func (s *EncryptedLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *EncryptedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptedLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncryptedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterEncryptedLiteral(s)
	}
}

func (s *EncryptedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitEncryptedLiteral(s)
	}
}

func (s *EncryptedLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitEncryptedLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) EncryptedLiteral() (localctx IEncryptedLiteralContext) {
	localctx = NewEncryptedLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, MariaDBParserRULE_encryptedLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6480)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserENCRYPTED || _la == MariaDBParserSTRING_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUuidSetContext is an interface to support dynamic dispatch.
type IUuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllCOLON_SYMB() []antlr.TerminalNode
	COLON_SYMB(i int) antlr.TerminalNode

	// IsUuidSetContext differentiates from other interfaces.
	IsUuidSetContext()
}

type UuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidSetContext() *UuidSetContext {
	var p = new(UuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uuidSet
	return p
}

func InitEmptyUuidSetContext(p *UuidSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uuidSet
}

func (*UuidSetContext) IsUuidSetContext() {}

func NewUuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidSetContext {
	var p = new(UuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_uuidSet

	return p
}

func (s *UuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidSetContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *UuidSetContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UuidSetContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserMINUS)
}

func (s *UuidSetContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, i)
}

func (s *UuidSetContext) AllCOLON_SYMB() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOLON_SYMB)
}

func (s *UuidSetContext) COLON_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLON_SYMB, i)
}

func (s *UuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUuidSet(s)
	}
}

func (s *UuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUuidSet(s)
	}
}

func (s *UuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UuidSet() (localctx IUuidSetContext) {
	localctx = NewUuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, MariaDBParserRULE_uuidSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6482)
		p.DecimalLiteral()
	}
	{
		p.SetState(6483)
		p.Match(MariaDBParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6484)
		p.DecimalLiteral()
	}
	{
		p.SetState(6485)
		p.Match(MariaDBParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6486)
		p.DecimalLiteral()
	}
	{
		p.SetState(6487)
		p.Match(MariaDBParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6488)
		p.DecimalLiteral()
	}
	{
		p.SetState(6489)
		p.Match(MariaDBParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6490)
		p.DecimalLiteral()
	}
	p.SetState(6496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MariaDBParserCOLON_SYMB {
		{
			p.SetState(6491)
			p.Match(MariaDBParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6492)
			p.DecimalLiteral()
		}
		{
			p.SetState(6493)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6494)
			p.DecimalLiteral()
		}

		p.SetState(6498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGlobalTableUid returns the globalTableUid rule contexts.
	GetGlobalTableUid() IXuidStringIdContext

	// GetQualifier returns the qualifier rule contexts.
	GetQualifier() IXuidStringIdContext

	// GetIdFormat returns the idFormat rule contexts.
	GetIdFormat() IDecimalLiteralContext

	// SetGlobalTableUid sets the globalTableUid rule contexts.
	SetGlobalTableUid(IXuidStringIdContext)

	// SetQualifier sets the qualifier rule contexts.
	SetQualifier(IXuidStringIdContext)

	// SetIdFormat sets the idFormat rule contexts.
	SetIdFormat(IDecimalLiteralContext)

	// Getter signatures
	AllXuidStringId() []IXuidStringIdContext
	XuidStringId(i int) IXuidStringIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	globalTableUid IXuidStringIdContext
	qualifier      IXuidStringIdContext
	idFormat       IDecimalLiteralContext
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xid
	return p
}

func InitEmptyXidContext(p *XidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xid
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) GetGlobalTableUid() IXuidStringIdContext { return s.globalTableUid }

func (s *XidContext) GetQualifier() IXuidStringIdContext { return s.qualifier }

func (s *XidContext) GetIdFormat() IDecimalLiteralContext { return s.idFormat }

func (s *XidContext) SetGlobalTableUid(v IXuidStringIdContext) { s.globalTableUid = v }

func (s *XidContext) SetQualifier(v IXuidStringIdContext) { s.qualifier = v }

func (s *XidContext) SetIdFormat(v IDecimalLiteralContext) { s.idFormat = v }

func (s *XidContext) AllXuidStringId() []IXuidStringIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			len++
		}
	}

	tst := make([]IXuidStringIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXuidStringIdContext); ok {
			tst[i] = t.(IXuidStringIdContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) XuidStringId(i int) IXuidStringIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXuidStringIdContext)
}

func (s *XidContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *XidContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *XidContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (s *XidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Xid() (localctx IXidContext) {
	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, MariaDBParserRULE_xid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6500)

		var _x = p.XuidStringId()

		localctx.(*XidContext).globalTableUid = _x
	}
	p.SetState(6507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMA {
		{
			p.SetState(6501)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6502)

			var _x = p.XuidStringId()

			localctx.(*XidContext).qualifier = _x
		}
		p.SetState(6505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOMMA {
			{
				p.SetState(6503)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6504)

				var _x = p.DecimalLiteral()

				localctx.(*XidContext).idFormat = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXuidStringIdContext is an interface to support dynamic dispatch.
type IXuidStringIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	AllHEXADECIMAL_LITERAL() []antlr.TerminalNode
	HEXADECIMAL_LITERAL(i int) antlr.TerminalNode

	// IsXuidStringIdContext differentiates from other interfaces.
	IsXuidStringIdContext()
}

type XuidStringIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXuidStringIdContext() *XuidStringIdContext {
	var p = new(XuidStringIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xuidStringId
	return p
}

func InitEmptyXuidStringIdContext(p *XuidStringIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_xuidStringId
}

func (*XuidStringIdContext) IsXuidStringIdContext() {}

func NewXuidStringIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XuidStringIdContext {
	var p = new(XuidStringIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_xuidStringId

	return p
}

func (s *XuidStringIdContext) GetParser() antlr.Parser { return s.parser }

func (s *XuidStringIdContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *XuidStringIdContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_STRING, 0)
}

func (s *XuidStringIdContext) AllHEXADECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserHEXADECIMAL_LITERAL)
}

func (s *XuidStringIdContext) HEXADECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserHEXADECIMAL_LITERAL, i)
}

func (s *XuidStringIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XuidStringIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XuidStringIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterXuidStringId(s)
	}
}

func (s *XuidStringIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitXuidStringId(s)
	}
}

func (s *XuidStringIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitXuidStringId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) XuidStringId() (localctx IXuidStringIdContext) {
	localctx = NewXuidStringIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, MariaDBParserRULE_xuidStringId)
	var _la int

	p.SetState(6516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6509)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6510)
			p.Match(MariaDBParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserHEXADECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserHEXADECIMAL_LITERAL {
			{
				p.SetState(6511)
				p.Match(MariaDBParserHEXADECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(6514)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthPluginContext is an interface to support dynamic dispatch.
type IAuthPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsAuthPluginContext differentiates from other interfaces.
	IsAuthPluginContext()
}

type AuthPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthPluginContext() *AuthPluginContext {
	var p = new(AuthPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_authPlugin
	return p
}

func InitEmptyAuthPluginContext(p *AuthPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_authPlugin
}

func (*AuthPluginContext) IsAuthPluginContext() {}

func NewAuthPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthPluginContext {
	var p = new(AuthPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_authPlugin

	return p
}

func (s *AuthPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AuthPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AuthPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAuthPlugin(s)
	}
}

func (s *AuthPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAuthPlugin(s)
	}
}

func (s *AuthPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAuthPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AuthPlugin() (localctx IAuthPluginContext) {
	localctx = NewAuthPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, MariaDBParserRULE_authPlugin)
	p.SetState(6520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 967, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6518)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6519)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uid
	return p
}

func InitEmptyUidContext(p *UidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uid
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, MariaDBParserRULE_uid)
	p.SetState(6525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 968, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6522)
			p.SimpleId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6523)
			p.Match(MariaDBParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6524)
			p.Match(MariaDBParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineName() IEngineNameContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, MariaDBParserRULE_simpleId)
	p.SetState(6536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 969, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6527)
			p.Match(MariaDBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6528)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6529)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6530)
			p.EngineName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6531)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6532)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6533)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6534)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6535)
			p.ScalarFunctionName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Uid() IUidContext

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dottedId
	return p
}

func InitEmptyDottedIdContext(p *DottedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dottedId
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DottedId() (localctx IDottedIdContext) {
	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, MariaDBParserRULE_dottedId)
	p.SetState(6541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6538)
			p.Match(MariaDBParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6539)
			p.Match(MariaDBParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6540)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	TWO_DECIMAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, MariaDBParserRULE_decimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6543)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1159)) & ^0x3f) == 0 && ((int64(1)<<(_la-1159))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILESIZE_LITERAL() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fileSizeLiteral
	return p
}

func InitEmptyFileSizeLiteralContext(p *FileSizeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_fileSizeLiteral
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFileSizeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, MariaDBParserRULE_fileSizeLiteral)
	p.SetState(6547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6545)
			p.Match(MariaDBParserFILESIZE_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserZERO_DECIMAL, MariaDBParserONE_DECIMAL, MariaDBParserTWO_DECIMAL, MariaDBParserDECIMAL_LITERAL, MariaDBParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6546)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	START_NATIONAL_STRING_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, MariaDBParserRULE_stringLiteral)
	var _la int

	var _alt int

	p.SetState(6572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 978, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserSTRING_LITERAL, MariaDBParserSTRING_CHARSET_NAME:
			p.SetState(6550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserSTRING_CHARSET_NAME {
				{
					p.SetState(6549)
					p.Match(MariaDBParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6552)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6553)
				p.Match(MariaDBParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6556)
					p.Match(MariaDBParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6559)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 974, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MariaDBParserSTRING_LITERAL, MariaDBParserSTRING_CHARSET_NAME:
			p.SetState(6562)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MariaDBParserSTRING_CHARSET_NAME {
				{
					p.SetState(6561)
					p.Match(MariaDBParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6564)
				p.Match(MariaDBParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MariaDBParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6565)
				p.Match(MariaDBParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6570)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 977, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6568)
				p.Match(MariaDBParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6569)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, MariaDBParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6574)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserFALSE || _la == MariaDBParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, MariaDBParserRULE_hexadecimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserSTRING_CHARSET_NAME {
		{
			p.SetState(6576)
			p.Match(MariaDBParserSTRING_CHARSET_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6579)
		p.Match(MariaDBParserHEXADECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_nullNotnull
	return p
}

func InitEmptyNullNotnullContext(p *NullNotnullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_nullNotnull
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (s *NullNotnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNullNotnull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) NullNotnull() (localctx INullNotnullContext) {
	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, MariaDBParserRULE_nullNotnull)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserNOT {
		{
			p.SetState(6581)
			p.Match(MariaDBParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6584)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserNULL_LITERAL || _la == MariaDBParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token

	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token)

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	MINUS() antlr.TerminalNode
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }

func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, MariaDBParserRULE_constant)
	var _la int

	p.SetState(6598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 982, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6586)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6587)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6588)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6589)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6590)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6591)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6592)
			p.Match(MariaDBParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6593)
			p.Match(MariaDBParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(6595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNOT {
			{
				p.SetState(6594)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6597)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNULL_LITERAL || _la == MariaDBParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSpatialDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarbinaryDataTypeContext struct {
	DataTypeContext
}

func NewLongVarbinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarbinaryDataTypeContext {
	var p = new(LongVarbinaryDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarbinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarbinaryDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLONG, 0)
}

func (s *LongVarbinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARBINARY, 0)
}

func (s *LongVarbinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLongVarbinaryDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewCollectionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionDataTypeContext {
	var p = new(CollectionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *CollectionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *CollectionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *CollectionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *CollectionDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENUM, 0)
}

func (s *CollectionDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET, 0)
}

func (s *CollectionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *CollectionDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CollectionDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CollectionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCollectionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalVaryingStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalVaryingStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalVaryingStringDataTypeContext {
	var p = new(NationalVaryingStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *NationalVaryingStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalVaryingStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalVaryingStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalVaryingStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNATIONAL, 0)
}

func (s *NationalVaryingStringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARYING, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *NationalVaryingStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalVaryingStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *NationalVaryingStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNationalVaryingStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DimensionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewDimensionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DimensionDataTypeContext {
	var p = new(DimensionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *DimensionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *DimensionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *DimensionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTINYINT, 0)
}

func (s *DimensionDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSMALLINT, 0)
}

func (s *DimensionDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEDIUMINT, 0)
}

func (s *DimensionDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT, 0)
}

func (s *DimensionDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTEGER, 0)
}

func (s *DimensionDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIGINT, 0)
}

func (s *DimensionDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIDDLEINT, 0)
}

func (s *DimensionDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT1, 0)
}

func (s *DimensionDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT2, 0)
}

func (s *DimensionDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT3, 0)
}

func (s *DimensionDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT4, 0)
}

func (s *DimensionDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT8, 0)
}

func (s *DimensionDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *DimensionDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSIGNED)
}

func (s *DimensionDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIGNED, i)
}

func (s *DimensionDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserUNSIGNED)
}

func (s *DimensionDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNSIGNED, i)
}

func (s *DimensionDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserZEROFILL)
}

func (s *DimensionDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserZEROFILL, i)
}

func (s *DimensionDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAL, 0)
}

func (s *DimensionDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *DimensionDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDOUBLE, 0)
}

func (s *DimensionDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRECISION, 0)
}

func (s *DimensionDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECIMAL, 0)
}

func (s *DimensionDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEC, 0)
}

func (s *DimensionDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIXED, 0)
}

func (s *DimensionDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMERIC, 0)
}

func (s *DimensionDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLOAT, 0)
}

func (s *DimensionDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLOAT4, 0)
}

func (s *DimensionDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLOAT8, 0)
}

func (s *DimensionDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *DimensionDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT, 0)
}

func (s *DimensionDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME, 0)
}

func (s *DimensionDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMESTAMP, 0)
}

func (s *DimensionDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATETIME, 0)
}

func (s *DimensionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *DimensionDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARBINARY, 0)
}

func (s *DimensionDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBLOB, 0)
}

func (s *DimensionDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEAR, 0)
}

func (s *DimensionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDimensionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

func (s *StringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarcharDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewLongVarcharDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarcharDataTypeContext {
	var p = new(LongVarcharDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarcharDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *LongVarcharDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *LongVarcharDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarcharDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLONG, 0)
}

func (s *LongVarcharDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARCHAR, 0)
}

func (s *LongVarcharDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *LongVarcharDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *LongVarcharDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LongVarcharDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *LongVarcharDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *LongVarcharDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLongVarcharDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalStringDataTypeContext {
	var p = new(NationalStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *NationalStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNATIONAL, 0)
}

func (s *NationalStringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARCHAR, 0)
}

func (s *NationalStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER, 0)
}

func (s *NationalStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *NationalStringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNCHAR, 0)
}

func (s *NationalStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNationalStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSimpleDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleDataTypeContext {
	var p = new(SimpleDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SimpleDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SimpleDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SimpleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE, 0)
}

func (s *SimpleDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTINYBLOB, 0)
}

func (s *SimpleDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEDIUMBLOB, 0)
}

func (s *SimpleDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLONGBLOB, 0)
}

func (s *SimpleDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBOOL, 0)
}

func (s *SimpleDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBOOLEAN, 0)
}

func (s *SimpleDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERIAL, 0)
}

func (s *SimpleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, MariaDBParserRULE_dataType)
	var _la int

	var _alt int

	p.SetState(6722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1010, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6600)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCHARACTER || ((int64((_la-222)) & ^0x3f) == 0 && ((int64(1)<<(_la-222))&31239) != 0) || _la == MariaDBParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVARYING {
			{
				p.SetState(6601)
				p.Match(MariaDBParserVARYING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6605)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 984, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6604)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6608)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 985, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6607)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6613)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 986, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6610)
				p.CharSet()
			}
			{
				p.SetState(6611)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 987, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6615)
				p.Match(MariaDBParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6616)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 987, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6617)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6620)
			p.Match(MariaDBParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6621)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCHARACTER || _la == MariaDBParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6623)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 988, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6622)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6626)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 989, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6625)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6628)
			p.Match(MariaDBParserNCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6629)

			var _m = p.Match(MariaDBParserVARCHAR)

			localctx.(*NationalStringDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6631)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 990, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6630)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6634)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 991, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6633)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewNationalVaryingStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6636)
			p.Match(MariaDBParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6637)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalVaryingStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCHARACTER || _la == MariaDBParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalVaryingStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6638)
			p.Match(MariaDBParserVARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6640)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 992, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6639)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6643)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 993, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6642)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6645)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&4095) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6647)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 994, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6646)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 995, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6649)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserUNSIGNED || _la == MariaDBParserZEROFILL || _la == MariaDBParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6654)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 995, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 6:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6655)

			var _m = p.Match(MariaDBParserREAL)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 996, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6656)
				p.LengthTwoDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 997, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6659)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserUNSIGNED || _la == MariaDBParserZEROFILL || _la == MariaDBParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6664)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 997, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 7:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6665)

			var _m = p.Match(MariaDBParserDOUBLE)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserPRECISION {
			{
				p.SetState(6666)
				p.Match(MariaDBParserPRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6670)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 999, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6669)
				p.LengthTwoDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1000, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6672)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserUNSIGNED || _la == MariaDBParserZEROFILL || _la == MariaDBParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1000, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 8:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6678)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&63) != 0) || _la == MariaDBParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6680)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1001, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6679)
				p.LengthTwoOptionalDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1002, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6682)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserUNSIGNED || _la == MariaDBParserZEROFILL || _la == MariaDBParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1002, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 9:
		localctx = NewSimpleDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6688)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&4237313) != 0) || _la == MariaDBParserBOOL || _la == MariaDBParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6689)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-218)) & ^0x3f) == 0 && ((int64(1)<<(_la-218))&2831) != 0) || _la == MariaDBParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6691)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1003, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6690)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		localctx = NewCollectionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6693)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CollectionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSET || _la == MariaDBParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CollectionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6694)
			p.CollectionOptions()
		}
		p.SetState(6696)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1004, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6695)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6701)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1005, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6698)
				p.CharSet()
			}
			{
				p.SetState(6699)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6703)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserJSON || ((int64((_la-810)) & ^0x3f) == 0 && ((int64(1)<<(_la-810))&511) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		localctx = NewLongVarcharDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6704)

			var _m = p.Match(MariaDBParserLONG)

			localctx.(*LongVarcharDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserVARCHAR {
			{
				p.SetState(6705)
				p.Match(MariaDBParserVARCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6709)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1007, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6708)
				p.Match(MariaDBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6714)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1008, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6711)
				p.CharSet()
			}
			{
				p.SetState(6712)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6718)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1009, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6716)
				p.Match(MariaDBParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6717)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewLongVarbinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6720)
			p.Match(MariaDBParserLONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6721)
			p.Match(MariaDBParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_collectionOptions
	return p
}

func InitEmptyCollectionOptionsContext(p *CollectionOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_collectionOptions
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCollectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, MariaDBParserRULE_collectionOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6724)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6725)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6726)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6727)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6733)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token

	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token)

	// Getter signatures
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	JSON() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_convertedDataType
	return p
}

func InitEmptyConvertedDataTypeContext(p *ConvertedDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_convertedDataType
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitConvertedDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, MariaDBParserRULE_convertedDataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserBINARY, MariaDBParserNCHAR:
		{
			p.SetState(6735)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserBINARY || _la == MariaDBParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(6736)
				p.LengthOneDimension()
			}

		}

	case MariaDBParserCHAR:
		{
			p.SetState(6739)

			var _m = p.Match(MariaDBParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(6740)
				p.LengthOneDimension()
			}

		}
		p.SetState(6746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCHARACTER || _la == MariaDBParserCHAR || _la == MariaDBParserCHARSET {
			{
				p.SetState(6743)
				p.CharSet()
			}
			{
				p.SetState(6744)
				p.CharsetName()
			}

		}

	case MariaDBParserINT, MariaDBParserINTEGER, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserDATETIME, MariaDBParserJSON:
		{
			p.SetState(6748)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&1441857) != 0) || _la == MariaDBParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MariaDBParserDECIMAL:
		{
			p.SetState(6749)

			var _m = p.Match(MariaDBParserDECIMAL)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLR_BRACKET {
			{
				p.SetState(6750)
				p.LengthTwoOptionalDimension()
			}

		}

	case MariaDBParserUNSIGNED, MariaDBParserSIGNED:
		{
			p.SetState(6753)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserUNSIGNED || _la == MariaDBParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserINTEGER {
			{
				p.SetState(6754)
				p.Match(MariaDBParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserARRAY {
		{
			p.SetState(6759)
			p.Match(MariaDBParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthOneDimension
	return p
}

func InitEmptyLengthOneDimensionContext(p *LengthOneDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthOneDimension
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLengthOneDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, MariaDBParserRULE_lengthOneDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6762)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6763)
		p.DecimalLiteral()
	}
	{
		p.SetState(6764)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthTwoDimension
	return p
}

func InitEmptyLengthTwoDimensionContext(p *LengthTwoDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthTwoDimension
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLengthTwoDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, MariaDBParserRULE_lengthTwoDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6766)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6767)
		p.DecimalLiteral()
	}
	{
		p.SetState(6768)
		p.Match(MariaDBParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6769)
		p.DecimalLiteral()
	}
	{
		p.SetState(6770)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthTwoOptionalDimension
	return p
}

func InitEmptyLengthTwoOptionalDimensionContext(p *LengthTwoOptionalDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lengthTwoOptionalDimension
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLengthTwoOptionalDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, MariaDBParserRULE_lengthTwoOptionalDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6772)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6773)
		p.DecimalLiteral()
	}
	p.SetState(6776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserCOMMA {
		{
			p.SetState(6774)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6775)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(6778)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uidList
	return p
}

func InitEmptyUidListContext(p *UidListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_uidList
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (s *UidListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUidList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UidList() (localctx IUidListContext) {
	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, MariaDBParserRULE_uidList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6780)
		p.Uid()
	}
	p.SetState(6785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1020, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6781)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6782)
				p.Uid()
			}

		}
		p.SetState(6787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1020, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tables
	return p
}

func InitEmptyTablesContext(p *TablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_tables
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (s *TablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Tables() (localctx ITablesContext) {
	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, MariaDBParserRULE_tables)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6788)
		p.TableName()
	}
	p.SetState(6793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6789)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6790)
				p.TableName()
			}

		}
		p.SetState(6795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllIndexColumnName() []IIndexColumnNameContext
	IndexColumnName(i int) IIndexColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnNames
	return p
}

func InitEmptyIndexColumnNamesContext(p *IndexColumnNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_indexColumnNames
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIndexColumnNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, MariaDBParserRULE_indexColumnNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6796)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6797)
		p.IndexColumnName()
	}
	p.SetState(6802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6798)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6799)
			p.IndexColumnName()
		}

		p.SetState(6804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6805)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressions
	return p
}

func InitEmptyExpressionsContext(p *ExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressions
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, MariaDBParserRULE_expressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6807)
		p.expression(0)
	}
	p.SetState(6812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6808)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6809)
			p.expression(0)
		}

		p.SetState(6814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultsContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsWithDefaultsContext differentiates from other interfaces.
	IsExpressionsWithDefaultsContext()
}

type ExpressionsWithDefaultsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultsContext() *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionsWithDefaults
	return p
}

func InitEmptyExpressionsWithDefaultsContext(p *ExpressionsWithDefaultsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionsWithDefaults
}

func (*ExpressionsWithDefaultsContext) IsExpressionsWithDefaultsContext() {}

func NewExpressionsWithDefaultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_expressionsWithDefaults

	return p
}

func (s *ExpressionsWithDefaultsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultsContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultsContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ExpressionsWithDefaultsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ExpressionsWithDefaultsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExpressionsWithDefaults(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ExpressionsWithDefaults() (localctx IExpressionsWithDefaultsContext) {
	localctx = NewExpressionsWithDefaultsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, MariaDBParserRULE_expressionsWithDefaults)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6815)
		p.ExpressionOrDefault()
	}
	p.SetState(6820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6816)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6817)
			p.ExpressionOrDefault()
		}

		p.SetState(6822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantsContext is an interface to support dynamic dispatch.
type IConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstantsContext differentiates from other interfaces.
	IsConstantsContext()
}

type ConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantsContext() *ConstantsContext {
	var p = new(ConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_constants
	return p
}

func InitEmptyConstantsContext(p *ConstantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_constants
}

func (*ConstantsContext) IsConstantsContext() {}

func NewConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantsContext {
	var p = new(ConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_constants

	return p
}

func (s *ConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *ConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *ConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterConstants(s)
	}
}

func (s *ConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitConstants(s)
	}
}

func (s *ConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Constants() (localctx IConstantsContext) {
	localctx = NewConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, MariaDBParserRULE_constants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6823)
		p.Constant()
	}
	p.SetState(6828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6824)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6825)
			p.Constant()
		}

		p.SetState(6830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStringsContext is an interface to support dynamic dispatch.
type ISimpleStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleStringsContext differentiates from other interfaces.
	IsSimpleStringsContext()
}

type SimpleStringsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStringsContext() *SimpleStringsContext {
	var p = new(SimpleStringsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleStrings
	return p
}

func InitEmptySimpleStringsContext(p *SimpleStringsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_simpleStrings
}

func (*SimpleStringsContext) IsSimpleStringsContext() {}

func NewSimpleStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStringsContext {
	var p = new(SimpleStringsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_simpleStrings

	return p
}

func (s *SimpleStringsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStringsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserSTRING_LITERAL)
}

func (s *SimpleStringsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, i)
}

func (s *SimpleStringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *SimpleStringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *SimpleStringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleStrings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SimpleStrings() (localctx ISimpleStringsContext) {
	localctx = NewSimpleStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, MariaDBParserRULE_simpleStrings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6831)
		p.Match(MariaDBParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6832)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6833)
			p.Match(MariaDBParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariablesContext is an interface to support dynamic dispatch.
type IUserVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOCAL_ID() []antlr.TerminalNode
	LOCAL_ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUserVariablesContext differentiates from other interfaces.
	IsUserVariablesContext()
}

type UserVariablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariablesContext() *UserVariablesContext {
	var p = new(UserVariablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userVariables
	return p
}

func InitEmptyUserVariablesContext(p *UserVariablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_userVariables
}

func (*UserVariablesContext) IsUserVariablesContext() {}

func NewUserVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariablesContext {
	var p = new(UserVariablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_userVariables

	return p
}

func (s *UserVariablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariablesContext) AllLOCAL_ID() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLOCAL_ID)
}

func (s *UserVariablesContext) LOCAL_ID(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, i)
}

func (s *UserVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *UserVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *UserVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUserVariables(s)
	}
}

func (s *UserVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUserVariables(s)
	}
}

func (s *UserVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUserVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UserVariables() (localctx IUserVariablesContext) {
	localctx = NewUserVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, MariaDBParserRULE_userVariables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6839)
		p.Match(MariaDBParserLOCAL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(6840)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6841)
			p.Match(MariaDBParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	CAST() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	ConvertedDataType() IConvertedDataTypeContext
	RR_BRACKET() antlr.TerminalNode
	Constant() IConstantContext
	UnaryOperator() IUnaryOperatorContext
	AllCurrentTimestamp() []ICurrentTimestampContext
	CurrentTimestamp(i int) ICurrentTimestampContext
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	FullId() IFullIdContext
	LASTVAL() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	FOR() antlr.TerminalNode
	PREVIOUS() antlr.TerminalNode
	NEXT() antlr.TerminalNode

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCAST, 0)
}

func (s *DefaultValueContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLASTVAL, 0)
}

func (s *DefaultValueContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXTVAL, 0)
}

func (s *DefaultValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *DefaultValueContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *DefaultValueContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREVIOUS, 0)
}

func (s *DefaultValueContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXT, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, MariaDBParserRULE_defaultValue)
	var _la int

	p.SetState(6882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1030, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6847)
			p.Match(MariaDBParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6848)
			p.Match(MariaDBParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6849)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6850)
			p.expression(0)
		}
		{
			p.SetState(6851)
			p.Match(MariaDBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6852)
			p.ConvertedDataType()
		}
		{
			p.SetState(6853)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6856)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1028, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6855)
				p.UnaryOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6858)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6859)
			p.CurrentTimestamp()
		}
		p.SetState(6863)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1029, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6860)
				p.Match(MariaDBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6861)
				p.Match(MariaDBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6862)
				p.CurrentTimestamp()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6865)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6866)
			p.expression(0)
		}
		{
			p.SetState(6867)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6869)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLASTVAL || _la == MariaDBParserNEXTVAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6870)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6871)
			p.FullId()
		}
		{
			p.SetState(6872)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6874)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6875)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNEXT || _la == MariaDBParserPREVIOUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6876)
			p.Match(MariaDBParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6877)
			p.Match(MariaDBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6878)
			p.FullId()
		}
		{
			p.SetState(6879)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6881)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_currentTimestamp
	return p
}

func InitEmptyCurrentTimestampContext(p *CurrentTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_currentTimestamp
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURDATE, 0)
}

func (s *CurrentTimestampContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURTIME, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCurrentTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, MariaDBParserRULE_currentTimestamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserLOCALTIMESTAMP:
		{
			p.SetState(6884)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-315)) & ^0x3f) == 0 && ((int64(1)<<(_la-315))&143) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6890)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1032, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6885)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-1159)) & ^0x3f) == 0 && ((int64(1)<<(_la-1159))&10247) != 0 {
				{
					p.SetState(6886)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(6889)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserNOW:
		{
			p.SetState(6892)
			p.Match(MariaDBParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6893)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-1159)) & ^0x3f) == 0 && ((int64(1)<<(_la-1159))&10247) != 0 {
			{
				p.SetState(6894)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(6897)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, MariaDBParserRULE_expressionOrDefault)
	p.SetState(6902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1035, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6900)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6901)
			p.Match(MariaDBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIF, 0)
}

func (s *IfExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, MariaDBParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6904)
		p.Match(MariaDBParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6905)
		p.Match(MariaDBParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, MariaDBParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6907)
		p.Match(MariaDBParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6908)
		p.Match(MariaDBParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6909)
		p.Match(MariaDBParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, MariaDBParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6911)
		p.Match(MariaDBParserOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6912)
		p.Match(MariaDBParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWaitNowaitClauseContext is an interface to support dynamic dispatch.
type IWaitNowaitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	NOWAIT() antlr.TerminalNode

	// IsWaitNowaitClauseContext differentiates from other interfaces.
	IsWaitNowaitClauseContext()
}

type WaitNowaitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitNowaitClauseContext() *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_waitNowaitClause
	return p
}

func InitEmptyWaitNowaitClauseContext(p *WaitNowaitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_waitNowaitClause
}

func (*WaitNowaitClauseContext) IsWaitNowaitClauseContext() {}

func NewWaitNowaitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_waitNowaitClause

	return p
}

func (s *WaitNowaitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitNowaitClauseContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *WaitNowaitClauseContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WaitNowaitClauseContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOWAIT, 0)
}

func (s *WaitNowaitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitNowaitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitNowaitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWaitNowaitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WaitNowaitClause() (localctx IWaitNowaitClauseContext) {
	localctx = NewWaitNowaitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, MariaDBParserRULE_waitNowaitClause)
	p.SetState(6917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6914)
			p.Match(MariaDBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6915)
			p.DecimalLiteral()
		}

	case MariaDBParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6916)
			p.Match(MariaDBParserNOWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockOptionContext is an interface to support dynamic dispatch.
type ILockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WaitNowaitClause() IWaitNowaitClauseContext
	SKIP_() antlr.TerminalNode
	LOCKED() antlr.TerminalNode

	// IsLockOptionContext differentiates from other interfaces.
	IsLockOptionContext()
}

type LockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockOptionContext() *LockOptionContext {
	var p = new(LockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockOption
	return p
}

func InitEmptyLockOptionContext(p *LockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_lockOption
}

func (*LockOptionContext) IsLockOptionContext() {}

func NewLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockOptionContext {
	var p = new(LockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_lockOption

	return p
}

func (s *LockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockOptionContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *LockOptionContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSKIP_, 0)
}

func (s *LockOptionContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCKED, 0)
}

func (s *LockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLockOption(s)
	}
}

func (s *LockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLockOption(s)
	}
}

func (s *LockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LockOption() (localctx ILockOptionContext) {
	localctx = NewLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, MariaDBParserRULE_lockOption)
	p.SetState(6922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserNOWAIT, MariaDBParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6919)
			p.WaitNowaitClause()
		}

	case MariaDBParserSKIP_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6920)
			p.Match(MariaDBParserSKIP_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6921)
			p.Match(MariaDBParserLOCKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecificFunctionCallContext struct {
	FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext {
	var p = new(SpecificFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecificFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecificFunctionContext)
}

func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSpecificFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type PasswordFunctionCallContext struct {
	FunctionCallContext
}

func NewPasswordFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordFunctionCallContext {
	var p = new(PasswordFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *PasswordFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionCallContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPasswordFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type UdfFunctionCallContext struct {
	FunctionCallContext
}

func NewUdfFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UdfFunctionCallContext {
	var p = new(UdfFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *UdfFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfFunctionCallContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *UdfFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *UdfFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUdfFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type NonAggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewNonAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonAggregateFunctionCallContext {
	var p = new(NonAggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *NonAggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateFunctionCallContext) NonAggregateWindowedFunction() INonAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonAggregateWindowedFunctionContext)
}

func (s *NonAggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNonAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarFunctionCallContext struct {
	FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext {
	var p = new(ScalarFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionCallContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitScalarFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, MariaDBParserRULE_functionCall)
	p.SetState(6942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1040, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSpecificFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6924)
			p.SpecificFunction()
		}

	case 2:
		localctx = NewAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6925)
			p.AggregateWindowedFunction()
		}

	case 3:
		localctx = NewNonAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6926)
			p.NonAggregateWindowedFunction()
		}

	case 4:
		localctx = NewScalarFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6927)
			p.ScalarFunctionName()
		}
		{
			p.SetState(6928)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6930)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1038, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6929)
				p.FunctionArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6932)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewUdfFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6934)
			p.FullId()
		}
		{
			p.SetState(6935)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6937)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1039, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6936)
				p.FunctionArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6939)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewPasswordFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6941)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSpecificFunctionContext differentiates from other interfaces.
	IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_specificFunction
	return p
}

func InitEmptySpecificFunctionContext(p *SpecificFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_specificFunction
}

func (*SpecificFunctionContext) IsSpecificFunctionContext() {}

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_specificFunction

	return p
}

func (s *SpecificFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificFunctionContext) CopyAll(ctx *SpecificFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionFunctionCallContext struct {
	SpecificFunctionContext
	positionString     IStringLiteralContext
	positionExpression IExpressionContext
	inString           IStringLiteralContext
	inExpression       IExpressionContext
}

func NewPositionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionFunctionCallContext {
	var p = new(PositionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *PositionFunctionCallContext) GetPositionString() IStringLiteralContext {
	return s.positionString
}

func (s *PositionFunctionCallContext) GetPositionExpression() IExpressionContext {
	return s.positionExpression
}

func (s *PositionFunctionCallContext) GetInString() IStringLiteralContext { return s.inString }

func (s *PositionFunctionCallContext) GetInExpression() IExpressionContext { return s.inExpression }

func (s *PositionFunctionCallContext) SetPositionString(v IStringLiteralContext) {
	s.positionString = v
}

func (s *PositionFunctionCallContext) SetPositionExpression(v IExpressionContext) {
	s.positionExpression = v
}

func (s *PositionFunctionCallContext) SetInString(v IStringLiteralContext) { s.inString = v }

func (s *PositionFunctionCallContext) SetInExpression(v IExpressionContext) { s.inExpression = v }

func (s *PositionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionCallContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOSITION, 0)
}

func (s *PositionFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *PositionFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PositionFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPositionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type TrimFunctionCallContext struct {
	SpecificFunctionContext
	positioinForm    antlr.Token
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromString       IStringLiteralContext
	fromExpression   IExpressionContext
}

func NewTrimFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimFunctionCallContext {
	var p = new(TrimFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *TrimFunctionCallContext) GetPositioinForm() antlr.Token { return s.positioinForm }

func (s *TrimFunctionCallContext) SetPositioinForm(v antlr.Token) { s.positioinForm = v }

func (s *TrimFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *TrimFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *TrimFunctionCallContext) GetFromString() IStringLiteralContext { return s.fromString }

func (s *TrimFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *TrimFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *TrimFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *TrimFunctionCallContext) SetFromString(v IStringLiteralContext) { s.fromString = v }

func (s *TrimFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *TrimFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionCallContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIM, 0)
}

func (s *TrimFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *TrimFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) BOTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBOTH, 0)
}

func (s *TrimFunctionCallContext) LEADING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEADING, 0)
}

func (s *TrimFunctionCallContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRAILING, 0)
}

func (s *TrimFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TrimFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TrimFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTrimFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonValueFunctionCallContext struct {
	SpecificFunctionContext
}

func NewJsonValueFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonValueFunctionCallContext {
	var p = new(JsonValueFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *JsonValueFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueFunctionCallContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_VALUE, 0)
}

func (s *JsonValueFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JsonValueFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *JsonValueFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNING, 0)
}

func (s *JsonValueFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *JsonValueFunctionCallContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonValueFunctionCallContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonValueFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonValueFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext {
	var p = new(CaseFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASE, 0)
}

func (s *CaseFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELSE, 0)
}

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCaseFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractFunctionCallContext struct {
	SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
}

func NewExtractFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractFunctionCallContext {
	var p = new(ExtractFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ExtractFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *ExtractFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *ExtractFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *ExtractFunctionCallContext) SetSourceExpression(v IExpressionContext) {
	s.sourceExpression = v
}

func (s *ExtractFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionCallContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTRACT, 0)
}

func (s *ExtractFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *ExtractFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *ExtractFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ExtractFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExtractFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type DataTypeFunctionCallContext struct {
	SpecificFunctionContext
	separator antlr.Token
}

func NewDataTypeFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataTypeFunctionCallContext {
	var p = new(DataTypeFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *DataTypeFunctionCallContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataTypeFunctionCallContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataTypeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeFunctionCallContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONVERT, 0)
}

func (s *DataTypeFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataTypeFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DataTypeFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *DataTypeFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *DataTypeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DataTypeFunctionCallContext) CAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCAST, 0)
}

func (s *DataTypeFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *DataTypeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDataTypeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ValuesFunctionCallContext struct {
	SpecificFunctionContext
}

func NewValuesFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesFunctionCallContext {
	var p = new(ValuesFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ValuesFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesFunctionCallContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUES, 0)
}

func (s *ValuesFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ValuesFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitValuesFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseExpressionFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseExpressionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionFunctionCallContext {
	var p = new(CaseExpressionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseExpressionFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseExpressionFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseExpressionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASE, 0)
}

func (s *CaseExpressionFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *CaseExpressionFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseExpressionFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELSE, 0)
}

func (s *CaseExpressionFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseExpressionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCaseExpressionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	SpecificFunctionContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_DATE, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURDATE, 0)
}

func (s *SimpleFunctionCallContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURTIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_USER, 0)
}

func (s *SimpleFunctionCallContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALTIME, 0)
}

func (s *SimpleFunctionCallContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTC_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *SimpleFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CharFunctionCallContext struct {
	SpecificFunctionContext
}

func NewCharFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionCallContext {
	var p = new(CharFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CharFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *CharFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *CharFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *CharFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *CharFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSING, 0)
}

func (s *CharFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCharFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type WeightFunctionCallContext struct {
	SpecificFunctionContext
	stringFormat antlr.Token
}

func NewWeightFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WeightFunctionCallContext {
	var p = new(WeightFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *WeightFunctionCallContext) GetStringFormat() antlr.Token { return s.stringFormat }

func (s *WeightFunctionCallContext) SetStringFormat(v antlr.Token) { s.stringFormat = v }

func (s *WeightFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightFunctionCallContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEIGHT_STRING, 0)
}

func (s *WeightFunctionCallContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLR_BRACKET)
}

func (s *WeightFunctionCallContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, i)
}

func (s *WeightFunctionCallContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserRR_BRACKET)
}

func (s *WeightFunctionCallContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, i)
}

func (s *WeightFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *WeightFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WeightFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAS, 0)
}

func (s *WeightFunctionCallContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WeightFunctionCallContext) LevelsInWeightString() ILevelsInWeightStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelsInWeightStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelsInWeightStringContext)
}

func (s *WeightFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR, 0)
}

func (s *WeightFunctionCallContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *WeightFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWeightFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GetFormatFunctionCallContext struct {
	SpecificFunctionContext
	datetimeFormat antlr.Token
}

func NewGetFormatFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetFormatFunctionCallContext {
	var p = new(GetFormatFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *GetFormatFunctionCallContext) GetDatetimeFormat() antlr.Token { return s.datetimeFormat }

func (s *GetFormatFunctionCallContext) SetDatetimeFormat(v antlr.Token) { s.datetimeFormat = v }

func (s *GetFormatFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetFormatFunctionCallContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGET_FORMAT, 0)
}

func (s *GetFormatFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, 0)
}

func (s *GetFormatFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *GetFormatFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE, 0)
}

func (s *GetFormatFunctionCallContext) TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME, 0)
}

func (s *GetFormatFunctionCallContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATETIME, 0)
}

func (s *GetFormatFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitGetFormatFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstrFunctionCallContext struct {
	SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromDecimal      IDecimalLiteralContext
	fromExpression   IExpressionContext
	forDecimal       IDecimalLiteralContext
	forExpression    IExpressionContext
}

func NewSubstrFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstrFunctionCallContext {
	var p = new(SubstrFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SubstrFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *SubstrFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *SubstrFunctionCallContext) GetFromDecimal() IDecimalLiteralContext { return s.fromDecimal }

func (s *SubstrFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *SubstrFunctionCallContext) GetForDecimal() IDecimalLiteralContext { return s.forDecimal }

func (s *SubstrFunctionCallContext) GetForExpression() IExpressionContext { return s.forExpression }

func (s *SubstrFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *SubstrFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *SubstrFunctionCallContext) SetFromDecimal(v IDecimalLiteralContext) { s.fromDecimal = v }

func (s *SubstrFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *SubstrFunctionCallContext) SetForDecimal(v IDecimalLiteralContext) { s.forDecimal = v }

func (s *SubstrFunctionCallContext) SetForExpression(v IExpressionContext) { s.forExpression = v }

func (s *SubstrFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstrFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM, 0)
}

func (s *SubstrFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBSTR, 0)
}

func (s *SubstrFunctionCallContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBSTRING, 0)
}

func (s *SubstrFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SubstrFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubstrFunctionCallContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SubstrFunctionCallContext) FOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOR, 0)
}

func (s *SubstrFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubstrFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) SpecificFunction() (localctx ISpecificFunctionContext) {
	localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, MariaDBParserRULE_specificFunction)
	var _la int

	p.SetState(7122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1064, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6944)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserCURRENT_USER || _la == MariaDBParserSCHEMA || ((int64((_la-313)) & ^0x3f) == 0 && ((int64(1)<<(_la-313))&262207) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6947)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1041, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6945)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6946)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6949)
			p.Match(MariaDBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6950)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6951)
			p.expression(0)
		}
		{
			p.SetState(6952)

			var _m = p.Match(MariaDBParserCOMMA)

			localctx.(*DataTypeFunctionCallContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6953)
			p.ConvertedDataType()
		}
		{
			p.SetState(6954)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6956)
			p.Match(MariaDBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6957)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6958)
			p.expression(0)
		}
		{
			p.SetState(6959)
			p.Match(MariaDBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6960)
			p.CharsetName()
		}
		{
			p.SetState(6961)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6963)
			p.Match(MariaDBParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6964)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6965)
			p.expression(0)
		}
		{
			p.SetState(6966)
			p.Match(MariaDBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6967)
			p.ConvertedDataType()
		}
		{
			p.SetState(6968)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewValuesFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6970)
			p.Match(MariaDBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6971)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6972)
			p.FullColumnName()
		}
		{
			p.SetState(6973)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewCaseExpressionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6975)
			p.Match(MariaDBParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6976)
			p.expression(0)
		}
		p.SetState(6978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserWHEN {
			{
				p.SetState(6977)
				p.CaseFuncAlternative()
			}

			p.SetState(6980)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserELSE {
			{
				p.SetState(6982)
				p.Match(MariaDBParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6983)

				var _x = p.FunctionArg()

				localctx.(*CaseExpressionFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6986)
			p.Match(MariaDBParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6988)
			p.Match(MariaDBParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserWHEN {
			{
				p.SetState(6989)
				p.CaseFuncAlternative()
			}

			p.SetState(6992)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserELSE {
			{
				p.SetState(6994)
				p.Match(MariaDBParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6995)

				var _x = p.FunctionArg()

				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6998)
			p.Match(MariaDBParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewCharFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7000)
			p.Match(MariaDBParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7001)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7002)
			p.FunctionArgs()
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserUSING {
			{
				p.SetState(7003)
				p.Match(MariaDBParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7004)
				p.CharsetName()
			}

		}
		{
			p.SetState(7007)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewPositionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7009)
			p.Match(MariaDBParserPOSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7010)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1047, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7011)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).positionString = _x
			}

		case 2:
			{
				p.SetState(7012)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).positionExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7015)
			p.Match(MariaDBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1048, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7016)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).inString = _x
			}

		case 2:
			{
				p.SetState(7017)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).inExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7020)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSubstrFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7022)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserSUBSTR || _la == MariaDBParserSUBSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7023)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1049, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7024)

				var _x = p.StringLiteral()

				localctx.(*SubstrFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(7025)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7028)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1050, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7029)

				var _x = p.DecimalLiteral()

				localctx.(*SubstrFunctionCallContext).fromDecimal = _x
			}

		case 2:
			{
				p.SetState(7030)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(7038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserFOR {
			{
				p.SetState(7033)
				p.Match(MariaDBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7036)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1051, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(7034)

					var _x = p.DecimalLiteral()

					localctx.(*SubstrFunctionCallContext).forDecimal = _x
				}

			case 2:
				{
					p.SetState(7035)

					var _x = p.expression(0)

					localctx.(*SubstrFunctionCallContext).forExpression = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		{
			p.SetState(7040)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7042)
			p.Match(MariaDBParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7043)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7044)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionCallContext).positioinForm = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserBOTH || _la == MariaDBParserLEADING || _la == MariaDBParserTRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionCallContext).positioinForm = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7047)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1053, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7045)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1053, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7046)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7049)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1054, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7050)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(7051)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7054)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7056)
			p.Match(MariaDBParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7057)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1055, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7058)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(7059)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7062)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1056, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7063)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(7064)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7067)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewWeightFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7069)
			p.Match(MariaDBParserWEIGHT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7070)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1057, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7071)
				p.StringLiteral()
			}

		case 2:
			{
				p.SetState(7072)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(7081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserAS {
			{
				p.SetState(7075)
				p.Match(MariaDBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7076)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WeightFunctionCallContext).stringFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserCHAR || _la == MariaDBParserBINARY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WeightFunctionCallContext).stringFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7077)
				p.Match(MariaDBParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7078)
				p.DecimalLiteral()
			}
			{
				p.SetState(7079)
				p.Match(MariaDBParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(7084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserLEVEL {
			{
				p.SetState(7083)
				p.LevelsInWeightString()
			}

		}
		{
			p.SetState(7086)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewExtractFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7088)
			p.Match(MariaDBParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7089)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7090)
			p.IntervalType()
		}
		{
			p.SetState(7091)
			p.Match(MariaDBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1060, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7092)

				var _x = p.StringLiteral()

				localctx.(*ExtractFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(7093)

				var _x = p.expression(0)

				localctx.(*ExtractFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7096)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewGetFormatFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7098)
			p.Match(MariaDBParserGET_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7099)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7100)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GetFormatFunctionCallContext).datetimeFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&11) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GetFormatFunctionCallContext).datetimeFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7101)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7102)
			p.StringLiteral()
		}
		{
			p.SetState(7103)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewJsonValueFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7105)
			p.Match(MariaDBParserJSON_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7106)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7107)
			p.expression(0)
		}
		{
			p.SetState(7108)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7109)
			p.expression(0)
		}
		p.SetState(7112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserRETURNING {
			{
				p.SetState(7110)
				p.Match(MariaDBParserRETURNING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7111)
				p.ConvertedDataType()
			}

		}
		p.SetState(7115)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1062, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7114)
				p.JsonOnEmpty()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserDEFAULT || _la == MariaDBParserNULL_LITERAL || _la == MariaDBParserERROR {
			{
				p.SetState(7117)
				p.JsonOnError()
			}

		}
		{
			p.SetState(7120)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IFunctionArgContext

	// GetConsequent returns the consequent rule contexts.
	GetConsequent() IFunctionArgContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IFunctionArgContext)

	// SetConsequent sets the consequent rule contexts.
	SetConsequent(IFunctionArgContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllFunctionArg() []IFunctionArgContext
	FunctionArg(i int) IFunctionArgContext

	// IsCaseFuncAlternativeContext differentiates from other interfaces.
	IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	condition  IFunctionArgContext
	consequent IFunctionArgContext
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseFuncAlternative
	return p
}

func InitEmptyCaseFuncAlternativeContext(p *CaseFuncAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_caseFuncAlternative
}

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {}

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_caseFuncAlternative

	return p
}

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext { return s.condition }

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext { return s.consequent }

func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) { s.condition = v }

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) { s.consequent = v }

func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWHEN, 0)
}

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHEN, 0)
}

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgContext); ok {
			tst[i] = t.(IFunctionArgContext)
			i++
		}
	}

	return tst
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCaseFuncAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) {
	localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, MariaDBParserRULE_caseFuncAlternative)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7124)
		p.Match(MariaDBParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7125)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).condition = _x
	}
	{
		p.SetState(7126)
		p.Match(MariaDBParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7127)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).consequent = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelsInWeightStringContext is an interface to support dynamic dispatch.
type ILevelsInWeightStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelsInWeightStringContext differentiates from other interfaces.
	IsLevelsInWeightStringContext()
}

type LevelsInWeightStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsInWeightStringContext() *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_levelsInWeightString
	return p
}

func InitEmptyLevelsInWeightStringContext(p *LevelsInWeightStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_levelsInWeightString
}

func (*LevelsInWeightStringContext) IsLevelsInWeightStringContext() {}

func NewLevelsInWeightStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_levelsInWeightString

	return p
}

func (s *LevelsInWeightStringContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsInWeightStringContext) CopyAll(ctx *LevelsInWeightStringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LevelsInWeightStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsInWeightStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LevelWeightRangeContext struct {
	LevelsInWeightStringContext
	firstLevel IDecimalLiteralContext
	lastLevel  IDecimalLiteralContext
}

func NewLevelWeightRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightRangeContext {
	var p = new(LevelWeightRangeContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightRangeContext) GetFirstLevel() IDecimalLiteralContext { return s.firstLevel }

func (s *LevelWeightRangeContext) GetLastLevel() IDecimalLiteralContext { return s.lastLevel }

func (s *LevelWeightRangeContext) SetFirstLevel(v IDecimalLiteralContext) { s.firstLevel = v }

func (s *LevelWeightRangeContext) SetLastLevel(v IDecimalLiteralContext) { s.lastLevel = v }

func (s *LevelWeightRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightRangeContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEVEL, 0)
}

func (s *LevelWeightRangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, 0)
}

func (s *LevelWeightRangeContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightRangeContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelWeightRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLevelWeightRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type LevelWeightListContext struct {
	LevelsInWeightStringContext
}

func NewLevelWeightListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightListContext {
	var p = new(LevelWeightListContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightListContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEVEL, 0)
}

func (s *LevelWeightListContext) AllLevelInWeightListElement() []ILevelInWeightListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			len++
		}
	}

	tst := make([]ILevelInWeightListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILevelInWeightListElementContext); ok {
			tst[i] = t.(ILevelInWeightListElementContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightListContext) LevelInWeightListElement(i int) ILevelInWeightListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelInWeightListElementContext)
}

func (s *LevelWeightListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *LevelWeightListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *LevelWeightListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLevelWeightList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LevelsInWeightString() (localctx ILevelsInWeightStringContext) {
	localctx = NewLevelsInWeightStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, MariaDBParserRULE_levelsInWeightString)
	var _la int

	p.SetState(7143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1066, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLevelWeightListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7129)
			p.Match(MariaDBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7130)
			p.LevelInWeightListElement()
		}
		p.SetState(7135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(7131)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7132)
				p.LevelInWeightListElement()
			}

			p.SetState(7137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewLevelWeightRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7138)
			p.Match(MariaDBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7139)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).firstLevel = _x
		}
		{
			p.SetState(7140)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7141)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).lastLevel = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelInWeightListElementContext is an interface to support dynamic dispatch.
type ILevelInWeightListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderType returns the orderType token.
	GetOrderType() antlr.Token

	// SetOrderType sets the orderType token.
	SetOrderType(antlr.Token)

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	REVERSE() antlr.TerminalNode

	// IsLevelInWeightListElementContext differentiates from other interfaces.
	IsLevelInWeightListElementContext()
}

type LevelInWeightListElementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	orderType antlr.Token
}

func NewEmptyLevelInWeightListElementContext() *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_levelInWeightListElement
	return p
}

func InitEmptyLevelInWeightListElementContext(p *LevelInWeightListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_levelInWeightListElement
}

func (*LevelInWeightListElementContext) IsLevelInWeightListElementContext() {}

func NewLevelInWeightListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_levelInWeightListElement

	return p
}

func (s *LevelInWeightListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelInWeightListElementContext) GetOrderType() antlr.Token { return s.orderType }

func (s *LevelInWeightListElementContext) SetOrderType(v antlr.Token) { s.orderType = v }

func (s *LevelInWeightListElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelInWeightListElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASC, 0)
}

func (s *LevelInWeightListElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDESC, 0)
}

func (s *LevelInWeightListElementContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE, 0)
}

func (s *LevelInWeightListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelInWeightListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelInWeightListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLevelInWeightListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LevelInWeightListElement() (localctx ILevelInWeightListElementContext) {
	localctx = NewLevelInWeightListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, MariaDBParserRULE_levelInWeightListElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7145)
		p.DecimalLiteral()
	}
	p.SetState(7147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserASC || _la == MariaDBParserDESC || _la == MariaDBParserREVERSE {
		{
			p.SetState(7146)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LevelInWeightListElementContext).orderType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserASC || _la == MariaDBParserDESC || _la == MariaDBParserREVERSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LevelInWeightListElementContext).orderType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAggregator returns the aggregator token.
	GetAggregator() antlr.Token

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetAggregator sets the aggregator token.
	SetAggregator(antlr.Token)

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	AVG() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	OverClause() IOverClauseContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	STAR() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	SEPARATOR() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	aggregator antlr.Token
	starArg    antlr.Token
	separator  antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_aggregateWindowedFunction
	return p
}

func InitEmptyAggregateWindowedFunctionContext(p *AggregateWindowedFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_aggregateWindowedFunction
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) GetSeparator() antlr.Token { return s.separator }

func (s *AggregateWindowedFunctionContext) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAVG, 0)
}

func (s *AggregateWindowedFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX, 0)
}

func (s *AggregateWindowedFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIN, 0)
}

func (s *AggregateWindowedFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUM, 0)
}

func (s *AggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *AggregateWindowedFunctionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *AggregateWindowedFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISTINCT, 0)
}

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_AND, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_OR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_XOR, 0)
}

func (s *AggregateWindowedFunctionContext) STD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTD, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV_POP, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_POP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARIANCE, 0)
}

func (s *AggregateWindowedFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_CONCAT, 0)
}

func (s *AggregateWindowedFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDER, 0)
}

func (s *AggregateWindowedFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *AggregateWindowedFunctionContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregateWindowedFunctionContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *AggregateWindowedFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEPARATOR, 0)
}

func (s *AggregateWindowedFunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *AggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *AggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, MariaDBParserRULE_aggregateWindowedFunction)
	var _la int

	p.SetState(7208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserAVG, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserSUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7149)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-286)) & ^0x3f) == 0 && ((int64(1)<<(_la-286))&8400897) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7150)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1068, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7151)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MariaDBParserALL || _la == MariaDBParserDISTINCT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7154)
			p.FunctionArg()
		}
		{
			p.SetState(7155)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7157)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1069, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7156)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserCOUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7159)
			p.Match(MariaDBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7160)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1071, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7161)

				var _m = p.Match(MariaDBParserSTAR)

				localctx.(*AggregateWindowedFunctionContext).starArg = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(7163)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1070, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7162)

					var _m = p.Match(MariaDBParserALL)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(7165)
				p.FunctionArg()
			}

		case 3:
			{
				p.SetState(7166)

				var _m = p.Match(MariaDBParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7167)
				p.FunctionArgs()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7170)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1072, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7171)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7174)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-287)) & ^0x3f) == 0 && ((int64(1)<<(_la-287))&62652423) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7175)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7177)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1073, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7176)

				var _m = p.Match(MariaDBParserALL)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7179)
			p.FunctionArg()
		}
		{
			p.SetState(7180)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7182)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1074, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7181)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MariaDBParserGROUP_CONCAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7184)
			p.Match(MariaDBParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7185)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7187)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1075, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7186)

				var _m = p.Match(MariaDBParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7189)
			p.FunctionArgs()
		}
		p.SetState(7200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserORDER {
			{
				p.SetState(7190)
				p.Match(MariaDBParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7191)
				p.Match(MariaDBParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7192)
				p.OrderByExpression()
			}
			p.SetState(7197)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MariaDBParserCOMMA {
				{
					p.SetState(7193)
					p.Match(MariaDBParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7194)
					p.OrderByExpression()
				}

				p.SetState(7199)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserSEPARATOR {
			{
				p.SetState(7202)
				p.Match(MariaDBParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7203)

				var _m = p.Match(MariaDBParserSTRING_LITERAL)

				localctx.(*AggregateWindowedFunctionContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7206)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type INonAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	RR_BRACKET() antlr.TerminalNode
	OverClause() IOverClauseContext
	LAG() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	RANK() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode

	// IsNonAggregateWindowedFunctionContext differentiates from other interfaces.
	IsNonAggregateWindowedFunctionContext()
}

type NonAggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonAggregateWindowedFunctionContext() *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_nonAggregateWindowedFunction
	return p
}

func InitEmptyNonAggregateWindowedFunctionContext(p *NonAggregateWindowedFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_nonAggregateWindowedFunction
}

func (*NonAggregateWindowedFunctionContext) IsNonAggregateWindowedFunctionContext() {}

func NewNonAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_nonAggregateWindowedFunction

	return p
}

func (s *NonAggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NonAggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NonAggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *NonAggregateWindowedFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAG, 0)
}

func (s *NonAggregateWindowedFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAD, 0)
}

func (s *NonAggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *NonAggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *NonAggregateWindowedFunctionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *NonAggregateWindowedFunctionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *NonAggregateWindowedFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCUME_DIST, 0)
}

func (s *NonAggregateWindowedFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDENSE_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERCENT_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_NUMBER, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNTH_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNTILE, 0)
}

func (s *NonAggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonAggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNonAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) NonAggregateWindowedFunction() (localctx INonAggregateWindowedFunctionContext) {
	localctx = NewNonAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, MariaDBParserRULE_nonAggregateWindowedFunction)
	var _la int

	p.SetState(7248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserLAG, MariaDBParserLEAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7210)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserLAG || _la == MariaDBParserLEAD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7211)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7212)
			p.expression(0)
		}
		p.SetState(7215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1080, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7213)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7214)
				p.DecimalLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserCOMMA {
			{
				p.SetState(7217)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7218)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(7221)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7222)
			p.OverClause()
		}

	case MariaDBParserFIRST_VALUE, MariaDBParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7224)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFIRST_VALUE || _la == MariaDBParserLAST_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7225)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7226)
			p.expression(0)
		}
		{
			p.SetState(7227)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7228)
			p.OverClause()
		}

	case MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7230)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-291)) & ^0x3f) == 0 && ((int64(1)<<(_la-291))&14339) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7231)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7232)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7233)
			p.OverClause()
		}

	case MariaDBParserNTH_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7234)
			p.Match(MariaDBParserNTH_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7235)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7236)
			p.expression(0)
		}
		{
			p.SetState(7237)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7238)
			p.DecimalLiteral()
		}
		{
			p.SetState(7239)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7240)
			p.OverClause()
		}

	case MariaDBParserNTILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7242)
			p.Match(MariaDBParserNTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7243)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7244)
			p.DecimalLiteral()
		}
		{
			p.SetState(7245)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.OverClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	WindowName() IWindowNameContext
	WindowSpec() IWindowSpecContext

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_overClause
	return p
}

func InitEmptyOverClauseContext(p *OverClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_overClause
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOVER, 0)
}

func (s *OverClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *OverClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *OverClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *OverClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (s *OverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitOverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) OverClause() (localctx IOverClauseContext) {
	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, MariaDBParserRULE_overClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7250)
		p.Match(MariaDBParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserLR_BRACKET:
		{
			p.SetState(7251)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7253)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1083, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7252)
				p.WindowSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7255)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserATTRIBUTE, MariaDBParserBODY, MariaDBParserBUCKETS, MariaDBParserCONDITION, MariaDBParserCURRENT, MariaDBParserCURRENT_ROLE, MariaDBParserCURRENT_USER, MariaDBParserDATABASE, MariaDBParserDEFAULT, MariaDBParserDIAGNOSTICS, MariaDBParserEMPTY, MariaDBParserEXCEPT, MariaDBParserGROUP, MariaDBParserIF, MariaDBParserIGNORED, MariaDBParserINSERT, MariaDBParserLATERAL, MariaDBParserLEFT, MariaDBParserLOCKED, MariaDBParserMAXVALUE, MariaDBParserMINVALUE, MariaDBParserNUMBER, MariaDBParserOPTIONAL, MariaDBParserORDER, MariaDBParserPRIMARY, MariaDBParserPACKAGE, MariaDBParserREPLACE, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserSKIP_, MariaDBParserSTACKED, MariaDBParserSTATEMENT, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserDATETIME, MariaDBParserYEAR, MariaDBParserBINARY, MariaDBParserTEXT, MariaDBParserENUM, MariaDBParserSERIAL, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserNESTED, MariaDBParserORDINALITY, MariaDBParserPATH, MariaDBParserAVG, MariaDBParserBIT_AND, MariaDBParserBIT_OR, MariaDBParserBIT_XOR, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserGROUP_CONCAT, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserMAX, MariaDBParserMIN, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserSTD, MariaDBParserSTDDEV, MariaDBParserSTDDEV_POP, MariaDBParserSTDDEV_SAMP, MariaDBParserSUM, MariaDBParserVAR_POP, MariaDBParserVAR_SAMP, MariaDBParserVARIANCE, MariaDBParserCURRENT_DATE, MariaDBParserCURRENT_TIME, MariaDBParserCURRENT_TIMESTAMP, MariaDBParserLOCALTIME, MariaDBParserCURDATE, MariaDBParserCURTIME, MariaDBParserDATE_ADD, MariaDBParserDATE_SUB, MariaDBParserLOCALTIMESTAMP, MariaDBParserNOW, MariaDBParserPOSITION, MariaDBParserSUBSTR, MariaDBParserSUBSTRING, MariaDBParserSYSDATE, MariaDBParserTRIM, MariaDBParserUTC_DATE, MariaDBParserUTC_TIME, MariaDBParserUTC_TIMESTAMP, MariaDBParserACCOUNT, MariaDBParserACTION, MariaDBParserAFTER, MariaDBParserAGGREGATE, MariaDBParserALGORITHM, MariaDBParserANY, MariaDBParserAT, MariaDBParserAUTHORS, MariaDBParserAUTOCOMMIT, MariaDBParserAUTOEXTEND_SIZE, MariaDBParserAUTO_INCREMENT, MariaDBParserAVG_ROW_LENGTH, MariaDBParserBEGIN, MariaDBParserBINLOG, MariaDBParserBIT, MariaDBParserBLOCK, MariaDBParserBOOL, MariaDBParserBOOLEAN, MariaDBParserBTREE, MariaDBParserCACHE, MariaDBParserCASCADED, MariaDBParserCHAIN, MariaDBParserCHANGED, MariaDBParserCHANNEL, MariaDBParserCHECKSUM, MariaDBParserPAGE_CHECKSUM, MariaDBParserCIPHER, MariaDBParserCLASS_ORIGIN, MariaDBParserCLIENT, MariaDBParserCLOSE, MariaDBParserCLUSTERING, MariaDBParserCOALESCE, MariaDBParserCODE, MariaDBParserCOLUMNS, MariaDBParserCOLUMN_FORMAT, MariaDBParserCOLUMN_NAME, MariaDBParserCOMMENT, MariaDBParserCOMMIT, MariaDBParserCOMPACT, MariaDBParserCOMPLETION, MariaDBParserCOMPRESSED, MariaDBParserCOMPRESSION, MariaDBParserCONCURRENT, MariaDBParserCONNECT, MariaDBParserCONNECTION, MariaDBParserCONSISTENT, MariaDBParserCONSTRAINT_CATALOG, MariaDBParserCONSTRAINT_SCHEMA, MariaDBParserCONSTRAINT_NAME, MariaDBParserCONTAINS, MariaDBParserCONTEXT, MariaDBParserCONTRIBUTORS, MariaDBParserCOPY, MariaDBParserCPU, MariaDBParserCYCLE, MariaDBParserCURSOR_NAME, MariaDBParserDATA, MariaDBParserDATAFILE, MariaDBParserDEALLOCATE, MariaDBParserDEFAULT_AUTH, MariaDBParserDEFINER, MariaDBParserDELAY_KEY_WRITE, MariaDBParserDES_KEY_FILE, MariaDBParserDIRECTORY, MariaDBParserDISABLE, MariaDBParserDISCARD, MariaDBParserDISK, MariaDBParserDO, MariaDBParserDUMPFILE, MariaDBParserDUPLICATE, MariaDBParserDYNAMIC, MariaDBParserENABLE, MariaDBParserENCRYPTED, MariaDBParserENCRYPTION, MariaDBParserENCRYPTION_KEY_ID, MariaDBParserEND, MariaDBParserENDS, MariaDBParserENGINE, MariaDBParserENGINES, MariaDBParserERROR, MariaDBParserERRORS, MariaDBParserESCAPE, MariaDBParserEVEN, MariaDBParserEVENT, MariaDBParserEVENTS, MariaDBParserEVERY, MariaDBParserEXCHANGE, MariaDBParserEXCLUSIVE, MariaDBParserEXPIRE, MariaDBParserEXPORT, MariaDBParserEXTENDED, MariaDBParserEXTENT_SIZE, MariaDBParserFAILED_LOGIN_ATTEMPTS, MariaDBParserFAST, MariaDBParserFAULTS, MariaDBParserFIELDS, MariaDBParserFILE_BLOCK_SIZE, MariaDBParserFILTER, MariaDBParserFIRST, MariaDBParserFIXED, MariaDBParserFLUSH, MariaDBParserFOLLOWS, MariaDBParserFOUND, MariaDBParserFULL, MariaDBParserFUNCTION, MariaDBParserGENERAL, MariaDBParserGLOBAL, MariaDBParserGRANTS, MariaDBParserGROUP_REPLICATION, MariaDBParserHANDLER, MariaDBParserHASH, MariaDBParserHELP, MariaDBParserHISTORY, MariaDBParserHOST, MariaDBParserHOSTS, MariaDBParserIDENTIFIED, MariaDBParserIGNORE_SERVER_IDS, MariaDBParserIMPORT, MariaDBParserINCREMENT, MariaDBParserINDEXES, MariaDBParserINITIAL_SIZE, MariaDBParserINPLACE, MariaDBParserINSERT_METHOD, MariaDBParserINSTALL, MariaDBParserINSTANCE, MariaDBParserINSTANT, MariaDBParserINVISIBLE, MariaDBParserINVOKER, MariaDBParserIO, MariaDBParserIO_THREAD, MariaDBParserIPC, MariaDBParserISOLATION, MariaDBParserISSUER, MariaDBParserJSON, MariaDBParserKEY_BLOCK_SIZE, MariaDBParserLANGUAGE, MariaDBParserLAST, MariaDBParserLEAVES, MariaDBParserLESS, MariaDBParserLEVEL, MariaDBParserLIST, MariaDBParserLOCAL, MariaDBParserLOCALES, MariaDBParserLOGFILE, MariaDBParserLOGS, MariaDBParserMASTER, MariaDBParserMASTER_AUTO_POSITION, MariaDBParserMASTER_CONNECT_RETRY, MariaDBParserMASTER_DELAY, MariaDBParserMASTER_HEARTBEAT_PERIOD, MariaDBParserMASTER_HOST, MariaDBParserMASTER_LOG_FILE, MariaDBParserMASTER_LOG_POS, MariaDBParserMASTER_PASSWORD, MariaDBParserMASTER_PORT, MariaDBParserMASTER_RETRY_COUNT, MariaDBParserMASTER_SSL, MariaDBParserMASTER_SSL_CA, MariaDBParserMASTER_SSL_CAPATH, MariaDBParserMASTER_SSL_CERT, MariaDBParserMASTER_SSL_CIPHER, MariaDBParserMASTER_SSL_CRL, MariaDBParserMASTER_SSL_CRLPATH, MariaDBParserMASTER_SSL_KEY, MariaDBParserMASTER_TLS_VERSION, MariaDBParserMASTER_USER, MariaDBParserMAX_CONNECTIONS_PER_HOUR, MariaDBParserMAX_QUERIES_PER_HOUR, MariaDBParserMAX_ROWS, MariaDBParserMAX_SIZE, MariaDBParserMAX_UPDATES_PER_HOUR, MariaDBParserMAX_USER_CONNECTIONS, MariaDBParserMEDIUM, MariaDBParserMEMBER, MariaDBParserMERGE, MariaDBParserMESSAGE_TEXT, MariaDBParserMID, MariaDBParserMIGRATE, MariaDBParserMIN_ROWS, MariaDBParserMODE, MariaDBParserMODIFY, MariaDBParserMUTEX, MariaDBParserMYSQL, MariaDBParserMYSQL_ERRNO, MariaDBParserNAME, MariaDBParserNAMES, MariaDBParserNCHAR, MariaDBParserNEVER, MariaDBParserNEXT, MariaDBParserNO, MariaDBParserNOCACHE, MariaDBParserNOCOPY, MariaDBParserNOCYCLE, MariaDBParserNOMAXVALUE, MariaDBParserNOMINVALUE, MariaDBParserNOWAIT, MariaDBParserNODEGROUP, MariaDBParserNONE, MariaDBParserODBC, MariaDBParserOFFLINE, MariaDBParserOFFSET, MariaDBParserOF, MariaDBParserOJ, MariaDBParserOLD_PASSWORD, MariaDBParserONE, MariaDBParserONLINE, MariaDBParserONLY, MariaDBParserOPEN, MariaDBParserOPTIMIZER_COSTS, MariaDBParserOPTIONS, MariaDBParserOWNER, MariaDBParserPACK_KEYS, MariaDBParserPAGE, MariaDBParserPARSER, MariaDBParserPARTIAL, MariaDBParserPARTITIONING, MariaDBParserPARTITIONS, MariaDBParserPASSWORD, MariaDBParserPASSWORD_LOCK_TIME, MariaDBParserPHASE, MariaDBParserPLUGIN, MariaDBParserPLUGIN_DIR, MariaDBParserPLUGINS, MariaDBParserPORT, MariaDBParserPRECEDES, MariaDBParserPREPARE, MariaDBParserPRESERVE, MariaDBParserPREV, MariaDBParserPROCESSLIST, MariaDBParserPROFILE, MariaDBParserPROFILES, MariaDBParserPROXY, MariaDBParserQUERY, MariaDBParserQUERY_RESPONSE_TIME, MariaDBParserQUICK, MariaDBParserREBUILD, MariaDBParserRECOVER, MariaDBParserRECURSIVE, MariaDBParserREDO_BUFFER_SIZE, MariaDBParserREDUNDANT, MariaDBParserRELAY, MariaDBParserRELAY_LOG_FILE, MariaDBParserRELAY_LOG_POS, MariaDBParserRELAYLOG, MariaDBParserREMOVE, MariaDBParserREORGANIZE, MariaDBParserREPAIR, MariaDBParserREPLICATE_DO_DB, MariaDBParserREPLICATE_DO_TABLE, MariaDBParserREPLICATE_IGNORE_DB, MariaDBParserREPLICATE_IGNORE_TABLE, MariaDBParserREPLICATE_REWRITE_DB, MariaDBParserREPLICATE_WILD_DO_TABLE, MariaDBParserREPLICATE_WILD_IGNORE_TABLE, MariaDBParserREPLICATION, MariaDBParserRESET, MariaDBParserRESTART, MariaDBParserRESUME, MariaDBParserRETURNED_SQLSTATE, MariaDBParserRETURNS, MariaDBParserREUSE, MariaDBParserROLE, MariaDBParserROLLBACK, MariaDBParserROLLUP, MariaDBParserROTATE, MariaDBParserROW, MariaDBParserROWS, MariaDBParserROW_FORMAT, MariaDBParserRTREE, MariaDBParserSAVEPOINT, MariaDBParserSCHEDULE, MariaDBParserSECURITY, MariaDBParserSEQUENCE, MariaDBParserSERVER, MariaDBParserSESSION, MariaDBParserSHARE, MariaDBParserSHARED, MariaDBParserSIGNED, MariaDBParserSIMPLE, MariaDBParserSLAVE, MariaDBParserSLAVES, MariaDBParserSLOW, MariaDBParserSNAPSHOT, MariaDBParserSOCKET, MariaDBParserSOME, MariaDBParserSONAME, MariaDBParserSOUNDS, MariaDBParserSOURCE, MariaDBParserSQL_AFTER_GTIDS, MariaDBParserSQL_AFTER_MTS_GAPS, MariaDBParserSQL_BEFORE_GTIDS, MariaDBParserSQL_BUFFER_RESULT, MariaDBParserSQL_CACHE, MariaDBParserSQL_NO_CACHE, MariaDBParserSQL_THREAD, MariaDBParserSTART, MariaDBParserSTARTS, MariaDBParserSTATS_AUTO_RECALC, MariaDBParserSTATS_PERSISTENT, MariaDBParserSTATS_SAMPLE_PAGES, MariaDBParserSTATUS, MariaDBParserSTOP, MariaDBParserSTORAGE, MariaDBParserSTRING, MariaDBParserSUBCLASS_ORIGIN, MariaDBParserSUBJECT, MariaDBParserSUBPARTITION, MariaDBParserSUBPARTITIONS, MariaDBParserSUSPEND, MariaDBParserSWAPS, MariaDBParserSWITCHES, MariaDBParserTABLE_NAME, MariaDBParserTABLESPACE, MariaDBParserTABLE_TYPE, MariaDBParserTEMPORARY, MariaDBParserTEMPTABLE, MariaDBParserTHAN, MariaDBParserTRADITIONAL, MariaDBParserTRANSACTION, MariaDBParserTRANSACTIONAL, MariaDBParserTRIGGERS, MariaDBParserTRUNCATE, MariaDBParserTYPES, MariaDBParserUNBOUNDED, MariaDBParserUNDEFINED, MariaDBParserUNDOFILE, MariaDBParserUNDO_BUFFER_SIZE, MariaDBParserUNINSTALL, MariaDBParserUNKNOWN, MariaDBParserUNTIL, MariaDBParserUPGRADE, MariaDBParserUSER, MariaDBParserUSE_FRM, MariaDBParserUSER_RESOURCES, MariaDBParserVALIDATION, MariaDBParserVALUE, MariaDBParserVARIABLES, MariaDBParserVIEW, MariaDBParserVIRTUAL, MariaDBParserVISIBLE, MariaDBParserWAIT, MariaDBParserWARNINGS, MariaDBParserWITHOUT, MariaDBParserWORK, MariaDBParserWRAPPER, MariaDBParserWSREP_MEMBERSHIP, MariaDBParserWSREP_STATUS, MariaDBParserX509, MariaDBParserXA, MariaDBParserXML, MariaDBParserEUR, MariaDBParserUSA, MariaDBParserJIS, MariaDBParserISO, MariaDBParserINTERNAL, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserUSER_STATISTICS, MariaDBParserCLIENT_STATISTICS, MariaDBParserINDEX_STATISTICS, MariaDBParserTABLE_STATISTICS, MariaDBParserADMIN, MariaDBParserAUDIT_ADMIN, MariaDBParserBACKUP_ADMIN, MariaDBParserBINLOG_ADMIN, MariaDBParserBINLOG_ENCRYPTION_ADMIN, MariaDBParserCLONE_ADMIN, MariaDBParserCONNECTION_ADMIN, MariaDBParserENCRYPTION_KEY_ADMIN, MariaDBParserEXECUTE, MariaDBParserFILE, MariaDBParserFIREWALL_ADMIN, MariaDBParserFIREWALL_USER, MariaDBParserGROUP_REPLICATION_ADMIN, MariaDBParserINNODB_REDO_LOG_ARCHIVE, MariaDBParserINVOKE, MariaDBParserLAMBDA, MariaDBParserNDB_STORED_USER, MariaDBParserPASSWORDLESS_USER_ADMIN, MariaDBParserPERSIST_RO_VARIABLES_ADMIN, MariaDBParserPRIVILEGES, MariaDBParserPROCESS, MariaDBParserRELOAD, MariaDBParserREPLICATION_APPLIER, MariaDBParserREPLICATION_SLAVE_ADMIN, MariaDBParserRESOURCE_GROUP_ADMIN, MariaDBParserRESOURCE_GROUP_USER, MariaDBParserROLE_ADMIN, MariaDBParserROUTINE, MariaDBParserS3, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserSET_USER_ID, MariaDBParserSHOW_ROUTINE, MariaDBParserSHUTDOWN, MariaDBParserSUPER, MariaDBParserSYSTEM_VARIABLES_ADMIN, MariaDBParserTABLES, MariaDBParserTABLE_ENCRYPTION_ADMIN, MariaDBParserVERSION_TOKEN_ADMIN, MariaDBParserXA_RECOVER_ADMIN, MariaDBParserARMSCII8, MariaDBParserASCII, MariaDBParserBIG5, MariaDBParserCP1250, MariaDBParserCP1251, MariaDBParserCP1256, MariaDBParserCP1257, MariaDBParserCP850, MariaDBParserCP852, MariaDBParserCP866, MariaDBParserCP932, MariaDBParserDEC8, MariaDBParserEUCJPMS, MariaDBParserEUCKR, MariaDBParserGB18030, MariaDBParserGB2312, MariaDBParserGBK, MariaDBParserGEOSTD8, MariaDBParserGREEK, MariaDBParserHEBREW, MariaDBParserHP8, MariaDBParserKEYBCS2, MariaDBParserKOI8R, MariaDBParserKOI8U, MariaDBParserLATIN1, MariaDBParserLATIN2, MariaDBParserLATIN5, MariaDBParserLATIN7, MariaDBParserMACCE, MariaDBParserMACROMAN, MariaDBParserSJIS, MariaDBParserSWE7, MariaDBParserTIS620, MariaDBParserUCS2, MariaDBParserUJIS, MariaDBParserUTF16, MariaDBParserUTF16LE, MariaDBParserUTF32, MariaDBParserUTF8, MariaDBParserUTF8MB3, MariaDBParserUTF8MB4, MariaDBParserARCHIVE, MariaDBParserBLACKHOLE, MariaDBParserCSV, MariaDBParserFEDERATED, MariaDBParserINNODB, MariaDBParserMEMORY, MariaDBParserMRG_MYISAM, MariaDBParserMYISAM, MariaDBParserNDB, MariaDBParserNDBCLUSTER, MariaDBParserPERFORMANCE_SCHEMA, MariaDBParserTOKUDB, MariaDBParserREPEATABLE, MariaDBParserCOMMITTED, MariaDBParserUNCOMMITTED, MariaDBParserSERIALIZABLE, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCATALOG_NAME, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENGINE_ATTRIBUTE, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSCHEMA_NAME, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserVIA, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserPREVIOUS, MariaDBParserPERSISTENT, MariaDBParserBINLOG_MONITOR, MariaDBParserBINLOG_REPLAY, MariaDBParserFEDERATED_ADMIN, MariaDBParserREAD_ONLY_ADMIN, MariaDBParserREPLICA, MariaDBParserREPLICAS, MariaDBParserREPLICATION_MASTER_ADMIN, MariaDBParserMONITOR, MariaDBParserREAD_ONLY, MariaDBParserREPLAY, MariaDBParserMOD, MariaDBParserCHARSET_REVERSE_QOUTE_STRING, MariaDBParserSTRING_LITERAL, MariaDBParserID, MariaDBParserREVERSE_QUOTE_ID:
		{
			p.SetState(7256)
			p.WindowName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PartitionClause() IPartitionClauseContext
	OrderByClause() IOrderByClauseContext
	FrameClause() IFrameClauseContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *WindowSpecContext) FrameClause() IFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameClauseContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, MariaDBParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7260)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1085, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7259)
			p.WindowName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(7263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserPARTITION {
		{
			p.SetState(7262)
			p.PartitionClause()
		}

	}
	p.SetState(7266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserORDER {
		{
			p.SetState(7265)
			p.OrderByClause()
		}

	}
	p.SetState(7269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MariaDBParserRANGE || _la == MariaDBParserROWS {
		{
			p.SetState(7268)
			p.FrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowName
	return p
}

func InitEmptyWindowNameContext(p *WindowNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_windowName
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (s *WindowNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitWindowName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) WindowName() (localctx IWindowNameContext) {
	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, MariaDBParserRULE_windowName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7271)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameClauseContext is an interface to support dynamic dispatch.
type IFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	FrameExtent() IFrameExtentContext

	// IsFrameClauseContext differentiates from other interfaces.
	IsFrameClauseContext()
}

type FrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameClauseContext() *FrameClauseContext {
	var p = new(FrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameClause
	return p
}

func InitEmptyFrameClauseContext(p *FrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameClause
}

func (*FrameClauseContext) IsFrameClauseContext() {}

func NewFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameClauseContext {
	var p = new(FrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_frameClause

	return p
}

func (s *FrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameClauseContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *FrameClauseContext) FrameExtent() IFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameExtentContext)
}

func (s *FrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFrameClause(s)
	}
}

func (s *FrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFrameClause(s)
	}
}

func (s *FrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FrameClause() (localctx IFrameClauseContext) {
	localctx = NewFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, MariaDBParserRULE_frameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7273)
		p.FrameUnits()
	}
	{
		p.SetState(7274)
		p.FrameExtent()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (s *FrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, MariaDBParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7276)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserRANGE || _la == MariaDBParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameExtentContext is an interface to support dynamic dispatch.
type IFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameRange() IFrameRangeContext
	FrameBetween() IFrameBetweenContext

	// IsFrameExtentContext differentiates from other interfaces.
	IsFrameExtentContext()
}

type FrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameExtentContext() *FrameExtentContext {
	var p = new(FrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameExtent
	return p
}

func InitEmptyFrameExtentContext(p *FrameExtentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameExtent
}

func (*FrameExtentContext) IsFrameExtentContext() {}

func NewFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameExtentContext {
	var p = new(FrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_frameExtent

	return p
}

func (s *FrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameExtentContext) FrameRange() IFrameRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameExtentContext) FrameBetween() IFrameBetweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBetweenContext)
}

func (s *FrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFrameExtent(s)
	}
}

func (s *FrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFrameExtent(s)
	}
}

func (s *FrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FrameExtent() (localctx IFrameExtentContext) {
	localctx = NewFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, MariaDBParserRULE_frameExtent)
	p.SetState(7280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1089, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7278)
			p.FrameRange()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7279)
			p.FrameBetween()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBetweenContext is an interface to support dynamic dispatch.
type IFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllFrameRange() []IFrameRangeContext
	FrameRange(i int) IFrameRangeContext
	AND() antlr.TerminalNode

	// IsFrameBetweenContext differentiates from other interfaces.
	IsFrameBetweenContext()
}

type FrameBetweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBetweenContext() *FrameBetweenContext {
	var p = new(FrameBetweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameBetween
	return p
}

func InitEmptyFrameBetweenContext(p *FrameBetweenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameBetween
}

func (*FrameBetweenContext) IsFrameBetweenContext() {}

func NewFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_frameBetween

	return p
}

func (s *FrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllFrameRange() []IFrameRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameRangeContext); ok {
			len++
		}
	}

	tst := make([]IFrameRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameRangeContext); ok {
			tst[i] = t.(IFrameRangeContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) FrameRange(i int) IFrameRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, 0)
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (s *FrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FrameBetween() (localctx IFrameBetweenContext) {
	localctx = NewFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, MariaDBParserRULE_frameBetween)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7282)
		p.Match(MariaDBParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7283)
		p.FrameRange()
	}
	{
		p.SetState(7284)
		p.Match(MariaDBParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7285)
		p.FrameRange()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameRangeContext is an interface to support dynamic dispatch.
type IFrameRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameRangeContext differentiates from other interfaces.
	IsFrameRangeContext()
}

type FrameRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameRangeContext() *FrameRangeContext {
	var p = new(FrameRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameRange
	return p
}

func InitEmptyFrameRangeContext(p *FrameRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_frameRange
}

func (*FrameRangeContext) IsFrameRangeContext() {}

func NewFrameRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameRangeContext {
	var p = new(FrameRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_frameRange

	return p
}

func (s *FrameRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameRangeContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT, 0)
}

func (s *FrameRangeContext) ROW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW, 0)
}

func (s *FrameRangeContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNBOUNDED, 0)
}

func (s *FrameRangeContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRECEDING, 0)
}

func (s *FrameRangeContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOLLOWING, 0)
}

func (s *FrameRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFrameRange(s)
	}
}

func (s *FrameRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFrameRange(s)
	}
}

func (s *FrameRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFrameRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FrameRange() (localctx IFrameRangeContext) {
	localctx = NewFrameRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, MariaDBParserRULE_frameRange)
	var _la int

	p.SetState(7294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1090, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7287)
			p.Match(MariaDBParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7288)
			p.Match(MariaDBParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7289)
			p.Match(MariaDBParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFOLLOWING || _la == MariaDBParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7291)
			p.expression(0)
		}
		{
			p.SetState(7292)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFOLLOWING || _la == MariaDBParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, MariaDBParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7296)
		p.Match(MariaDBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7297)
		p.Match(MariaDBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7298)
		p.expression(0)
	}
	p.SetState(7303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(7299)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7300)
			p.expression(0)
		}

		p.SetState(7305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionNameBase() IFunctionNameBaseContext
	ASCII() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	IF() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	MID() antlr.TerminalNode
	NOW() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	UTC_DATE() antlr.TerminalNode
	UTC_TIME() antlr.TerminalNode
	UTC_TIMESTAMP() antlr.TerminalNode

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_scalarFunctionName
	return p
}

func InitEmptyScalarFunctionNameContext(p *ScalarFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_scalarFunctionName
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitScalarFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, MariaDBParserRULE_scalarFunctionName)
	p.SetState(7329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserDATABASE, MariaDBParserLEFT, MariaDBParserRIGHT, MariaDBParserSCHEMA, MariaDBParserDATE, MariaDBParserTIME, MariaDBParserTIMESTAMP, MariaDBParserYEAR, MariaDBParserJSON_ARRAY, MariaDBParserJSON_ARRAYAGG, MariaDBParserJSON_ARRAY_APPEND, MariaDBParserJSON_ARRAY_INSERT, MariaDBParserJSON_CONTAINS, MariaDBParserJSON_CONTAINS_PATH, MariaDBParserJSON_DEPTH, MariaDBParserJSON_EXTRACT, MariaDBParserJSON_INSERT, MariaDBParserJSON_KEYS, MariaDBParserJSON_LENGTH, MariaDBParserJSON_MERGE, MariaDBParserJSON_MERGE_PATCH, MariaDBParserJSON_MERGE_PRESERVE, MariaDBParserJSON_OBJECT, MariaDBParserJSON_OBJECTAGG, MariaDBParserJSON_OVERLAPS, MariaDBParserJSON_PRETTY, MariaDBParserJSON_QUOTE, MariaDBParserJSON_REMOVE, MariaDBParserJSON_REPLACE, MariaDBParserJSON_SCHEMA_VALID, MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, MariaDBParserJSON_SEARCH, MariaDBParserJSON_SET, MariaDBParserJSON_STORAGE_FREE, MariaDBParserJSON_STORAGE_SIZE, MariaDBParserJSON_TABLE, MariaDBParserJSON_TYPE, MariaDBParserJSON_UNQUOTE, MariaDBParserJSON_VALID, MariaDBParserJSON_VALUE, MariaDBParserCOUNT, MariaDBParserCUME_DIST, MariaDBParserDENSE_RANK, MariaDBParserFIRST_VALUE, MariaDBParserLAG, MariaDBParserLAST_VALUE, MariaDBParserLEAD, MariaDBParserNTILE, MariaDBParserNTH_VALUE, MariaDBParserPERCENT_RANK, MariaDBParserRANK, MariaDBParserROW_NUMBER, MariaDBParserPOSITION, MariaDBParserINVISIBLE, MariaDBParserVISIBLE, MariaDBParserQUARTER, MariaDBParserMONTH, MariaDBParserDAY, MariaDBParserHOUR, MariaDBParserMINUTE, MariaDBParserWEEK, MariaDBParserSECOND, MariaDBParserMICROSECOND, MariaDBParserSESSION_VARIABLES_ADMIN, MariaDBParserGEOMETRYCOLLECTION, MariaDBParserLINESTRING, MariaDBParserMULTILINESTRING, MariaDBParserMULTIPOINT, MariaDBParserMULTIPOLYGON, MariaDBParserPOINT, MariaDBParserPOLYGON, MariaDBParserABS, MariaDBParserACOS, MariaDBParserADDDATE, MariaDBParserADDTIME, MariaDBParserAES_DECRYPT, MariaDBParserAES_ENCRYPT, MariaDBParserAREA, MariaDBParserASBINARY, MariaDBParserASIN, MariaDBParserASTEXT, MariaDBParserASWKB, MariaDBParserASWKT, MariaDBParserASYMMETRIC_DECRYPT, MariaDBParserASYMMETRIC_DERIVE, MariaDBParserASYMMETRIC_ENCRYPT, MariaDBParserASYMMETRIC_SIGN, MariaDBParserASYMMETRIC_VERIFY, MariaDBParserATAN, MariaDBParserATAN2, MariaDBParserBENCHMARK, MariaDBParserBIN, MariaDBParserBIT_COUNT, MariaDBParserBIT_LENGTH, MariaDBParserBUFFER, MariaDBParserCEIL, MariaDBParserCEILING, MariaDBParserCENTROID, MariaDBParserCHARACTER_LENGTH, MariaDBParserCHARSET, MariaDBParserCHAR_LENGTH, MariaDBParserCOERCIBILITY, MariaDBParserCOLLATION, MariaDBParserCOMPRESS, MariaDBParserCONCAT, MariaDBParserCONCAT_WS, MariaDBParserCONNECTION_ID, MariaDBParserCONV, MariaDBParserCONVERT_TZ, MariaDBParserCOS, MariaDBParserCOT, MariaDBParserCRC32, MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, MariaDBParserCREATE_DH_PARAMETERS, MariaDBParserCREATE_DIGEST, MariaDBParserCROSSES, MariaDBParserDATEDIFF, MariaDBParserDATE_FORMAT, MariaDBParserDAYNAME, MariaDBParserDAYOFMONTH, MariaDBParserDAYOFWEEK, MariaDBParserDAYOFYEAR, MariaDBParserDECODE, MariaDBParserDEGREES, MariaDBParserDES_DECRYPT, MariaDBParserDES_ENCRYPT, MariaDBParserDIMENSION, MariaDBParserDISJOINT, MariaDBParserELT, MariaDBParserENCODE, MariaDBParserENCRYPT, MariaDBParserENDPOINT, MariaDBParserENVELOPE, MariaDBParserEQUALS, MariaDBParserEXP, MariaDBParserEXPORT_SET, MariaDBParserEXTERIORRING, MariaDBParserEXTRACTVALUE, MariaDBParserFIELD, MariaDBParserFIND_IN_SET, MariaDBParserFLOOR, MariaDBParserFORMAT, MariaDBParserFOUND_ROWS, MariaDBParserFROM_BASE64, MariaDBParserFROM_DAYS, MariaDBParserFROM_UNIXTIME, MariaDBParserGEOMCOLLFROMTEXT, MariaDBParserGEOMCOLLFROMWKB, MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, MariaDBParserGEOMETRYCOLLECTIONFROMWKB, MariaDBParserGEOMETRYFROMTEXT, MariaDBParserGEOMETRYFROMWKB, MariaDBParserGEOMETRYN, MariaDBParserGEOMETRYTYPE, MariaDBParserGEOMFROMTEXT, MariaDBParserGEOMFROMWKB, MariaDBParserGET_FORMAT, MariaDBParserGET_LOCK, MariaDBParserGLENGTH, MariaDBParserGREATEST, MariaDBParserGTID_SUBSET, MariaDBParserGTID_SUBTRACT, MariaDBParserHEX, MariaDBParserIFNULL, MariaDBParserINET6_ATON, MariaDBParserINET6_NTOA, MariaDBParserINET_ATON, MariaDBParserINET_NTOA, MariaDBParserINSTR, MariaDBParserINTERIORRINGN, MariaDBParserINTERSECTS, MariaDBParserISCLOSED, MariaDBParserISEMPTY, MariaDBParserISNULL, MariaDBParserISSIMPLE, MariaDBParserIS_FREE_LOCK, MariaDBParserIS_IPV4, MariaDBParserIS_IPV4_COMPAT, MariaDBParserIS_IPV4_MAPPED, MariaDBParserIS_IPV6, MariaDBParserIS_USED_LOCK, MariaDBParserLAST_INSERT_ID, MariaDBParserLCASE, MariaDBParserLEAST, MariaDBParserLENGTH, MariaDBParserLINEFROMTEXT, MariaDBParserLINEFROMWKB, MariaDBParserLINESTRINGFROMTEXT, MariaDBParserLINESTRINGFROMWKB, MariaDBParserLN, MariaDBParserLOAD_FILE, MariaDBParserLOCATE, MariaDBParserLOG, MariaDBParserLOG10, MariaDBParserLOG2, MariaDBParserLOWER, MariaDBParserLPAD, MariaDBParserLTRIM, MariaDBParserMAKEDATE, MariaDBParserMAKETIME, MariaDBParserMAKE_SET, MariaDBParserMASTER_POS_WAIT, MariaDBParserMBRCONTAINS, MariaDBParserMBRDISJOINT, MariaDBParserMBREQUAL, MariaDBParserMBRINTERSECTS, MariaDBParserMBROVERLAPS, MariaDBParserMBRTOUCHES, MariaDBParserMBRWITHIN, MariaDBParserMD5, MariaDBParserMLINEFROMTEXT, MariaDBParserMLINEFROMWKB, MariaDBParserMONTHNAME, MariaDBParserMPOINTFROMTEXT, MariaDBParserMPOINTFROMWKB, MariaDBParserMPOLYFROMTEXT, MariaDBParserMPOLYFROMWKB, MariaDBParserMULTILINESTRINGFROMTEXT, MariaDBParserMULTILINESTRINGFROMWKB, MariaDBParserMULTIPOINTFROMTEXT, MariaDBParserMULTIPOINTFROMWKB, MariaDBParserMULTIPOLYGONFROMTEXT, MariaDBParserMULTIPOLYGONFROMWKB, MariaDBParserNAME_CONST, MariaDBParserNULLIF, MariaDBParserNUMGEOMETRIES, MariaDBParserNUMINTERIORRINGS, MariaDBParserNUMPOINTS, MariaDBParserOCT, MariaDBParserOCTET_LENGTH, MariaDBParserORD, MariaDBParserOVERLAPS, MariaDBParserPERIOD_ADD, MariaDBParserPERIOD_DIFF, MariaDBParserPI, MariaDBParserPOINTFROMTEXT, MariaDBParserPOINTFROMWKB, MariaDBParserPOINTN, MariaDBParserPOLYFROMTEXT, MariaDBParserPOLYFROMWKB, MariaDBParserPOLYGONFROMTEXT, MariaDBParserPOLYGONFROMWKB, MariaDBParserPOW, MariaDBParserPOWER, MariaDBParserQUOTE, MariaDBParserRADIANS, MariaDBParserRAND, MariaDBParserRANDOM_BYTES, MariaDBParserRELEASE_LOCK, MariaDBParserREVERSE, MariaDBParserROUND, MariaDBParserROW_COUNT, MariaDBParserRPAD, MariaDBParserRTRIM, MariaDBParserSEC_TO_TIME, MariaDBParserSESSION_USER, MariaDBParserSHA, MariaDBParserSHA1, MariaDBParserSHA2, MariaDBParserSIGN, MariaDBParserSIN, MariaDBParserSLEEP, MariaDBParserSOUNDEX, MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, MariaDBParserSQRT, MariaDBParserSRID, MariaDBParserSTARTPOINT, MariaDBParserSTRCMP, MariaDBParserSTR_TO_DATE, MariaDBParserST_AREA, MariaDBParserST_ASBINARY, MariaDBParserST_ASTEXT, MariaDBParserST_ASWKB, MariaDBParserST_ASWKT, MariaDBParserST_BUFFER, MariaDBParserST_CENTROID, MariaDBParserST_CONTAINS, MariaDBParserST_CROSSES, MariaDBParserST_DIFFERENCE, MariaDBParserST_DIMENSION, MariaDBParserST_DISJOINT, MariaDBParserST_DISTANCE, MariaDBParserST_ENDPOINT, MariaDBParserST_ENVELOPE, MariaDBParserST_EQUALS, MariaDBParserST_EXTERIORRING, MariaDBParserST_GEOMCOLLFROMTEXT, MariaDBParserST_GEOMCOLLFROMTXT, MariaDBParserST_GEOMCOLLFROMWKB, MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, MariaDBParserST_GEOMETRYFROMTEXT, MariaDBParserST_GEOMETRYFROMWKB, MariaDBParserST_GEOMETRYN, MariaDBParserST_GEOMETRYTYPE, MariaDBParserST_GEOMFROMTEXT, MariaDBParserST_GEOMFROMWKB, MariaDBParserST_INTERIORRINGN, MariaDBParserST_INTERSECTION, MariaDBParserST_INTERSECTS, MariaDBParserST_ISCLOSED, MariaDBParserST_ISEMPTY, MariaDBParserST_ISSIMPLE, MariaDBParserST_LINEFROMTEXT, MariaDBParserST_LINEFROMWKB, MariaDBParserST_LINESTRINGFROMTEXT, MariaDBParserST_LINESTRINGFROMWKB, MariaDBParserST_NUMGEOMETRIES, MariaDBParserST_NUMINTERIORRING, MariaDBParserST_NUMINTERIORRINGS, MariaDBParserST_NUMPOINTS, MariaDBParserST_OVERLAPS, MariaDBParserST_POINTFROMTEXT, MariaDBParserST_POINTFROMWKB, MariaDBParserST_POINTN, MariaDBParserST_POLYFROMTEXT, MariaDBParserST_POLYFROMWKB, MariaDBParserST_POLYGONFROMTEXT, MariaDBParserST_POLYGONFROMWKB, MariaDBParserST_SRID, MariaDBParserST_STARTPOINT, MariaDBParserST_SYMDIFFERENCE, MariaDBParserST_TOUCHES, MariaDBParserST_UNION, MariaDBParserST_WITHIN, MariaDBParserST_X, MariaDBParserST_Y, MariaDBParserSUBDATE, MariaDBParserSUBSTRING_INDEX, MariaDBParserSUBTIME, MariaDBParserSYSTEM_USER, MariaDBParserTAN, MariaDBParserTIMEDIFF, MariaDBParserTIMESTAMPADD, MariaDBParserTIMESTAMPDIFF, MariaDBParserTIME_FORMAT, MariaDBParserTIME_TO_SEC, MariaDBParserTOUCHES, MariaDBParserTO_BASE64, MariaDBParserTO_DAYS, MariaDBParserTO_SECONDS, MariaDBParserUCASE, MariaDBParserUNCOMPRESS, MariaDBParserUNCOMPRESSED_LENGTH, MariaDBParserUNHEX, MariaDBParserUNIX_TIMESTAMP, MariaDBParserUPDATEXML, MariaDBParserUPPER, MariaDBParserUUID, MariaDBParserUUID_SHORT, MariaDBParserVALIDATE_PASSWORD_STRENGTH, MariaDBParserVERSION, MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MariaDBParserWEEKDAY, MariaDBParserWEEKOFYEAR, MariaDBParserWEIGHT_STRING, MariaDBParserWITHIN, MariaDBParserYEARWEEK, MariaDBParserY_FUNCTION, MariaDBParserX_FUNCTION, MariaDBParserLASTVAL, MariaDBParserNEXTVAL, MariaDBParserSETVAL, MariaDBParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7306)
			p.FunctionNameBase()
		}

	case MariaDBParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7307)
			p.Match(MariaDBParserASCII)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7308)
			p.Match(MariaDBParserCURDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7309)
			p.Match(MariaDBParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7310)
			p.Match(MariaDBParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7311)
			p.Match(MariaDBParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7312)
			p.Match(MariaDBParserCURTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7313)
			p.Match(MariaDBParserDATE_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7314)
			p.Match(MariaDBParserDATE_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7315)
			p.Match(MariaDBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7316)
			p.Match(MariaDBParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7317)
			p.Match(MariaDBParserLOCALTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7318)
			p.Match(MariaDBParserLOCALTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7319)
			p.Match(MariaDBParserMID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7320)
			p.Match(MariaDBParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserREPLACE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7321)
			p.Match(MariaDBParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSUBSTR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7322)
			p.Match(MariaDBParserSUBSTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSUBSTRING:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7323)
			p.Match(MariaDBParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserSYSDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7324)
			p.Match(MariaDBParserSYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserTRIM:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7325)
			p.Match(MariaDBParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserUTC_DATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7326)
			p.Match(MariaDBParserUTC_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserUTC_TIME:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7327)
			p.Match(MariaDBParserUTC_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7328)
			p.Match(MariaDBParserUTC_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordFunctionClauseContext is an interface to support dynamic dispatch.
type IPasswordFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName token.
	GetFunctionName() antlr.Token

	// SetFunctionName sets the functionName token.
	SetFunctionName(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode

	// IsPasswordFunctionClauseContext differentiates from other interfaces.
	IsPasswordFunctionClauseContext()
}

type PasswordFunctionClauseContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName antlr.Token
}

func NewEmptyPasswordFunctionClauseContext() *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_passwordFunctionClause
	return p
}

func InitEmptyPasswordFunctionClauseContext(p *PasswordFunctionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_passwordFunctionClause
}

func (*PasswordFunctionClauseContext) IsPasswordFunctionClauseContext() {}

func NewPasswordFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_passwordFunctionClause

	return p
}

func (s *PasswordFunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordFunctionClauseContext) GetFunctionName() antlr.Token { return s.functionName }

func (s *PasswordFunctionClauseContext) SetFunctionName(v antlr.Token) { s.functionName = v }

func (s *PasswordFunctionClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *PasswordFunctionClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOLD_PASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPasswordFunctionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PasswordFunctionClause() (localctx IPasswordFunctionClauseContext) {
	localctx = NewPasswordFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, MariaDBParserRULE_passwordFunctionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7331)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PasswordFunctionClauseContext).functionName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserOLD_PASSWORD || _la == MariaDBParserPASSWORD) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PasswordFunctionClauseContext).functionName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7332)
		p.Match(MariaDBParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7333)
		p.FunctionArg()
	}
	{
		p.SetState(7334)
		p.Match(MariaDBParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, MariaDBParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1093, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7336)
			p.Constant()
		}

	case 2:
		{
			p.SetState(7337)
			p.FullColumnName()
		}

	case 3:
		{
			p.SetState(7338)
			p.FunctionCall()
		}

	case 4:
		{
			p.SetState(7339)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(7351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MariaDBParserCOMMA {
		{
			p.SetState(7342)
			p.Match(MariaDBParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1094, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7343)
				p.Constant()
			}

		case 2:
			{
				p.SetState(7344)
				p.FullColumnName()
			}

		case 3:
			{
				p.SetState(7345)
				p.FunctionCall()
			}

		case 4:
			{
				p.SetState(7346)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(7353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FullColumnName() IFullColumnNameContext
	FunctionCall() IFunctionCallContext
	Expression() IExpressionContext

	// IsFunctionArgContext differentiates from other interfaces.
	IsFunctionArgContext()
}

type FunctionArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext {
	var p = new(FunctionArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionArg
	return p
}

func InitEmptyFunctionArgContext(p *FunctionArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionArg
}

func (*FunctionArgContext) IsFunctionArgContext() {}

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext {
	var p = new(FunctionArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_functionArg

	return p
}

func (s *FunctionArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFunctionArg(s)
	}
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFunctionArg(s)
	}
}

func (s *FunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFunctionArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FunctionArg() (localctx IFunctionArgContext) {
	localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, MariaDBParserRULE_functionArg)
	p.SetState(7358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1096, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7354)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7355)
			p.FullColumnName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7356)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7357)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExpressionContext struct {
	ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MariaDBParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 688
	p.EnterRecursionRule(localctx, 688, MariaDBParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1098, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7361)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserNOT || _la == MariaDBParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7362)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7363)
			p.predicate(0)
		}
		{
			p.SetState(7364)
			p.Match(MariaDBParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MariaDBParserNOT {
			{
				p.SetState(7365)
				p.Match(MariaDBParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7368)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MariaDBParserFALSE || _la == MariaDBParserTRUE || _la == MariaDBParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7370)
			p.predicate(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1099, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_expression)
			p.SetState(7373)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(7374)
				p.LogicalOperator()
			}
			{
				p.SetState(7375)
				p.expression(4)
			}

		}
		p.SetState(7381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1099, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSoundsLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExpressionAtomPredicateContext struct {
	PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryComparisonPredicateContext struct {
	PredicateContext
	quantifier antlr.Token
}

func NewSubqueryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparisonPredicateContext {
	var p = new(SubqueryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SubqueryComparisonPredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *SubqueryComparisonPredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *SubqueryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryComparisonPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SubqueryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *SubqueryComparisonPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryComparisonPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALL, 0)
}

func (s *SubqueryComparisonPredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserANY, 0)
}

func (s *SubqueryComparisonPredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOME, 0)
}

func (s *SubqueryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubqueryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonMemberOfPredicateContext struct {
	PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonMemberOfPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryComparisonPredicateContext struct {
	PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBinaryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type InPredicateContext struct {
	PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *InPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterInPredicate(s)
	}
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitInPredicate(s)
	}
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenPredicateContext struct {
	PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBetweenPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullPredicateContext struct {
	PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIsNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikePredicateContext struct {
	PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

func (s *LikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegexpPredicateContext struct {
	PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitRegexpPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MariaDBParser) predicate(_p int) (localctx IPredicateContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 690
	p.EnterRecursionRule(localctx, 690, MariaDBParserRULE_predicate, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(7385)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7383)
			p.Match(MariaDBParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7384)
			p.Match(MariaDBParserVAR_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7387)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1108, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1107, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7389)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(7390)
					p.ComparisonOperator()
				}
				{
					p.SetState(7391)

					var _x = p.predicate(9)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7393)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				p.SetState(7395)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserNOT {
					{
						p.SetState(7394)
						p.Match(MariaDBParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7397)
					p.Match(MariaDBParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7398)
					p.predicate(0)
				}
				{
					p.SetState(7399)
					p.Match(MariaDBParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7400)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7402)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(7403)
					p.Match(MariaDBParserSOUNDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7404)
					p.Match(MariaDBParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7405)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7406)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(7408)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserNOT {
					{
						p.SetState(7407)
						p.Match(MariaDBParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7410)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserREGEXP || _la == MariaDBParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7411)
					p.predicate(4)
				}

			case 5:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7412)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				p.SetState(7414)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserNOT {
					{
						p.SetState(7413)
						p.Match(MariaDBParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7416)
					p.Match(MariaDBParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7417)
					p.Match(MariaDBParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(7420)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1104, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(7418)
						p.SelectStatement()
					}

				case 2:
					{
						p.SetState(7419)
						p.Expressions()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(7422)
					p.Match(MariaDBParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7424)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(7425)
					p.Match(MariaDBParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7426)
					p.NullNotnull()
				}

			case 7:
				localctx = NewSubqueryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7427)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(7428)
					p.ComparisonOperator()
				}
				{
					p.SetState(7429)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SubqueryComparisonPredicateContext).quantifier = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MariaDBParserALL || _la == MariaDBParserANY || _la == MariaDBParserSOME) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SubqueryComparisonPredicateContext).quantifier = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7430)
					p.Match(MariaDBParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7431)
					p.SelectStatement()
				}
				{
					p.SetState(7432)
					p.Match(MariaDBParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 8:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7434)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(7436)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MariaDBParserNOT {
					{
						p.SetState(7435)
						p.Match(MariaDBParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7438)
					p.Match(MariaDBParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7439)
					p.predicate(0)
				}
				p.SetState(7442)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1106, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(7440)
						p.Match(MariaDBParserESCAPE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(7441)
						p.Match(MariaDBParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 9:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_predicate)
				p.SetState(7444)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(7445)
					p.Match(MariaDBParserMEMBER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7446)
					p.Match(MariaDBParserOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7447)
					p.Match(MariaDBParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7448)
					p.predicate(0)
				}
				{
					p.SetState(7449)
					p.Match(MariaDBParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1108, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionAtom
	return p
}

func InitEmptyExpressionAtomContext(p *ExpressionAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_expressionAtom
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyAll(ctx *ExpressionAtomContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCollateExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMysqlVariableExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedRowExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitNestedRowExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MathExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMathOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMathOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMathExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewExistsExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpressionAtomContext {
	var p = new(ExistsExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ExistsExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExpressionAtomContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXISTS, 0)
}

func (s *ExistsExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitExistsExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIntervalExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewSubqueryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionAtomContext {
	var p = new(SubqueryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *SubqueryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitSubqueryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext {
	var p = new(FunctionCallExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFunctionCallExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBinaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBitExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *MariaDBParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 692
	p.EnterRecursionRule(localctx, 692, MariaDBParserRULE_expressionAtom, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7457)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7458)
			p.FullColumnName()
		}

	case 3:
		localctx = NewFunctionCallExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7459)
			p.FunctionCall()
		}

	case 4:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7460)
			p.MysqlVariable()
		}

	case 5:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7461)
			p.UnaryOperator()
		}
		{
			p.SetState(7462)
			p.expressionAtom(10)
		}

	case 6:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7464)
			p.Match(MariaDBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7465)
			p.expressionAtom(9)
		}

	case 7:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7466)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7467)
			p.expression(0)
		}
		p.SetState(7472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MariaDBParserCOMMA {
			{
				p.SetState(7468)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7469)
				p.expression(0)
			}

			p.SetState(7474)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7475)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7477)
			p.Match(MariaDBParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7478)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7479)
			p.expression(0)
		}
		p.SetState(7482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MariaDBParserCOMMA {
			{
				p.SetState(7480)
				p.Match(MariaDBParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7481)
				p.expression(0)
			}

			p.SetState(7484)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7486)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewExistsExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7488)
			p.Match(MariaDBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7489)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7490)
			p.SelectStatement()
		}
		{
			p.SetState(7491)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSubqueryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7493)
			p.Match(MariaDBParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7494)
			p.SelectStatement()
		}
		{
			p.SetState(7495)
			p.Match(MariaDBParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7497)
			p.Match(MariaDBParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7498)
			p.expression(0)
		}
		{
			p.SetState(7499)
			p.IntervalType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1113, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7518)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1112, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_expressionAtom)
				p.SetState(7503)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(7504)
					p.BitOperator()
				}
				{
					p.SetState(7505)

					var _x = p.expressionAtom(4)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_expressionAtom)
				p.SetState(7507)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(7508)
					p.MathOperator()
				}
				{
					p.SetState(7509)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_expressionAtom)
				p.SetState(7511)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(7512)
					p.JsonOperator()
				}
				{
					p.SetState(7513)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MariaDBParserRULE_expressionAtom)
				p.SetState(7515)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(7516)
					p.Match(MariaDBParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7517)
					p.CollationName()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, MariaDBParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7523)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserNOT || ((int64((_la-1141)) & ^0x3f) == 0 && ((int64(1)<<(_la-1141))&387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, MariaDBParserRULE_comparisonOperator)
	p.SetState(7539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7525)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7526)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7527)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7528)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7529)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7530)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7531)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7532)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7533)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7534)
			p.Match(MariaDBParserEXCLAMATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7535)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7536)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7537)
			p.Match(MariaDBParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7538)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_logicalOperator
	return p
}

func InitEmptyLogicalOperatorContext(p *LogicalOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_logicalOperator
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, MariaDBParserRULE_logicalOperator)
	p.SetState(7548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7541)
			p.Match(MariaDBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7542)
			p.Match(MariaDBParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7543)
			p.Match(MariaDBParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7544)
			p.Match(MariaDBParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7545)
			p.Match(MariaDBParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7546)
			p.Match(MariaDBParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7547)
			p.Match(MariaDBParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_bitOperator
	return p
}

func InitEmptyBitOperatorContext(p *BitOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_bitOperator
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (s *BitOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitBitOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, MariaDBParserRULE_bitOperator)
	p.SetState(7557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MariaDBParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7550)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7551)
			p.Match(MariaDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7552)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7553)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7554)
			p.Match(MariaDBParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7555)
			p.Match(MariaDBParserBIT_XOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MariaDBParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7556)
			p.Match(MariaDBParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_mathOperator
	return p
}

func InitEmptyMathOperatorContext(p *MathOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_mathOperator
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTAR, 0)
}

func (s *MathOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIVIDE, 0)
}

func (s *MathOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODULE, 0)
}

func (s *MathOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIV, 0)
}

func (s *MathOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMOD, 0)
}

func (s *MathOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUS, 0)
}

func (s *MathOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (s *MathOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitMathOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) MathOperator() (localctx IMathOperatorContext) {
	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, MariaDBParserRULE_mathOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7559)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MariaDBParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, MariaDBParserRULE_jsonOperator)
	p.SetState(7566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1117, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7561)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7562)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7563)
			p.Match(MariaDBParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7564)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7565)
			p.Match(MariaDBParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARMSCII8() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	BIG5() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	CP1250() antlr.TerminalNode
	CP1251() antlr.TerminalNode
	CP1256() antlr.TerminalNode
	CP1257() antlr.TerminalNode
	CP850() antlr.TerminalNode
	CP852() antlr.TerminalNode
	CP866() antlr.TerminalNode
	CP932() antlr.TerminalNode
	DEC8() antlr.TerminalNode
	EUCJPMS() antlr.TerminalNode
	EUCKR() antlr.TerminalNode
	GB18030() antlr.TerminalNode
	GB2312() antlr.TerminalNode
	GBK() antlr.TerminalNode
	GEOSTD8() antlr.TerminalNode
	GREEK() antlr.TerminalNode
	HEBREW() antlr.TerminalNode
	HP8() antlr.TerminalNode
	KEYBCS2() antlr.TerminalNode
	KOI8R() antlr.TerminalNode
	KOI8U() antlr.TerminalNode
	LATIN1() antlr.TerminalNode
	LATIN2() antlr.TerminalNode
	LATIN5() antlr.TerminalNode
	LATIN7() antlr.TerminalNode
	MACCE() antlr.TerminalNode
	MACROMAN() antlr.TerminalNode
	SJIS() antlr.TerminalNode
	SWE7() antlr.TerminalNode
	TIS620() antlr.TerminalNode
	UCS2() antlr.TerminalNode
	UJIS() antlr.TerminalNode
	UTF16() antlr.TerminalNode
	UTF16LE() antlr.TerminalNode
	UTF32() antlr.TerminalNode
	UTF8() antlr.TerminalNode
	UTF8MB3() antlr.TerminalNode
	UTF8MB4() antlr.TerminalNode

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charsetNameBase
	return p
}

func InitEmptyCharsetNameBaseContext(p *CharsetNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_charsetNameBase
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitCharsetNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, MariaDBParserRULE_charsetNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7568)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserBINARY || ((int64((_la-753)) & ^0x3f) == 0 && ((int64(1)<<(_la-753))&2199023255551) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionLevelBase
	return p
}

func InitEmptyTransactionLevelBaseContext(p *TransactionLevelBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_transactionLevelBase
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitTransactionLevelBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, MariaDBParserRULE_transactionLevelBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7570)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-806)) & ^0x3f) == 0 && ((int64(1)<<(_la-806))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilegesBase
	return p
}

func InitEmptyPrivilegesBaseContext(p *PrivilegesBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_privilegesBase
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitPrivilegesBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, MariaDBParserRULE_privilegesBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7572)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-716)) & ^0x3f) == 0 && ((int64(1)<<(_la-716))&11828396035) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalTypeBase
	return p
}

func InitEmptyIntervalTypeBaseContext(p *IntervalTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_intervalTypeBase
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitIntervalTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, MariaDBParserRULE_intervalTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7574)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-695)) & ^0x3f) == 0 && ((int64(1)<<(_la-695))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	TEXT() antlr.TerminalNode

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dataTypeBase
	return p
}

func InitEmptyDataTypeBaseContext(p *DataTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_dataTypeBase
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitDataTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, MariaDBParserRULE_dataTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7576)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&1179679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	ATTRIBUTE() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BODY() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	PAGE_CHECKSUM() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EUR() antlr.TerminalNode
	EVEN() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWS() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INPLACE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INSTANT() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	JIS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALES() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMBER() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MID() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	NESTED() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOCOPY() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ODBC() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OF() antlr.TerminalNode
	OJ() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZER_COSTS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACKAGE() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PORT() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUERY_RESPONSE_TIME() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPLICAS() antlr.TerminalNode
	REPLICATE_DO_DB() antlr.TerminalNode
	REPLICATE_DO_TABLE() antlr.TerminalNode
	REPLICATE_IGNORE_DB() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE() antlr.TerminalNode
	REPLICATE_REWRITE_DB() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHARED() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLAVES() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TABLE_TYPE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USA() antlr.TerminalNode
	USER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	VALIDATION() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	WSREP_MEMBERSHIP() antlr.TerminalNode
	WSREP_STATUS() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	XML() antlr.TerminalNode
	BINLOG_MONITOR() antlr.TerminalNode
	BINLOG_REPLAY() antlr.TerminalNode
	CURRENT_ROLE() antlr.TerminalNode
	CYCLE() antlr.TerminalNode
	ENCRYPTED() antlr.TerminalNode
	ENCRYPTION_KEY_ID() antlr.TerminalNode
	FEDERATED_ADMIN() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	LASTVAL() antlr.TerminalNode
	LOCKED() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	MINVALUE() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	NOCACHE() antlr.TerminalNode
	NOCYCLE() antlr.TerminalNode
	NOMAXVALUE() antlr.TerminalNode
	NOMINVALUE() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	PREVIOUS() antlr.TerminalNode
	READ_ONLY_ADMIN() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPLICATION_MASTER_ADMIN() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SETVAL() antlr.TerminalNode
	SKIP_() antlr.TerminalNode
	STATEMENT() antlr.TerminalNode
	VIA() antlr.TerminalNode
	MONITOR() antlr.TerminalNode
	READ_ONLY() antlr.TerminalNode
	REPLAY() antlr.TerminalNode
	USER_STATISTICS() antlr.TerminalNode
	CLIENT_STATISTICS() antlr.TerminalNode
	INDEX_STATISTICS() antlr.TerminalNode
	TABLE_STATISTICS() antlr.TerminalNode

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_keywordsCanBeId
	return p
}

func InitEmptyKeywordsCanBeIdContext(p *KeywordsCanBeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_keywordsCanBeId
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserANY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BODY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBODY, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONDITION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_USER, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEMPTY, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHISTORY, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLATERAL, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOCALES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCALES, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNESTED, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORDINALITY, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPACKAGE, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPASSWORD_LOCK_TIME, 0)
}

func (s *KeywordsCanBeIdContext) PATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPATH, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY_RESPONSE_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUERY_RESPONSE_TIME, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICAS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICAS, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREUSE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(MariaDBParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLAVES, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) TYPES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTYPES, 0)
}

func (s *KeywordsCanBeIdContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNBOUNDED, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) WSREP_MEMBERSHIP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWSREP_MEMBERSHIP, 0)
}

func (s *KeywordsCanBeIdContext) WSREP_STATUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWSREP_STATUS, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(MariaDBParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(MariaDBParserXML, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_MONITOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_MONITOR, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_REPLAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBINLOG_REPLAY, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCURRENT_ROLE, 0)
}

func (s *KeywordsCanBeIdContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTED, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPTION_KEY_ID, 0)
}

func (s *KeywordsCanBeIdContext) FEDERATED_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFEDERATED_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLASTVAL, 0)
}

func (s *KeywordsCanBeIdContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCKED, 0)
}

func (s *KeywordsCanBeIdContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXTVAL, 0)
}

func (s *KeywordsCanBeIdContext) NOCACHE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCACHE, 0)
}

func (s *KeywordsCanBeIdContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) NOMAXVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NOMINVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNOMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPREVIOUS, 0)
}

func (s *KeywordsCanBeIdContext) READ_ONLY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD_ONLY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICA, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_MASTER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLICATION_MASTER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESTART() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRESTART, 0)
}

func (s *KeywordsCanBeIdContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEQUENCE, 0)
}

func (s *KeywordsCanBeIdContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSETVAL, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSKIP_, 0)
}

func (s *KeywordsCanBeIdContext) STATEMENT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTATEMENT, 0)
}

func (s *KeywordsCanBeIdContext) VIA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVIA, 0)
}

func (s *KeywordsCanBeIdContext) MONITOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMONITOR, 0)
}

func (s *KeywordsCanBeIdContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREAD_ONLY, 0)
}

func (s *KeywordsCanBeIdContext) REPLAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREPLAY, 0)
}

func (s *KeywordsCanBeIdContext) USER_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUSER_STATISTICS, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCLIENT_STATISTICS, 0)
}

func (s *KeywordsCanBeIdContext) INDEX_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINDEX_STATISTICS, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTABLE_STATISTICS, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitKeywordsCanBeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, MariaDBParserRULE_keywordsCanBeId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7578)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&649090574498545664) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&434896845670449217) != 0) || ((int64((_la-158)) & ^0x3f) == 0 && ((int64(1)<<(_la-158))&5121) != 0) || ((int64((_la-239)) & ^0x3f) == 0 && ((int64(1)<<(_la-239))&1769897061370560513) != 0) || ((int64((_la-305)) & ^0x3f) == 0 && ((int64(1)<<(_la-305))&-134217473) != 0) || ((int64((_la-369)) & ^0x3f) == 0 && ((int64(1)<<(_la-369))&-1) != 0) || ((int64((_la-434)) & ^0x3f) == 0 && ((int64(1)<<(_la-434))&-33554433) != 0) || ((int64((_la-498)) & ^0x3f) == 0 && ((int64(1)<<(_la-498))&-4612530443357519873) != 0) || ((int64((_la-562)) & ^0x3f) == 0 && ((int64(1)<<(_la-562))&-8589934593) != 0) || ((int64((_la-626)) & ^0x3f) == 0 && ((int64(1)<<(_la-626))&9203105838531592191) != 0) || ((int64((_la-690)) & ^0x3f) == 0 && ((int64(1)<<(_la-690))&8425078131550576671) != 0) || _la == MariaDBParserMEMORY || _la == MariaDBParserCATALOG_NAME || _la == MariaDBParserENGINE_ATTRIBUTE || _la == MariaDBParserSECONDARY_ENGINE_ATTRIBUTE || _la == MariaDBParserSCHEMA_NAME || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&65535) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	ADDTIME() antlr.TerminalNode
	AES_DECRYPT() antlr.TerminalNode
	AES_ENCRYPT() antlr.TerminalNode
	AREA() antlr.TerminalNode
	ASBINARY() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ASTEXT() antlr.TerminalNode
	ASWKB() antlr.TerminalNode
	ASWKT() antlr.TerminalNode
	ASYMMETRIC_DECRYPT() antlr.TerminalNode
	ASYMMETRIC_DERIVE() antlr.TerminalNode
	ASYMMETRIC_ENCRYPT() antlr.TerminalNode
	ASYMMETRIC_SIGN() antlr.TerminalNode
	ASYMMETRIC_VERIFY() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	ATAN2() antlr.TerminalNode
	BENCHMARK() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BIT_COUNT() antlr.TerminalNode
	BIT_LENGTH() antlr.TerminalNode
	BUFFER() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode
	CENTROID() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	COERCIBILITY() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COMPRESS() antlr.TerminalNode
	CONCAT() antlr.TerminalNode
	CONCAT_WS() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONV() antlr.TerminalNode
	CONVERT_TZ() antlr.TerminalNode
	COS() antlr.TerminalNode
	COT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CRC32() antlr.TerminalNode
	CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode
	CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode
	CREATE_DH_PARAMETERS() antlr.TerminalNode
	CREATE_DIGEST() antlr.TerminalNode
	CROSSES() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_FORMAT() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYNAME() antlr.TerminalNode
	DAYOFMONTH() antlr.TerminalNode
	DAYOFWEEK() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DECODE() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DES_DECRYPT() antlr.TerminalNode
	DES_ENCRYPT() antlr.TerminalNode
	DIMENSION() antlr.TerminalNode
	DISJOINT() antlr.TerminalNode
	ELT() antlr.TerminalNode
	ENCODE() antlr.TerminalNode
	ENCRYPT() antlr.TerminalNode
	ENDPOINT() antlr.TerminalNode
	ENVELOPE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORT_SET() antlr.TerminalNode
	EXTERIORRING() antlr.TerminalNode
	EXTRACTVALUE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	FIND_IN_SET() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND_ROWS() antlr.TerminalNode
	FROM_BASE64() antlr.TerminalNode
	FROM_DAYS() antlr.TerminalNode
	FROM_UNIXTIME() antlr.TerminalNode
	GEOMCOLLFROMTEXT() antlr.TerminalNode
	GEOMCOLLFROMWKB() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	GEOMETRYFROMTEXT() antlr.TerminalNode
	GEOMETRYFROMWKB() antlr.TerminalNode
	GEOMETRYN() antlr.TerminalNode
	GEOMETRYTYPE() antlr.TerminalNode
	GEOMFROMTEXT() antlr.TerminalNode
	GEOMFROMWKB() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GET_LOCK() antlr.TerminalNode
	GLENGTH() antlr.TerminalNode
	GREATEST() antlr.TerminalNode
	GTID_SUBSET() antlr.TerminalNode
	GTID_SUBTRACT() antlr.TerminalNode
	HEX() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IFNULL() antlr.TerminalNode
	INET6_ATON() antlr.TerminalNode
	INET6_NTOA() antlr.TerminalNode
	INET_ATON() antlr.TerminalNode
	INET_NTOA() antlr.TerminalNode
	INSTR() antlr.TerminalNode
	INTERIORRINGN() antlr.TerminalNode
	INTERSECTS() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ISCLOSED() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISSIMPLE() antlr.TerminalNode
	IS_FREE_LOCK() antlr.TerminalNode
	IS_IPV4() antlr.TerminalNode
	IS_IPV4_COMPAT() antlr.TerminalNode
	IS_IPV4_MAPPED() antlr.TerminalNode
	IS_IPV6() antlr.TerminalNode
	IS_USED_LOCK() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LAST_INSERT_ID() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LCASE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LINEFROMTEXT() antlr.TerminalNode
	LINEFROMWKB() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LINESTRINGFROMTEXT() antlr.TerminalNode
	LINESTRINGFROMWKB() antlr.TerminalNode
	LN() antlr.TerminalNode
	LOAD_FILE() antlr.TerminalNode
	LOCATE() antlr.TerminalNode
	LOG() antlr.TerminalNode
	LOG10() antlr.TerminalNode
	LOG2() antlr.TerminalNode
	LOWER() antlr.TerminalNode
	LPAD() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	MAKEDATE() antlr.TerminalNode
	MAKETIME() antlr.TerminalNode
	MAKE_SET() antlr.TerminalNode
	MASTER_POS_WAIT() antlr.TerminalNode
	MBRCONTAINS() antlr.TerminalNode
	MBRDISJOINT() antlr.TerminalNode
	MBREQUAL() antlr.TerminalNode
	MBRINTERSECTS() antlr.TerminalNode
	MBROVERLAPS() antlr.TerminalNode
	MBRTOUCHES() antlr.TerminalNode
	MBRWITHIN() antlr.TerminalNode
	MD5() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MLINEFROMTEXT() antlr.TerminalNode
	MLINEFROMWKB() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHNAME() antlr.TerminalNode
	MPOINTFROMTEXT() antlr.TerminalNode
	MPOINTFROMWKB() antlr.TerminalNode
	MPOLYFROMTEXT() antlr.TerminalNode
	MPOLYFROMWKB() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTILINESTRINGFROMTEXT() antlr.TerminalNode
	MULTILINESTRINGFROMWKB() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOINTFROMTEXT() antlr.TerminalNode
	MULTIPOINTFROMWKB() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MULTIPOLYGONFROMTEXT() antlr.TerminalNode
	MULTIPOLYGONFROMWKB() antlr.TerminalNode
	NAME_CONST() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NUMGEOMETRIES() antlr.TerminalNode
	NUMINTERIORRINGS() antlr.TerminalNode
	NUMPOINTS() antlr.TerminalNode
	OCT() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode
	ORD() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PERIOD_ADD() antlr.TerminalNode
	PERIOD_DIFF() antlr.TerminalNode
	PI() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POINTFROMTEXT() antlr.TerminalNode
	POINTFROMWKB() antlr.TerminalNode
	POINTN() antlr.TerminalNode
	POLYFROMTEXT() antlr.TerminalNode
	POLYFROMWKB() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POLYGONFROMTEXT() antlr.TerminalNode
	POLYGONFROMWKB() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	POW() antlr.TerminalNode
	POWER() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RADIANS() antlr.TerminalNode
	RAND() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RANDOM_BYTES() antlr.TerminalNode
	RELEASE_LOCK() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROUND() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	RPAD() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SEC_TO_TIME() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SHA() antlr.TerminalNode
	SHA1() antlr.TerminalNode
	SHA2() antlr.TerminalNode
	SIGN() antlr.TerminalNode
	SIN() antlr.TerminalNode
	SLEEP() antlr.TerminalNode
	SOUNDEX() antlr.TerminalNode
	SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode
	SQRT() antlr.TerminalNode
	SRID() antlr.TerminalNode
	STARTPOINT() antlr.TerminalNode
	STRCMP() antlr.TerminalNode
	STR_TO_DATE() antlr.TerminalNode
	ST_AREA() antlr.TerminalNode
	ST_ASBINARY() antlr.TerminalNode
	ST_ASTEXT() antlr.TerminalNode
	ST_ASWKB() antlr.TerminalNode
	ST_ASWKT() antlr.TerminalNode
	ST_BUFFER() antlr.TerminalNode
	ST_CENTROID() antlr.TerminalNode
	ST_CONTAINS() antlr.TerminalNode
	ST_CROSSES() antlr.TerminalNode
	ST_DIFFERENCE() antlr.TerminalNode
	ST_DIMENSION() antlr.TerminalNode
	ST_DISJOINT() antlr.TerminalNode
	ST_DISTANCE() antlr.TerminalNode
	ST_ENDPOINT() antlr.TerminalNode
	ST_ENVELOPE() antlr.TerminalNode
	ST_EQUALS() antlr.TerminalNode
	ST_EXTERIORRING() antlr.TerminalNode
	ST_GEOMCOLLFROMTEXT() antlr.TerminalNode
	ST_GEOMCOLLFROMTXT() antlr.TerminalNode
	ST_GEOMCOLLFROMWKB() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	ST_GEOMETRYFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYFROMWKB() antlr.TerminalNode
	ST_GEOMETRYN() antlr.TerminalNode
	ST_GEOMETRYTYPE() antlr.TerminalNode
	ST_GEOMFROMTEXT() antlr.TerminalNode
	ST_GEOMFROMWKB() antlr.TerminalNode
	ST_INTERIORRINGN() antlr.TerminalNode
	ST_INTERSECTION() antlr.TerminalNode
	ST_INTERSECTS() antlr.TerminalNode
	ST_ISCLOSED() antlr.TerminalNode
	ST_ISEMPTY() antlr.TerminalNode
	ST_ISSIMPLE() antlr.TerminalNode
	ST_LINEFROMTEXT() antlr.TerminalNode
	ST_LINEFROMWKB() antlr.TerminalNode
	ST_LINESTRINGFROMTEXT() antlr.TerminalNode
	ST_LINESTRINGFROMWKB() antlr.TerminalNode
	ST_NUMGEOMETRIES() antlr.TerminalNode
	ST_NUMINTERIORRING() antlr.TerminalNode
	ST_NUMINTERIORRINGS() antlr.TerminalNode
	ST_NUMPOINTS() antlr.TerminalNode
	ST_OVERLAPS() antlr.TerminalNode
	ST_POINTFROMTEXT() antlr.TerminalNode
	ST_POINTFROMWKB() antlr.TerminalNode
	ST_POINTN() antlr.TerminalNode
	ST_POLYFROMTEXT() antlr.TerminalNode
	ST_POLYFROMWKB() antlr.TerminalNode
	ST_POLYGONFROMTEXT() antlr.TerminalNode
	ST_POLYGONFROMWKB() antlr.TerminalNode
	ST_SRID() antlr.TerminalNode
	ST_STARTPOINT() antlr.TerminalNode
	ST_SYMDIFFERENCE() antlr.TerminalNode
	ST_TOUCHES() antlr.TerminalNode
	ST_UNION() antlr.TerminalNode
	ST_WITHIN() antlr.TerminalNode
	ST_X() antlr.TerminalNode
	ST_Y() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBSTRING_INDEX() antlr.TerminalNode
	SUBTIME() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	TAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_FORMAT() antlr.TerminalNode
	TIME_TO_SEC() antlr.TerminalNode
	TOUCHES() antlr.TerminalNode
	TO_BASE64() antlr.TerminalNode
	TO_DAYS() antlr.TerminalNode
	TO_SECONDS() antlr.TerminalNode
	UCASE() antlr.TerminalNode
	UNCOMPRESS() antlr.TerminalNode
	UNCOMPRESSED_LENGTH() antlr.TerminalNode
	UNHEX() antlr.TerminalNode
	UNIX_TIMESTAMP() antlr.TerminalNode
	UPDATEXML() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	UUID() antlr.TerminalNode
	UUID_SHORT() antlr.TerminalNode
	VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKDAY() antlr.TerminalNode
	WEEKOFYEAR() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARWEEK() antlr.TerminalNode
	Y_FUNCTION() antlr.TerminalNode
	X_FUNCTION() antlr.TerminalNode
	JSON_ARRAY() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode
	JSON_QUOTE() antlr.TerminalNode
	JSON_CONTAINS() antlr.TerminalNode
	JSON_CONTAINS_PATH() antlr.TerminalNode
	JSON_EXTRACT() antlr.TerminalNode
	JSON_KEYS() antlr.TerminalNode
	JSON_OVERLAPS() antlr.TerminalNode
	JSON_SEARCH() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_ARRAY_APPEND() antlr.TerminalNode
	JSON_ARRAY_INSERT() antlr.TerminalNode
	JSON_INSERT() antlr.TerminalNode
	JSON_MERGE() antlr.TerminalNode
	JSON_MERGE_PATCH() antlr.TerminalNode
	JSON_MERGE_PRESERVE() antlr.TerminalNode
	JSON_REMOVE() antlr.TerminalNode
	JSON_REPLACE() antlr.TerminalNode
	JSON_SET() antlr.TerminalNode
	JSON_UNQUOTE() antlr.TerminalNode
	JSON_DEPTH() antlr.TerminalNode
	JSON_LENGTH() antlr.TerminalNode
	JSON_TYPE() antlr.TerminalNode
	JSON_VALID() antlr.TerminalNode
	JSON_TABLE() antlr.TerminalNode
	JSON_SCHEMA_VALID() antlr.TerminalNode
	JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode
	JSON_PRETTY() antlr.TerminalNode
	JSON_STORAGE_FREE() antlr.TerminalNode
	JSON_STORAGE_SIZE() antlr.TerminalNode
	JSON_ARRAYAGG() antlr.TerminalNode
	JSON_OBJECTAGG() antlr.TerminalNode
	LASTVAL() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	SETVAL() antlr.TerminalNode

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionNameBase
	return p
}

func InitEmptyFunctionNameBaseContext(p *FunctionNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MariaDBParserRULE_functionNameBase
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MariaDBParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(MariaDBParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(MariaDBParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(MariaDBParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(MariaDBParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MariaDBParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(MariaDBParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserLASTVAL, 0)
}

func (s *FunctionNameBaseContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserNEXTVAL, 0)
}

func (s *FunctionNameBaseContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(MariaDBParserSETVAL, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MariaDBParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MariaDBParserVisitor:
		return t.VisitFunctionNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MariaDBParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, MariaDBParserRULE_functionNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7580)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MariaDBParserDATABASE || ((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&22517998136852481) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17179869161) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&8796109397507) != 0) || _la == MariaDBParserINVISIBLE || ((int64((_la-677)) & ^0x3f) == 0 && ((int64(1)<<(_la-677))&66846721) != 0) || _la == MariaDBParserSESSION_VARIABLES_ADMIN || ((int64((_la-810)) & ^0x3f) == 0 && ((int64(1)<<(_la-810))&-8589934599) != 0) || ((int64((_la-874)) & ^0x3f) == 0 && ((int64(1)<<(_la-874))&-257) != 0) || ((int64((_la-938)) & ^0x3f) == 0 && ((int64(1)<<(_la-938))&-1) != 0) || ((int64((_la-1002)) & ^0x3f) == 0 && ((int64(1)<<(_la-1002))&-529) != 0) || ((int64((_la-1066)) & ^0x3f) == 0 && ((int64(1)<<(_la-1066))&2111062325329919) != 0) || _la == MariaDBParserMOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *MariaDBParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 344:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 345:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 346:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MariaDBParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MariaDBParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MariaDBParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 12)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
